Open∇FOAM
The Open Source CFD Toolbox
User Guide
Version 1.6
24th July 2009
U-2
Copyright c 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 OpenCFD
Limited.
Permission is granted to copy, distribute and/or modify this document under the terms
of the GNU Free Documentation License, Version 1.2 published by the Free Software
Foundation; with no Invariant Sections, no Back-Cover Texts and one Front-Cover Text:
“Available free from openfoam.org.” A copy of the license is included in the section
entitled “GNU Free Documentation License”.
This document is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.
Typeset in LATEX.
Open∇FOAM-1.6
U-3
GNU Free Documentation License
Version 1.2, November 2002
Copyright c 2000,2001,2002 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
Everyone is permitted to copy and distribute verbatim copies of this license document, but
changing it is not allowed.
Preamble
The purpose of this License is to make a manual, textbook, or other functional and useful
document “free” in the sense of freedom: to assure everyone the eﬀective freedom to copy and
redistribute it, with or without modifying it, either commercially or noncommercially. Secon-
darily, this License preserves for the author and publisher a way to get credit for their work,
while not being considered responsible for modiﬁcations made by others.
This License is a kind of “copyleft”, which means that derivative works of the document
must themselves be free in the same sense. It complements the GNU General Public License,
which is a copyleft license designed for free software.
We have designed this License in order to use it for manuals for free software, because free
software needs free documentation: a free program should come with manuals providing the
same freedoms that the software does. But this License is not limited to software manuals; it
can be used for any textual work, regardless of subject matter or whether it is published as a
printed book. We recommend this License principally for works whose purpose is instruction or
reference.
1. APPLICABILITY AND DEFINITIONS
This License applies to any manual or other work, in any medium, that contains a notice placed
by the copyright holder saying it can be distributed under the terms of this License. Such a
notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under
the conditions stated herein. The “Document”, below, refers to any such manual or work.
Any member of the public is a licensee, and is addressed as “you”. You accept the license if
you copy, modify or distribute the work in a way requiring permission under copyright law.
A “Modiﬁed Version” of the Document means any work containing the Document or
a portion of it, either copied verbatim, or with modiﬁcations and/or translated into another
language.
A “Secondary Section” is a named appendix or a front-matter section of the Document
that deals exclusively with the relationship of the publishers or authors of the Document to
the Document’s overall subject (or to related matters) and contains nothing that could fall
directly within that overall subject. (Thus, if the Document is in part a textbook of mathe-
matics, a Secondary Section may not explain any mathematics.) The relationship could be a
matter of historical connection with the subject or with related matters, or of legal, commercial,
philosophical, ethical or political position regarding them.
The “Invariant Sections” are certain Secondary Sections whose titles are designated, as
being those of Invariant Sections, in the notice that says that the Document is released under
this License. If a section does not ﬁt the above deﬁnition of Secondary then it is not allowed to be
designated as Invariant. The Document may contain zero Invariant Sections. If the Document
does not identify any Invariant Sections then there are none.
The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts
or Back-Cover Texts, in the notice that says that the Document is released under this License.
A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.
A “Transparent” copy of the Document means a machine-readable copy, represented in
a format whose speciﬁcation is available to the general public, that is suitable for revising the
Open∇FOAM-1.6
U-4
document straightforwardly with generic text editors or (for images composed of pixels) generic
paint programs or (for drawings) some widely available drawing editor, and that is suitable for
input to text formatters or for automatic translation to a variety of formats suitable for input to
text formatters. A copy made in an otherwise Transparent ﬁle format whose markup, or absence
of markup, has been arranged to thwart or discourage subsequent modiﬁcation by readers is not
Transparent. An image format is not Transparent if used for any substantial amount of text. A
copy that is not “Transparent” is called “Opaque”.
Examples of suitable formats for Transparent copies include plain ASCII without markup,
Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD,
and standard-conforming simple HTML, PostScript or PDF designed for human modiﬁcation.
Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include
proprietary formats that can be read and edited only by proprietary word processors, SGML or
XML for which the DTD and/or processing tools are not generally available, and the machine-
generated HTML, PostScript or PDF produced by some word processors for output purposes
only.
The “Title Page” means, for a printed book, the title page itself, plus such following pages
as are needed to hold, legibly, the material this License requires to appear in the title page. For
works in formats which do not have any title page as such, “Title Page” means the text near
the most prominent appearance of the work’s title, preceding the beginning of the body of the
text.
A section “Entitled XYZ” means a named subunit of the Document whose title either is
precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another
language. (Here XYZ stands for a speciﬁc section name mentioned below, such as “Acknowl-
edgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Ti-
tle” of such a section when you modify the Document means that it remains a section “Entitled
XYZ” according to this deﬁnition.
The Document may include Warranty Disclaimers next to the notice which states that this
License applies to the Document. These Warranty Disclaimers are considered to be included by
reference in this License, but only as regards disclaiming warranties: any other implication that
these Warranty Disclaimers may have is void and has no eﬀect on the meaning of this License.
2. VERBATIM COPYING
You may copy and distribute the Document in any medium, either commercially or noncom-
mercially, provided that this License, the copyright notices, and the license notice saying this
License applies to the Document are reproduced in all copies, and that you add no other con-
ditions whatsoever to those of this License. You may not use technical measures to obstruct or
control the reading or further copying of the copies you make or distribute. However, you may
accept compensation in exchange for copies. If you distribute a large enough number of copies
you must also follow the conditions in section 3.
You may also lend copies, under the same conditions stated above, and you may publicly
display copies.
3. COPYING IN QUANTITY
If you publish printed copies (or copies in media that commonly have printed covers) of the
Document, numbering more than 100, and the Document’s license notice requires Cover Texts,
you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts:
Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers
must also clearly and legibly identify you as the publisher of these copies. The front cover must
present the full title with all words of the title equally prominent and visible. You may add
other material on the covers in addition. Copying with changes limited to the covers, as long as
they preserve the title of the Document and satisfy these conditions, can be treated as verbatim
copying in other respects.
Open∇FOAM-1.6
U-5
If the required texts for either cover are too voluminous to ﬁt legibly, you should put the ﬁrst
ones listed (as many as ﬁt reasonably) on the actual cover, and continue the rest onto adjacent
pages.
If you publish or distribute Opaque copies of the Document numbering more than 100, you
must either include a machine-readable Transparent copy along with each Opaque copy, or state
in or with each Opaque copy a computer-network location from which the general network-using
public has access to download using public-standard network protocols a complete Transparent
copy of the Document, free of added material. If you use the latter option, you must take
reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated location until at least one
year after the last time you distribute an Opaque copy (directly or through your agents or
retailers) of that edition to the public.
It is requested, but not required, that you contact the authors of the Document well before
redistributing any large number of copies, to give them a chance to provide you with an updated
version of the Document.
4. MODIFICATIONS
You may copy and distribute a Modiﬁed Version of the Document under the conditions of
sections 2 and 3 above, provided that you release the Modiﬁed Version under precisely this
License, with the Modiﬁed Version ﬁlling the role of the Document, thus licensing distribution
and modiﬁcation of the Modiﬁed Version to whoever possesses a copy of it. In addition, you
must do these things in the Modiﬁed Version:
A. Use in the Title Page (and on the covers, if any) a title distinct from that of the Document,
and from those of previous versions (which should, if there were any, be listed in the
History section of the Document). You may use the same title as a previous version if the
original publisher of that version gives permission.
B. List on the Title Page, as authors, one or more persons or entities responsible for au-
thorship of the modiﬁcations in the Modiﬁed Version, together with at least ﬁve of the
principal authors of the Document (all of its principal authors, if it has fewer than ﬁve),
unless they release you from this requirement.
C. State on the Title page the name of the publisher of the Modiﬁed Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modiﬁcations adjacent to the other copyright
notices.
F. Include, immediately after the copyright notices, a license notice giving the public per-
mission to use the Modiﬁed Version under the terms of this License, in the form shown
in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections and required Cover Texts
given in the Document’s license notice.
H. Include an unaltered copy of this License.
I. Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating
at least the title, year, new authors, and publisher of the Modiﬁed Version as given on the
Title Page. If there is no section Entitled “History” in the Document, create one stating
the title, year, authors, and publisher of the Document as given on its Title Page, then
add an item describing the Modiﬁed Version as stated in the previous sentence.
Open∇FOAM-1.6
U-6
J. Preserve the network location, if any, given in the Document for public access to a Trans-
parent copy of the Document, and likewise the network locations given in the Document
for previous versions it was based on. These may be placed in the “History” section. You
may omit a network location for a work that was published at least four years before the
Document itself, or if the original publisher of the version it refers to gives permission.
K. For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the
section, and preserve in the section all the substance and tone of each of the contributor
acknowledgements and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document, unaltered in their text and in their
titles. Section numbers or the equivalent are not considered part of the section titles.
M. Delete any section Entitled “Endorsements”. Such a section may not be included in the
Modiﬁed Version.
N. Do not retitle any existing section to be Entitled “Endorsements” or to conﬂict in title
with any Invariant Section.
O. Preserve any Warranty Disclaimers.
If the Modiﬁed Version includes new front-matter sections or appendices that qualify as
Secondary Sections and contain no material copied from the Document, you may at your option
designate some or all of these sections as invariant. To do this, add their titles to the list of
Invariant Sections in the Modiﬁed Version’s license notice. These titles must be distinct from
any other section titles.
You may add a section Entitled “Endorsements”, provided it contains nothing but endorse-
ments of your Modiﬁed Version by various parties–for example, statements of peer review or
that the text has been approved by an organization as the authoritative deﬁnition of a standard.
You may add a passage of up to ﬁve words as a Front-Cover Text, and a passage of up to
25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modiﬁed Version.
Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through
arrangements made by) any one entity. If the Document already includes a cover text for the
same cover, previously added by you or by arrangement made by the same entity you are acting
on behalf of, you may not add another; but you may replace the old one, on explicit permission
from the previous publisher that added the old one.
The author(s) and publisher(s) of the Document do not by this License give permission to
use their names for publicity for or to assert or imply endorsement of any Modiﬁed Version.
5. COMBINING DOCUMENTS
You may combine the Document with other documents released under this License, under
the terms deﬁned in section 4 above for modiﬁed versions, provided that you include in the
combination all of the Invariant Sections of all of the original documents, unmodiﬁed, and list
them all as Invariant Sections of your combined work in its license notice, and that you preserve
all their Warranty Disclaimers.
The combined work need only contain one copy of this License, and multiple identical In-
variant Sections may be replaced with a single copy. If there are multiple Invariant Sections
with the same name but diﬀerent contents, make the title of each such section unique by adding
at the end of it, in parentheses, the name of the original author or publisher of that section if
known, or else a unique number. Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
In the combination, you must combine any sections Entitled “History” in the various origi-
nal documents, forming one section Entitled “History”; likewise combine any sections Entitled
“Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections
Entitled “Endorsements”.
Open∇FOAM-1.6
U-7
6. COLLECTIONS OF DOCUMENTS
You may make a collection consisting of the Document and other documents released under
this License, and replace the individual copies of this License in the various documents with a
single copy that is included in the collection, provided that you follow the rules of this License
for verbatim copying of each of the documents in all other respects.
You may extract a single document from such a collection, and distribute it individually
under this License, provided you insert a copy of this License into the extracted document, and
follow this License in all other respects regarding verbatim copying of that document.
7. AGGREGATION WITH INDEPENDENT WORKS
A compilation of the Document or its derivatives with other separate and independent docu-
ments or works, in or on a volume of a storage or distribution medium, is called an “aggregate”
if the copyright resulting from the compilation is not used to limit the legal rights of the com-
pilation’s users beyond what the individual works permit. When the Document is included in
an aggregate, this License does not apply to the other works in the aggregate which are not
themselves derivative works of the Document.
If the Cover Text requirement of section 3 is applicable to these copies of the Document,
then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts
may be placed on covers that bracket the Document within the aggregate, or the electronic
equivalent of covers if the Document is in electronic form. Otherwise they must appear on
printed covers that bracket the whole aggregate.
8. TRANSLATION
Translation is considered a kind of modiﬁcation, so you may distribute translations of the
Document under the terms of section 4. Replacing Invariant Sections with translations requires
special permission from their copyright holders, but you may include translations of some or
all Invariant Sections in addition to the original versions of these Invariant Sections. You
may include a translation of this License, and all the license notices in the Document, and any
Warranty Disclaimers, provided that you also include the original English version of this License
and the original versions of those notices and disclaimers. In case of a disagreement between
the translation and the original version of this License or a notice or disclaimer, the original
version will prevail.
If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”,
the requirement (section 4) to Preserve its Title (section 1) will typically require changing the
actual title.
9. TERMINATION
You may not copy, modify, sublicense, or distribute the Document except as expressly provided
for under this License. Any other attempt to copy, modify, sublicense or distribute the Document
is void, and will automatically terminate your rights under this License. However, parties who
have received copies, or rights, from you under this License will not have their licenses terminated
so long as such parties remain in full compliance.
10. FUTURE REVISIONS OF THIS LICENSE
The Free Software Foundation may publish new, revised versions of the GNU Free Documenta-
tion License from time to time. Such new versions will be similar in spirit to the present version,
but may diﬀer in detail to address new problems or concerns. See http://www.gnu.org/copyleft/.
Each version of the License is given a distinguishing version number. If the Document
speciﬁes that a particular numbered version of this License “or any later version” applies to it,
you have the option of following the terms and conditions either of that speciﬁed version or of
Open∇FOAM-1.6
U-8
any later version that has been published (not as a draft) by the Free Software Foundation. If
the Document does not specify a version number of this License, you may choose any version
ever published (not as a draft) by the Free Software Foundation.
Open∇FOAM-1.6
U-9
Trademarks
ANSYS is a registered trademark of ANSYS Inc.
CFX is a registered trademark of Ansys Inc.
CHEMKIN is a registered trademark of Reaction Design Corporation
EnSight is a registered trademark of Computational Engineering International Ltd.
Fieldview is a registered trademark of Intelligent Light
Fluent is a registered trademark of Ansys Inc.
GAMBIT is a registered trademark of Ansys Inc.
Icem-CFD is a registered trademark of Ansys Inc.
I-DEAS is a registered trademark of Structural Dynamics Research Corporation
JAVA is a registered trademark of Sun Microsystems Inc.
Linux is a registered trademark of Linus Torvalds
OpenFOAM is a registered trademark of OpenCFD Ltd
ParaView is a registered trademark of Kitware
STAR-CD is a registered trademark of Computational Dynamics Ltd.
UNIX is a registered trademark of The Open Group
Open∇FOAM-1.6
U-10
Open∇FOAM-1.6
Contents
Copyright Notice U-2
GNU Free Documentation Licence U-3
1. APPLICABILITY AND DEFINITIONS . . . . . . . . . . . . . . . . . U-3
2. VERBATIM COPYING . . . . . . . . . . . . . . . . . . . . . . . . . U-4
3. COPYING IN QUANTITY . . . . . . . . . . . . . . . . . . . . . . . . U-4
4. MODIFICATIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-5
5. COMBINING DOCUMENTS . . . . . . . . . . . . . . . . . . . . . . U-6
6. COLLECTIONS OF DOCUMENTS . . . . . . . . . . . . . . . . . . . U-7
7. AGGREGATION WITH INDEPENDENT WORKS . . . . . . . . . . U-7
8. TRANSLATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-7
9. TERMINATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-7
10. FUTURE REVISIONS OF THIS LICENSE . . . . . . . . . . . . . . U-7
Trademarks U-9
Contents U-11
1 Introduction U-17
2 Tutorials U-19
2.1 Lid-driven cavity ﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . U-19
2.1.1 Pre-processing . . . . . . . . . . . . . . . . . . . . . . . . . . U-20
2.1.1.1 Mesh generation . . . . . . . . . . . . . . . . . . . U-20
2.1.1.2 Boundary and initial conditions . . . . . . . . . . . U-22
2.1.1.3 Physical properties . . . . . . . . . . . . . . . . . . U-23
2.1.1.4 Control . . . . . . . . . . . . . . . . . . . . . . . . U-23
2.1.1.5 Discretisation and linear-solver settings . . . . . . . U-25
2.1.2 Viewing the mesh . . . . . . . . . . . . . . . . . . . . . . . . U-25
2.1.3 Running an application . . . . . . . . . . . . . . . . . . . . . U-26
2.1.4 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-28
2.1.4.1 Isosurface and contour plots . . . . . . . . . . . . . U-28
2.1.4.2 Vector plots . . . . . . . . . . . . . . . . . . . . . . U-30
2.1.4.3 Streamline plots . . . . . . . . . . . . . . . . . . . U-30
2.1.5 Increasing the mesh resolution . . . . . . . . . . . . . . . . . U-30
2.1.5.1 Creating a new case using an existing case . . . . . U-32
2.1.5.2 Creating the ﬁner mesh . . . . . . . . . . . . . . . U-32
2.1.5.3 Mapping the coarse mesh results onto the ﬁne mesh U-32
2.1.5.4 Control adjustments . . . . . . . . . . . . . . . . . U-33
2.1.5.5 Running the code as a background process . . . . . U-33
2.1.5.6 Vector plot with the reﬁned mesh . . . . . . . . . . U-33
U-12 Contents
2.1.5.7 Plotting graphs . . . . . . . . . . . . . . . . . . . . U-34
2.1.6 Introducing mesh grading . . . . . . . . . . . . . . . . . . . U-36
2.1.6.1 Creating the graded mesh . . . . . . . . . . . . . . U-37
2.1.6.2 Changing time and time step . . . . . . . . . . . . U-38
2.1.6.3 Mapping ﬁelds . . . . . . . . . . . . . . . . . . . . U-39
2.1.7 Increasing the Reynolds number . . . . . . . . . . . . . . . . U-39
2.1.7.1 Pre-processing . . . . . . . . . . . . . . . . . . . . U-39
2.1.7.2 Running the code . . . . . . . . . . . . . . . . . . . U-39
2.1.8 High Reynolds number ﬂow . . . . . . . . . . . . . . . . . . U-40
2.1.8.1 Pre-processing . . . . . . . . . . . . . . . . . . . . U-41
2.1.8.2 Running the code . . . . . . . . . . . . . . . . . . . U-42
2.1.9 Changing the case geometry . . . . . . . . . . . . . . . . . . U-43
2.1.10 Post-processing the modiﬁed geometry . . . . . . . . . . . . U-46
2.2 Stress analysis of a plate with a hole . . . . . . . . . . . . . . . . . U-46
2.2.1 Mesh generation . . . . . . . . . . . . . . . . . . . . . . . . U-47
2.2.1.1 Boundary and initial conditions . . . . . . . . . . . U-49
2.2.1.2 Mechanical properties . . . . . . . . . . . . . . . . U-51
2.2.1.3 Thermal properties . . . . . . . . . . . . . . . . . . U-51
2.2.1.4 Control . . . . . . . . . . . . . . . . . . . . . . . . U-51
2.2.1.5 Discretisation schemes and linear-solver control . . U-52
2.2.2 Running the code . . . . . . . . . . . . . . . . . . . . . . . . U-54
2.2.3 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-54
2.2.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-55
2.2.4.1 Increasing mesh resolution . . . . . . . . . . . . . . U-55
2.2.4.2 Introducing mesh grading . . . . . . . . . . . . . . U-56
2.2.4.3 Changing the plate size . . . . . . . . . . . . . . . U-56
2.3 Breaking of a dam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-56
2.3.1 Mesh generation . . . . . . . . . . . . . . . . . . . . . . . . U-56
2.3.2 Boundary conditions . . . . . . . . . . . . . . . . . . . . . . U-58
2.3.3 Setting initial ﬁeld . . . . . . . . . . . . . . . . . . . . . . . U-58
2.3.4 Fluid properties . . . . . . . . . . . . . . . . . . . . . . . . . U-59
2.3.5 Turbulence modelling . . . . . . . . . . . . . . . . . . . . . . U-60
2.3.6 Time step control . . . . . . . . . . . . . . . . . . . . . . . . U-60
2.3.7 Discretisation schemes . . . . . . . . . . . . . . . . . . . . . U-61
2.3.8 Linear-solver control . . . . . . . . . . . . . . . . . . . . . . U-62
2.3.9 Running the code . . . . . . . . . . . . . . . . . . . . . . . . U-62
2.3.10 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-63
2.3.11 Running in parallel . . . . . . . . . . . . . . . . . . . . . . . U-63
2.3.12 Post-processing a case run in parallel . . . . . . . . . . . . . U-67
3 Applications and libraries U-69
3.1 The programming language of OpenFOAM . . . . . . . . . . . . . . U-69
3.1.1 Language in general . . . . . . . . . . . . . . . . . . . . . . U-69
3.1.2 Object-orientation and C++ . . . . . . . . . . . . . . . . . . U-70
3.1.3 Equation representation . . . . . . . . . . . . . . . . . . . . U-70
3.1.4 Solver codes . . . . . . . . . . . . . . . . . . . . . . . . . . . U-71
3.2 Compiling applications and libraries . . . . . . . . . . . . . . . . . . U-71
3.2.1 Header .H ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . U-71
3.2.2 Compiling with wmake . . . . . . . . . . . . . . . . . . . . . U-73
3.2.2.1 Including headers . . . . . . . . . . . . . . . . . . . U-73
3.2.2.2 Linking to libraries . . . . . . . . . . . . . . . . . . U-74
Open∇FOAM-1.6
Contents U-13
3.2.2.3 Source ﬁles to be compiled . . . . . . . . . . . . . . U-74
3.2.2.4 Running wmake . . . . . . . . . . . . . . . . . . . . U-75
3.2.2.5 wmake environment variables . . . . . . . . . . . . U-75
3.2.3 Removing dependency lists: wclean and rmdepall . . . . . . . U-75
3.2.4 Compilation example: the pisoFoam application . . . . . . . U-76
3.2.5 Debug messaging and optimisation switches . . . . . . . . . U-79
3.2.6 Linking new user-deﬁned libraries to existing applications . . U-80
3.3 Running applications . . . . . . . . . . . . . . . . . . . . . . . . . . U-80
3.4 Running applications in parallel . . . . . . . . . . . . . . . . . . . . U-81
3.4.1 Decomposition of mesh and initial ﬁeld data . . . . . . . . . U-81
3.4.2 Running a decomposed case . . . . . . . . . . . . . . . . . . U-83
3.4.3 Distributing data across several disks . . . . . . . . . . . . . U-84
3.4.4 Post-processing parallel processed cases . . . . . . . . . . . . U-85
3.4.4.1 Reconstructing mesh and data . . . . . . . . . . . U-85
3.4.4.2 Post-processing decomposed cases . . . . . . . . . . U-85
3.5 Standard solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-85
3.6 Standard utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-88
3.7 Standard libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-94
4 OpenFOAM cases U-101
4.1 File structure of OpenFOAM cases . . . . . . . . . . . . . . . . . . U-101
4.2 Basic input/output ﬁle format . . . . . . . . . . . . . . . . . . . . . U-102
4.2.1 General syntax rules . . . . . . . . . . . . . . . . . . . . . . U-102
4.2.2 Dictionaries . . . . . . . . . . . . . . . . . . . . . . . . . . . U-102
4.2.3 The data ﬁle header . . . . . . . . . . . . . . . . . . . . . . U-103
4.2.4 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-104
4.2.5 Scalars, vectors and tensors . . . . . . . . . . . . . . . . . . U-105
4.2.6 Dimensional units . . . . . . . . . . . . . . . . . . . . . . . . U-105
4.2.7 Dimensioned types . . . . . . . . . . . . . . . . . . . . . . . U-106
4.2.8 Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-106
4.2.9 Directives and macro substitutions . . . . . . . . . . . . . . U-107
4.3 Time and data input/output control . . . . . . . . . . . . . . . . . U-108
4.4 Numerical schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . U-110
4.4.1 Interpolation schemes . . . . . . . . . . . . . . . . . . . . . . U-112
4.4.1.1 Schemes for strictly bounded scalar ﬁelds . . . . . U-113
4.4.1.2 Schemes for vector ﬁelds . . . . . . . . . . . . . . . U-113
4.4.2 Surface normal gradient schemes . . . . . . . . . . . . . . . U-114
4.4.3 Gradient schemes . . . . . . . . . . . . . . . . . . . . . . . . U-114
4.4.4 Laplacian schemes . . . . . . . . . . . . . . . . . . . . . . . U-115
4.4.5 Divergence schemes . . . . . . . . . . . . . . . . . . . . . . . U-115
4.4.6 Time schemes . . . . . . . . . . . . . . . . . . . . . . . . . . U-116
4.4.7 Flux calculation . . . . . . . . . . . . . . . . . . . . . . . . . U-117
4.5 Solution and algorithm control . . . . . . . . . . . . . . . . . . . . . U-117
4.5.1 Linear solver control . . . . . . . . . . . . . . . . . . . . . . U-117
4.5.1.1 Solution tolerances . . . . . . . . . . . . . . . . . . U-118
4.5.1.2 Preconditioned conjugate gradient solvers . . . . . U-119
4.5.1.3 Smooth solvers . . . . . . . . . . . . . . . . . . . . U-119
4.5.1.4 Geometric-algebraic multi-grid solvers . . . . . . . U-119
4.5.2 Solution under-relaxation . . . . . . . . . . . . . . . . . . . U-120
4.5.3 PISO and SIMPLE algorithms . . . . . . . . . . . . . . . . . U-121
4.5.3.1 Pressure referencing . . . . . . . . . . . . . . . . . U-121
Open∇FOAM-1.6
U-14 Contents
4.5.4 Other parameters . . . . . . . . . . . . . . . . . . . . . . . . U-122
5 Mesh generation and conversion U-123
5.1 Mesh description . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-123
5.1.1 Mesh speciﬁcation and validity constraints . . . . . . . . . . U-123
5.1.1.1 Points . . . . . . . . . . . . . . . . . . . . . . . . . U-124
5.1.1.2 Faces . . . . . . . . . . . . . . . . . . . . . . . . . U-124
5.1.1.3 Cells . . . . . . . . . . . . . . . . . . . . . . . . . . U-124
5.1.1.4 Boundary . . . . . . . . . . . . . . . . . . . . . . . U-125
5.1.2 The polyMesh description . . . . . . . . . . . . . . . . . . . . U-125
5.1.3 The cellShape tools . . . . . . . . . . . . . . . . . . . . . . . U-126
5.1.4 1- and 2-dimensional and axi-symmetric problems . . . . . . U-126
5.2 Boundaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-128
5.2.1 Speciﬁcation of patch types in OpenFOAM . . . . . . . . . . U-128
5.2.2 Base types . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-130
5.2.3 Primitive types . . . . . . . . . . . . . . . . . . . . . . . . . U-132
5.2.4 Derived types . . . . . . . . . . . . . . . . . . . . . . . . . . U-132
5.3 Mesh generation with the blockMesh utility . . . . . . . . . . . . . . U-132
5.3.1 Writing a blockMeshDict ﬁle . . . . . . . . . . . . . . . . . . U-134
5.3.1.1 The vertices . . . . . . . . . . . . . . . . . . . . U-135
5.3.1.2 The edges . . . . . . . . . . . . . . . . . . . . . . U-135
5.3.1.3 The blocks . . . . . . . . . . . . . . . . . . . . . . U-136
5.3.1.4 The patches . . . . . . . . . . . . . . . . . . . . . U-137
5.3.2 Multiple blocks . . . . . . . . . . . . . . . . . . . . . . . . . U-138
5.3.3 Creating blocks with fewer than 8 vertices . . . . . . . . . . U-139
5.3.4 Running blockMesh . . . . . . . . . . . . . . . . . . . . . . . U-140
5.4 Mesh generation with the snappyHexMesh utility . . . . . . . . . . . U-140
5.4.1 The mesh generation process of snappyHexMesh . . . . . . . U-141
5.4.2 Creating the background hex mesh . . . . . . . . . . . . . . U-142
5.4.3 Cell splitting at feature edges and surfaces . . . . . . . . . . U-143
5.4.4 Cell removal . . . . . . . . . . . . . . . . . . . . . . . . . . . U-144
5.4.5 Cell splitting in speciﬁed regions . . . . . . . . . . . . . . . . U-145
5.4.6 Snapping to surfaces . . . . . . . . . . . . . . . . . . . . . . U-146
5.4.7 Mesh layers . . . . . . . . . . . . . . . . . . . . . . . . . . . U-146
5.4.8 Mesh quality controls . . . . . . . . . . . . . . . . . . . . . . U-148
5.5 Mesh conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-148
5.5.1 ﬂuentMeshToFoam . . . . . . . . . . . . . . . . . . . . . . . U-149
5.5.2 starToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-150
5.5.2.1 General advice on conversion . . . . . . . . . . . . U-151
5.5.2.2 Eliminating extraneous data . . . . . . . . . . . . . U-151
5.5.2.3 Removing default boundary conditions . . . . . . . U-152
5.5.2.4 Renumbering the model . . . . . . . . . . . . . . . U-152
5.5.2.5 Writing out the mesh data . . . . . . . . . . . . . . U-153
5.5.2.6 Problems with the .vrt ﬁle . . . . . . . . . . . . . . U-154
5.5.2.7 Converting the mesh to OpenFOAM format . . . . U-154
5.5.3 gambitToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . U-154
5.5.4 ideasToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-155
5.5.5 cfx4ToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-155
5.6 Mapping ﬁelds between diﬀerent geometries . . . . . . . . . . . . . U-155
5.6.1 Mapping consistent ﬁelds . . . . . . . . . . . . . . . . . . . . U-156
5.6.2 Mapping inconsistent ﬁelds . . . . . . . . . . . . . . . . . . . U-156
Open∇FOAM-1.6
Contents U-15
5.6.3 Mapping parallel cases . . . . . . . . . . . . . . . . . . . . . U-156
6 Post-processing U-159
6.1 paraFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-159
6.1.1 Overview of paraFoam . . . . . . . . . . . . . . . . . . . . . U-159
6.1.2 The Properties panel . . . . . . . . . . . . . . . . . . . . . . U-160
6.1.3 The Display panel . . . . . . . . . . . . . . . . . . . . . . . . U-161
6.1.4 The button toolbars . . . . . . . . . . . . . . . . . . . . . . U-163
6.1.5 Manipulating the view . . . . . . . . . . . . . . . . . . . . . U-163
6.1.5.1 View settings . . . . . . . . . . . . . . . . . . . . . U-163
6.1.5.2 General settings . . . . . . . . . . . . . . . . . . . U-163
6.1.6 Contour plots . . . . . . . . . . . . . . . . . . . . . . . . . . U-164
6.1.6.1 Introducing a cutting plane . . . . . . . . . . . . . U-164
6.1.7 Vector plots . . . . . . . . . . . . . . . . . . . . . . . . . . . U-164
6.1.7.1 Plotting at cell centres . . . . . . . . . . . . . . . . U-164
6.1.8 Streamlines . . . . . . . . . . . . . . . . . . . . . . . . . . . U-164
6.1.9 Image output . . . . . . . . . . . . . . . . . . . . . . . . . . U-165
6.1.10 Animation output . . . . . . . . . . . . . . . . . . . . . . . . U-165
6.2 Post-processing with Fluent . . . . . . . . . . . . . . . . . . . . . . U-166
6.3 Post-processing with Fieldview . . . . . . . . . . . . . . . . . . . . . U-167
6.4 Post-processing with EnSight . . . . . . . . . . . . . . . . . . . . . . U-167
6.4.1 Converting data to EnSight format . . . . . . . . . . . . . . U-168
6.4.2 The ensight74FoamExec reader module . . . . . . . . . . . . U-168
6.4.2.1 Conﬁguration of EnSight for the reader module . . U-168
6.4.2.2 Using the reader module . . . . . . . . . . . . . . . U-168
6.5 Sampling data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-169
6.6 Monitoring and managing jobs . . . . . . . . . . . . . . . . . . . . . U-172
6.6.1 The foamJob script for running jobs . . . . . . . . . . . . . . U-173
6.6.2 The foamLog script for monitoring jobs . . . . . . . . . . . . U-173
7 Models and physical properties U-175
7.1 Thermophysical models . . . . . . . . . . . . . . . . . . . . . . . . . U-175
7.1.1 Thermophysical property data . . . . . . . . . . . . . . . . . U-177
7.2 Turbulence models . . . . . . . . . . . . . . . . . . . . . . . . . . . U-178
7.2.1 Model coeﬃcients . . . . . . . . . . . . . . . . . . . . . . . . U-179
7.2.2 Wall functions . . . . . . . . . . . . . . . . . . . . . . . . . . U-179
Index U-181
Open∇FOAM-1.6
U-16 Contents
Open∇FOAM-1.6
Chapter 1
Introduction
This guide accompanies the release of version 1.6 of the Open Source Field Operation
and Manipulation (OpenFOAM) C++ libraries. It provides a description of the basic
operation of OpenFOAM, ﬁrst through a set of tutorial exercises in chapter 2 and later
by a more detailed description of the individual components that make up OpenFOAM.
OpenFOAM is ﬁrst and foremost a C++ library, used primarily to create executa-
bles, known as applications. The applications fall into two categories: solvers, that are
each designed to solve a speciﬁc problem in continuum mechanics; and utilities, that are
designed to perform tasks that involve data manipulation. The OpenFOAM distribution
contains numerous solvers and utilities covering a wide range of problems, as described
in chapter 3.
One of the strengths of OpenFOAM is that new solvers and utilities can be created
by its users with some pre-requisite knowledge of the underlying method, physics and
programming techniques involved.
OpenFOAM is supplied with pre- and post-processing environments. The interface
to the pre- and post-processing are themselves OpenFOAM utilities, thereby ensuring
consistent data handling across all environments. The overall structure of OpenFOAM is
shown in Figure 1.1. The pre-processing and running of OpenFOAM cases is described
Applications
User
Tools
MeshingUtilities Standard
Applications
Others
e.g.EnSight
Post-processingSolvingPre-processing
Open Source Field Operation and Manipulation (OpenFOAM) C++ Library
ParaView
Figure 1.1: Overview of OpenFOAM structure.
in chapter 4 In chapter 5, we cover both the generation of meshes using the mesh gen-
erator supplied with OpenFOAM and conversion of mesh data generated by third-party
products. Post-processing is described in chapter 6.
U-18 Introduction
Open∇FOAM-1.6
Chapter 2
Tutorials
In this chapter we shall describe in detail the process of setup, simulation and post-
processing for some OpenFOAM test cases, with the principal aim of introducing a user to
the basic procedures of running OpenFOAM. The $FOAM TUTORIALS directory contains
many more cases that demonstrate the use of all the solvers and many utilities supplied
with OpenFOAM. Before attempting to run the tutorials, the user must ﬁrst make sure
that they have installed OpenFOAM correctly.
The tutorial cases describe the use of the blockMesh pre-processing tool, case setup
and running OpenFOAM solvers and post-processing using paraFoam. Those users with
access to third-party post-processing tools supported in OpenFOAM have an option:
either they can follow the tutorials using paraFoam; or refer to the description of the use
of the third-party product in chapter 6 when post-processing is required.
Copies of all tutorials are available from the tutorials directory of the OpenFOAM
installation. The tutorials are organised into a set of directories according to the type
of ﬂow and then subdirectories according to solver. For example, all the icoFoam cases
are stored within a subdirectory incompressible/icoFoam, where incompressible indicates
the type of ﬂow. If the user wishes to run a range of example cases, it is recommended
that the user copy the tutorials directory into their local run directory. They can be easily
copied by typing:
mkdir -p $FOAM RUN
cp -r $FOAM TUTORIALS $FOAM RUN
2.1 Lid-driven cavity ﬂow
This tutorial will describe how to pre-process, run and post-process a case involving
isothermal, incompressible ﬂow in a two-dimensional square domain. The geometry is
shown in Figure 2.1 in which all the boundaries of the square are walls. The top wall
moves in the x-direction at a speed of 1 m/s while the other 3 are stationary. Initially,
the ﬂow will be assumed laminar and will be solved on a uniform mesh using the icoFoam
solver for laminar, isothermal, incompressible ﬂow. During the course of the tutorial, the
eﬀect of increased mesh resolution and mesh grading towards the walls will be investigated.
Finally, the ﬂow Reynolds number will be increased and the pisoFoam solver will be used
for turbulent, isothermal, incompressible ﬂow.
U-20 Tutorials
x
Ux = 1 m/s
d = 0.1 m
y
Figure 2.1: Geometry of the lid driven cavity.
2.1.1 Pre-processing
Cases are setup in OpenFOAM by editing case ﬁles. Users should select an xeditor of
choice with which to do this, such as emacs, vi, gedit, kate, nedit, etc. Editing ﬁles is
possible in OpenFOAM because the I/O uses a dictionary format with keywords that
convey suﬃcient meaning to be understood by even the least experienced users.
A case being simulated involves data for mesh, ﬁelds, properties, control parameters,
etc. As described in section 4.1, in OpenFOAM this data is stored in a set of ﬁles within
a case directory rather than in a single case ﬁle, as in many other CFD packages. The
case directory is given a suitably descriptive name, e.g. the ﬁrst example case for this
tutorial is simply named cavity. In preparation of editing case ﬁles and running the ﬁrst
cavity case, the user should change to the case directory
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavity
2.1.1.1 Mesh generation
OpenFOAM always operates in a 3 dimensional Cartesian coordinate system and all
geometries are generated in 3 dimensions. OpenFOAM solves the case in 3 dimensions
by default but can be instructed to solve in 2 dimensions by specifying a ‘special’ empty
boundary condition on boundaries normal to the (3rd) dimension for which no solution
is required.
The cavity domain consists of a square of side length d = 0.1 m in the x-y plane. A
uniform mesh of 20 by 20 cells will be used initially. The block structure is shown in
Figure 2.2. The mesh generator supplied with OpenFOAM, blockMesh, generates meshes
from a description speciﬁed in an input dictionary, blockMeshDict located in the con-
stant/polyMesh directory for a given case. The blockMeshDict entries for this case are as
follows:
1 /*--------------------------------*- C++ -*----------------------------------*\
2 | ========= | |
3 | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox |
4 | \\ / O peration | Version: 1.6 |
5 | \\ / A nd | Web: http://www.OpenFOAM.org |
6 | \\/ M anipulation | |
7 \*---------------------------------------------------------------------------*/
8 FoamFile
9 {
10 version 2.0;
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-21
3 2
4 5
7 6
0
z
x 1
y
Figure 2.2: Block structure of the mesh for the cavity.
11 format ascii;
12 class dictionary;
13 object blockMeshDict;
14 }
15 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
16
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (1 0 0)
23 (1 1 0)
24 (0 1 0)
25 (0 0 0.1)
26 (1 0 0.1)
27 (1 1 0.1)
28 (0 1 0.1)
29 );
30
31 blocks
32 (
33 hex (0 1 2 3 4 5 6 7) (20 20 1) simpleGrading (1 1 1)
34 );
35
36 edges
37 (
38 );
39
40 patches
41 (
42 wall movingWall
43 (
44 (3 7 6 2)
45 )
46 wall fixedWalls
47 (
48 (0 4 7 3)
49 (2 6 5 1)
50 (1 5 4 0)
51 )
52 empty frontAndBack
53 (
54 (0 3 2 1)
55 (4 5 6 7)
56 )
57 );
58
59 mergePatchPairs
60 (
61 );
62
63 // ************************************************************************* //
The ﬁle ﬁrst contains header information in the form of a banner (lines 1-7), then ﬁle
information contained in a FoamFile sub-dictionary, delimited by curly braces ({...}).
Open∇FOAM-1.6
U-22 Tutorials
For the remainder of the manual:
For the sake of clarity and to save space, ﬁle headers, including the banner and
FoamFile sub-dictionary, will be removed from verbatim quoting of case ﬁles
The ﬁle ﬁrst speciﬁes coordinates of the block vertices; it then deﬁnes the blocks
(here, only 1) from the vertex labels and the number of cells within it; and ﬁnally, it deﬁnes
the boundary patches. The user is encouraged to consult section 5.3 to understand the
meaning of the entries in the blockMeshDict ﬁle.
The mesh is generated by running blockMesh on this blockMeshDict ﬁle. From within
the case directory, this is done, simply by typing in the terminal:
blockMesh
The running status of blockMesh is reported in the terminal window. Any mistakes in
the blockMeshDict ﬁle are picked up by blockMesh and the resulting error message directs
the user to the line in the ﬁle where the problem occurred. There should be no error
messages at this stage.
2.1.1.2 Boundary and initial conditions
Once the mesh generation is complete, the user can look at this initial ﬁelds set up for
this case. The case is set up to start at time t = 0 s, so the initial ﬁeld data is stored in
a 0 sub-directory of the cavity directory. The 0 sub-directory contains 2 ﬁles, p and U,
one for each of the pressure (p) and velocity (U) ﬁelds whose initial values and boundary
conditions must be set. Let us examine ﬁle p:
17 dimensions [0 2 -2 0 0 0 0];
18
19 internalField uniform 0;
20
21 boundaryField
22 {
23 movingWall
24 {
25 type zeroGradient;
26 }
27
28 fixedWalls
29 {
30 type zeroGradient;
31 }
32
33 frontAndBack
34 {
35 type empty;
36 }
37 }
38
39 // ************************************************************************* //
There are 3 principal entries in ﬁeld data ﬁles:
dimensions speciﬁes the dimensions of the ﬁeld, here kinematic pressure, i.e. m2
s−2
(see
section 4.2.6 for more information);
internalField the internal ﬁeld data which can be uniform, described by a single value;
or nonuniform, where all the values of the ﬁeld must be speciﬁed (see section 4.2.8
for more information);
boundaryField the boundary ﬁeld data that includes boundary conditions and data for
all the boundary patches (see section 4.2.8 for more information).
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-23
For this case cavity, the boundary consists of walls only, split into 2 patches named: (1)
fixedWalls for the ﬁxed sides and base of the cavity; (2) movingWall for the moving top
of the cavity. As walls, both are given a zeroGradient boundary condition for p, meaning
“the normal gradient of pressure is zero”. The frontAndBack patch represents the front
and back planes of the 2D case and therefore must be set as empty.
In this case, as in most we encounter, the initial ﬁelds are set to be uniform. Here the
pressure is kinematic, and as an incompressible case, its absolute value is not relevant, so
is set to uniform 0 for convenience.
The user can similarly examine the velocity ﬁeld in the 0/U ﬁle. The dimensions are
those expected for velocity, the internal ﬁeld is initialised as uniform zero, which in the
case of velocity must be expressed by 3 vector components, i.e.uniform (0 0 0) (see
section 4.2.5 for more information).
The boundary ﬁeld for velocity requires the same boundary condition for the front-
AndBack patch. The other patches are walls: a no-slip condition is assumed on the
fixedWalls, hence a ﬁxedValue condition with a value of uniform (0 0 0). The top
surface moves at a speed of 1 m/s in the x-direction so requires a ﬁxedValue condition
also but with uniform (1 0 0).
2.1.1.3 Physical properties
The physical properties for the case are stored in dictionaries whose names are given the
suﬃx . . . Properties, located in the Dictionaries directory tree. For an icoFoam case,
the only property that must be speciﬁed is the kinematic viscosity which is stored from
the transportProperties dictionary. The user can check that the kinematic viscosity is
set correctly by opening the transportProperties dictionary to view/edit its entries. The
keyword for kinematic viscosity is nu, the phonetic label for the Greek symbol ν by which
it is represented in equations. Initially this case will be run with a Reynolds number of
10, where the Reynolds number is deﬁned as:
Re =
d|U|
ν
(2.1)
where d and |U| are the characteristic length and velocity respectively and ν is the
kinematic viscosity. Here d = 0.1 m, |U| = 1 m s−1
, so that for Re = 10, ν = 0.01 m2
s−1
.
The correct ﬁle entry for kinematic viscosity is thus speciﬁed below:
17
18 nu nu [ 0 2 -1 0 0 0 0 ] 0.01;
19
20
21 // ************************************************************************* //
2.1.1.4 Control
Input data relating to the control of time and reading and writing of the solution data are
read in from the controlDict dictionary. The user should view this ﬁle; as a case control
ﬁle, it is located in the system directory.
The start/stop times and the time step for the run must be set. OpenFOAM oﬀers
great ﬂexibility with time control which is described in full in section 4.3. In this tutorial
we wish to start the run at time t = 0 which means that OpenFOAM needs to read ﬁeld
data from a directory named 0 — see section 4.1 for more information of the case ﬁle
structure. Therefore we set the startFrom keyword to startTime and then specify the
startTime keyword to be 0.
For the end time, we wish to reach the steady state solution where the ﬂow is circu-
lating around the cavity. As a general rule, the ﬂuid should pass through the domain 10
Open∇FOAM-1.6
U-24 Tutorials
times to reach steady state in laminar ﬂow. In this case the ﬂow does not pass through
this domain as there is no inlet or outlet, so instead the end time can be set to the time
taken for the lid to travel ten times across the cavity, i.e. 1 s; in fact, with hindsight, we
discover that 0.5 s is suﬃcient so we shall adopt this value. To specify this end time, we
must specify the stopAt keyword as endTime and then set the endTime keyword to 0.5.
Now we need to set the time step, represented by the keyword deltaT. To achieve
temporal accuracy and numerical stability when running icoFoam, a Courant number of
less than 1 is required. The Courant number is deﬁned for one cell as:
Co =
δt|U|
δx
(2.2)
where δt is the time step, |U| is the magnitude of the velocity through that cell and δx
is the cell size in the direction of the velocity. The ﬂow velocity varies across the domain
and we must ensure Co < 1 everywhere. We therefore choose δt based on the worst case:
the maximum Co corresponding to the combined eﬀect of a large ﬂow velocity and small
cell size. Here, the cell size is ﬁxed across the domain so the maximum Co will occur next
to the lid where the velocity approaches 1 m s−1
. The cell size is:
δx =
d
n
=
0.1
20
= 0.005 m (2.3)
Therefore to achieve a Courant number less than or equal to 1 throughout the domain
the time step deltaT must be set to less than or equal to:
δt =
Co δx
|U|
=
1 × 0.005
1
= 0.005 s (2.4)
As the simulation progresses we wish to write results at certain intervals of time that
we can later view with a post-processing package. The writeControl keyword presents
several options for setting the time at which the results are written; here we select the
timeStep option which speciﬁes that results are written every nth time step where the
value n is speciﬁed under the writeInterval keyword. Let us decide that we wish to
write our results at times 0.1, 0.2,. . . , 0.5 s. With a time step of 0.005 s, we therefore
need to output results at every 20th time time step and so we set writeInterval to 20.
OpenFOAM creates a new directory named after the current time, e.g. 0.1 s, on each
occasion that it writes a set of data, as discussed in full in section 4.1. In the icoFoam
solver, it writes out the results for each ﬁeld, U and p, into the time directories. For this
case, the entries in the controlDict are shown below:
17
18 application icoFoam;
19
20 startFrom startTime;
21
22 startTime 0;
23
24 stopAt endTime;
25
26 endTime 0.5;
27
28 deltaT 0.005;
29
30 writeControl timeStep;
31
32 writeInterval 20;
33
34 purgeWrite 0;
35
36 writeFormat ascii;
37
38 writePrecision 6;
39
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-25
40 writeCompression uncompressed;
41
42 timeFormat general;
43
44 timePrecision 6;
45
46 runTimeModifiable yes;
47
48
49 // ************************************************************************* //
2.1.1.5 Discretisation and linear-solver settings
The user speciﬁes the choice of ﬁnite volume discretisation schemes in the fvSchemes
dictionary in the system directory. The speciﬁcation of the linear equation solvers and
tolerances and other algorithm controls is made in the fvSolution dictionary, similarly in
the system directory. The user is free to view these dictionaries but we do not need to
discuss all their entries at this stage except for pRefCell and pRefValue in the PISO
sub-dictionary of the fvSolution dictionary. In a closed incompressible system such as the
cavity, pressure is relative: it is the pressure range that matters not the absolute values.
In cases such as this, the solver sets a reference level by pRefValue in cell pRefCell. In
this example both are set to 0. Changing either of these values will change the absolute
pressure ﬁeld, but not, of course, the relative pressures or velocity ﬁeld.
2.1.2 Viewing the mesh
Before the case is run it is a good idea to view the mesh to check for any errors. The mesh
is viewed in paraFoam, the post-processing tool supplied with OpenFOAM. The paraFoam
post-processing is started by typing in the terminal from within the case directory
paraFoam
Alternatively, it can be launched from another directory location with an optional
-case argument giving the case directory, e.g.
paraFoam -case $FOAM RUN/tutorials/incompressible/icoFoam/cavity
This launches the ParaView window as shown in Figure 6.1. In the Pipeline Browser,
the user can see that ParaView has opened cavity.OpenFOAM, the module for the cavity
case. Before clicking the Apply button, the user needs to select some geometry from
the Region Status and panel. Because the case is small, it is easiest to select all the data
by checking the box adjacent to the Region Status panel title, which automatically checks
all individual components within the respective panel. The user should then click the
Apply button to load the geometry into ParaView.
some general settings are applied as described in section 6.1.5.1. Please consult this
section about these settings.
The user should then open the Display panel that controls the visual representation of
the selected module. Within the Display panel the user should do the following as shown
in Figure 2.3: (1) set Color by Solid Color; (2) click Set Solid Color and select an appro-
priate colour e.g. black (for a white background); (3) in the Style panel, select Wireframe
from the Representation menu. The background colour can be set by selecting View
Settings... from Edit in the top menu panel.
Especially the ﬁrst time the user starts ParaView, it is recommended that they
manipulate the view as described in section 6.1.5. In particular, since this is a 2D case,
it is recommended that Use Parallel Projection is selected in the General panel of View
Open∇FOAM-1.6
U-26 Tutorials
Open Display panel
Select Color by Solid Color
Set Solid Color, e.g. black
Select Wireframe
Figure 2.3: Viewing the mesh in paraFoam.
Settings window selected from the Edit menu. The Orientation Axes can be toggled on
and oﬀ in the Annotation window or moved by drag and drop with the mouse.
2.1.3 Running an application
Like any UNIX/Linux executable, OpenFOAM applications can be run in two ways: as
a foreground process, i.e. one in which the shell waits until the command has ﬁnished
before giving a command prompt; as a background process, one which does not have to
be completed before the shell accepts additional commands.
On this occasion, we will run icoFoam in the foreground. The icoFoam solver is exe-
cuted either by entering the case directory and typing
icoFoam
at the command prompt, or with the optional -case argument giving the case directory,
e.g.
icoFoam -case $FOAM RUN/tutorials/incompressible/icoFoam/cavity
The progress of the job is written to the terminal window. It tells the user the current
time, maximum Courant number, initial and ﬁnal residuals for all ﬁelds.
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-27
Open Display panel
Rescale to Data Range
Select Surface
Select Color by interpolated p
Figure 2.4: Displaying pressure contours for the cavity case.
Figure 2.5: Pressures in the cavity case.
Open∇FOAM-1.6
U-28 Tutorials
2.1.4 Post-processing
As soon as results are written to time directories, they can be viewed using paraFoam.
Return to the paraFoam window and select the Properties panel for the cavity.OpenFOAM
case module. If the correct window panels for the case module do not seem to be present
at any time, please ensure that: cavity.OpenFOAM is highlighted in blue; eye button
alongside it is switched on to show the graphics are enabled;
To prepare paraFoam to display the data of interest, we must ﬁrst load the data at
the required run time of 0.5 s. If the case was run while ParaView was open, the output
data in time directories will not be automatically loaded within ParaView. To load the
data the user should select Update GUI in the Properties window and then click the green
Apply button. The time data will be loaded into ParaView.
2.1.4.1 Isosurface and contour plots
To view pressure, the user should open the Display panel since it that controls the visual
representation of the selected module. To make a simple plot of pressure, the user should
select the following, as described in detail in Figure 2.4: in the Style panel, select Surface
from the Representation menu; in the Color panel, select Color by and Rescale to
Data Range. Now in order to view the solution at t = 0.5 s, the user can use the VCR
Controls or Current Time Controls to change the current time to 0.5. These are
located in the toolbars below the menus at the top of the ParaView window, as shown in
Figure 6.4. The pressure ﬁeld solution has, as expected, a region of low pressure at the
top left of the cavity and one of high pressure at the top right of the cavity as shown in
Figure 2.5.
With the point icon ( ) the pressure ﬁeld is interpolated across each cell to give a
continuous appearance. Instead if the user selects the cell icon, , from the Color by
menu, a single value for pressure will be attributed to each cell so that each cell will be
denoted by a single colour with no grading.
A colour bar can be included by either by clicking the Toggle Color Legend Visibility
button in the Active Variable Controls toolbar, or by selecting Show Color Legend
from the View menu. Clicking the Edit Color Map button, either in the Active Variable
Controls toolbar or in the Color panel of the Display window, the user can set a range
of attributes of the colour bar, such as text size, font selection and numbering format for
the scale. The colour bar can be located in the image window by drag and drop with the
mouse.
New versions of ParaView default to using a colour scale of blue to white to red rather
than the more common blue to green to red (rainbow). Therefore the ﬁrst time that the
user executes ParaView, they may wish to change the colour scale. This can be done by
selecting Choose Preset in the Color Scale Editor and selecting Blue to Red Rainbow. After
clicking the OK conﬁrmation button, the user can click the Make Default button so that
ParaView will always adopt this type of colour bar.
If the user rotates the image, they can see that they have now coloured the complete
geometry surface by the pressure. In order to produce a genuine contour plot the user
should ﬁrst create a cutting plane, or ‘slice’, through the geometry using the Slice ﬁlter
as described in section 6.1.6.1. The cutting plane should be centred at (0.05, 0.05, 0.005)
and its normal should be set to (0, 0, 1). Having generated the cutting plane, the contours
can be created using by the Contour ﬁlter described in section 6.1.6.
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-29
Open Parameters panel
Select Scale Mode off
Select Glyph Type Arrow
Specify Set Scale Factor 0.005
Figure 2.6: Properties panel for the Glyph ﬁlter.
Figure 2.7: Velocities in the cavity case.
Open∇FOAM-1.6
U-30 Tutorials
2.1.4.2 Vector plots
Before we start to plot the vectors of the ﬂow velocity, it may be useful to remove other
modules that have been created, e.g. using the Slice and Contour ﬁlters described above.
These can: either be deleted entirely, by highlighting the relevant module in the Pipeline
Browser and clicking Delete in their respective Properties panel; or, be disabled by toggling
the eye button for the relevant module in the Pipeline Browser.
We now wish to generate a vector glyph for velocity at the centre of each cell. We
ﬁrst need to ﬁlter the data to cell centres as described in section 6.1.7.1. With the
cavity.OpenFOAM module highlighted in the Pipeline Browser, the user should select Cell
Centers from the Filter menu and then click Apply.
With these Centers highlighted in the Pipeline Browser, the user should then select
Glyph from the Filter menu. The Properties window panel should appear as shown in
Figure 2.6. In the resulting Properties panel, the velocity ﬁeld, U, is automatically selected
in the vectors menu, since it is the only vector ﬁeld present. By default the Scale Mode
for the glyphs will be Vector Magnitude of velocity but, since the we may wish to view
the velocities throughout the domain, the user should instead select off and Set Scale
Factor to 0.005. On clicking Apply, the glyphs appear but, probably as a single colour,
e.g. white. The user should colour the glyphs by velocity magnitude which, as usual, is
controlled by setting Color by U in the Display panel. The user should also select Show
Color Legend in Edit Color Map. The output is shown in Figure 2.7, in which uppercase
Times Roman fonts are selected for the Color Legend headings and the labels are speciﬁed
to 2 ﬁxed signiﬁcant ﬁgures by deselecting Automatic Label Format and entering %-#6.2f
in the Label Format text box. The background colour is set to white in the General panel
of View Settings as described in section 6.1.5.1.
2.1.4.3 Streamline plots
Again, before the user continues to post-process in ParaView, they should disable modules
such as those for the vector plot described above. We now wish to plot a streamlines of
velocity as described in section 6.1.8.
With the cavity.OpenFOAM module highlighted in the Pipeline Browser, the user
should then select Stream Tracer from the Filter menu and then click Apply. The
Properties window panel should appear as shown in Figure 2.8. The Seed points should
be speciﬁed along a Line Source running vertically through the centre of the geometry,
i.e. from (0.05, 0, 0.005) to (0.05, 0.1, 0.005). For the image in this guide we used: a point
Resolution of 21; Max Propagation by Length 0.5; Initial Step Length by Cell Length 0.01;
and, Integration Direction BOTH. The Runge-Kutta 2 IntegratorType was used with
default parameters.
On clicking Apply the tracer is generated. The user should then select Tube from the
Filter menu to produce high quality streamline images. For the image in this report, we
used: Num. sides 6; Radius 0.0003; and, Radius factor 10. The streamtubes are coloured
by velocity magnitude. On clicking Apply the image in Figure 2.9 should be produced.
2.1.5 Increasing the mesh resolution
The mesh resolution will now be increased by a factor of two in each direction. The results
from the coarser mesh will be mapped onto the ﬁner mesh to use as initial conditions for
the problem. The solution from the ﬁner mesh will then be compared with those from
the coarser mesh.
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-31
Open Parameters panel
Set Integration Direction to BOTH
Set Max Propagation to Length 0.5
Set Initial Step Length to Cell Length 0.01
Specify Line Source and set points and resolution
Figure 2.8: Properties panel for the Stream Tracer ﬁlter.
Figure 2.9: Streamlines in the cavity case.
Open∇FOAM-1.6
U-32 Tutorials
2.1.5.1 Creating a new case using an existing case
We now wish to create a new case named cavityFine that is created from cavity. The user
should therefore clone the cavity case and edit the necessary ﬁles. First the user should
create a new case directory at the same directory level as the cavity case, e.g.
cd $FOAM RUN/tutorials/incompressible/icoFoam
mkdir cavityFine
The user should then copy the base directories from the cavity case into cavityFine, and
then enter the cavityFine case.
cp -r cavity/constant cavityFine
cp -r cavity/system cavityFine
cd cavityFine
2.1.5.2 Creating the ﬁner mesh
We now wish to increase the number of cells in the mesh by using blockMesh. The user
should open the blockMeshDict ﬁle in an editor and edit the block speciﬁcation. The blocks
are speciﬁed in a list under the blocks keyword. The syntax of the block deﬁnitions is
described fully in section 5.3.1.3; at this stage it is suﬃcient to know that following hex
is ﬁrst the list of vertices in the block, then a list (or vector) of numbers of cells in each
direction. This was originally set to (20 20 1) for the cavity case. The user should now
change this to (40 40 1) and save the ﬁle. The new reﬁned mesh should then be created
by running blockMesh as before.
2.1.5.3 Mapping the coarse mesh results onto the ﬁne mesh
The mapFields utility maps one or more ﬁelds relating to a given geometry onto the cor-
responding ﬁelds for another geometry. In our example, the ﬁelds are deemed ‘consistent’
because the geometry and the boundary types, or conditions, of both source and tar-
get ﬁelds are identical. We use the -consistent command line option when executing
mapFields in this example.
The ﬁeld data that mapFields maps is read from the time directory speciﬁed by
startFrom/startTime in the controlDict of the target case, i.e. those into which the
results are being mapped. In this example, we wish to map the ﬁnal results of the coarser
mesh from case cavity onto the ﬁner mesh of case cavityFine. Therefore, since these re-
sults are stored in the 0.5 directory of cavity, the startTime should be set to 0.5 s in the
controlDict dictionary and startFrom should be set to startTime.
The case is ready to run mapFields. Typing mapFields -help quickly shows that map-
Fields requires the source case directory as an argument. We are using the -consistent
option, so the utility is executed from withing the cavityFine directory by
mapFields ../cavity -consistent
The utility should run with output to the terminal including:
Source: ".." "cavity"
Target: "." "cavityFine"
Create databases as time
Source time: 0.5
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-33
Target time: 0.5
Create meshes
Source mesh size: 400 Target mesh size: 1681
Consistently creating and mapping fields for time 0.5
interpolating p
interpolating U
End
2.1.5.4 Control adjustments
To maintain a Courant number of less that 1, as discussed in section 2.1.1.4, the time
step must now be halved since the size of all cells has halved. Therefore deltaT should
be set to to 0.0025 s in the controlDict dictionary. Field data is currently written out at
an interval of a ﬁxed number of time steps. Here we demonstrate how to specify data
output at ﬁxed intervals of time. Under the writeControl keyword in controlDict, instead
of requesting output by a ﬁxed number of time steps with the timeStep entry, a ﬁxed
amount of run time can be speciﬁed between the writing of results using the runTime
entry. In this case the user should specify output every 0.1 and therefore should set
writeInterval to 0.1 and writeControl to runTime. Finally, since the case is starting
with a the solution obtained on the coarse mesh we only need to run it for a short period
to achieve reasonable convergence to steady-state. Therefore the endTime should be set
to 0.7 s. Make sure these settings are correct and then save the ﬁle.
2.1.5.5 Running the code as a background process
The user should experience running icoFoam as a background process, redirecting the
terminal output to a log ﬁle that can be viewed later. From the cavityFine directory, the
user should execute:
icoFoam > log &
cat log
2.1.5.6 Vector plot with the reﬁned mesh
The user can open multiple cases simultaneously in ParaView; essentially because each new
case is simply another module that appears in the Pipeline Browser. There is one minor
inconvenience when opening a new case in ParaView because there is a prerequisite that
the selected data is a ﬁle with a name that has an extension. However, in OpenFOAM,
each case is stored in a multitude of ﬁles with no extensions within a speciﬁc directory
structure. The solution, that the paraFoam script performs automatically, is to create
a dummy ﬁle with the extension .OpenFOAM — hence, the cavity case module is called
cavity.OpenFOAM.
However, if the user wishes to open another case directly from within ParaView, they
need to create such a dummy ﬁle. For example, to load the cavityFine case the ﬁle would
be created by typing at the command prompt:
cd $FOAM RUN/tutorials/incompressible/icoFoam
touch cavityFine/cavityFine.OpenFOAM
Now the cavityFine case can be loaded into ParaView by selecting Open from the File
menu, and having navigated the directory tree, selecting cavityFine.OpenFOAM. The user
Open∇FOAM-1.6
U-34 Tutorials
Open Display panel
Select Scatter Plot
Select Ux from Line Series
Select arc length
Figure 2.10: Selecting ﬁelds for graph plotting.
can now make a vector plot of the results from the reﬁned mesh in ParaView. The plot can
be compared with the cavity case by enabling glyph images for both case simultaneously.
2.1.5.7 Plotting graphs
The user may wish to visualise the results by extracting some scalar measure of velocity
and plotting 2-dimensional graphs along lines through the domain. OpenFOAM is well
equipped for this kind of data manipulation. There are numerous utilities that do spe-
cialised data manipulations, and some, simpler calculations are incorporated into a single
utility foamCalc. As a utility, it is unique in that it is executed by
foamCalc <calcType> <fieldName1 ... fieldNameN>
The calculator operation is speciﬁed in <calcType>; at the time of writing, the following
operations are implemented: addSubtract; randomise; div; components; mag; magGrad;
magSqr; interpolate. The user can obtain the list of <calcType> by deliberately calling
one that does not exist, so that foamCalc throws up an error message and lists the types
available, e.g.
>> foamCalc xxxx
Selecting calcType xxxx
unknown calcType type xxxx, constructor not in hash table
Valid calcType selections are:
8
(
randomise
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-35
magSqr
magGrad
addSubtract
div
mag
interpolate
components
)
The components and mag calcTypes provide usefu l scalar measures of velocity. When
“foamCalc components U” is run on a case, say cavity, it reads in the velocity vector ﬁeld
from each time directory and, in the corresponding time directories, writes scalar ﬁelds
Ux, Uy and Uz representing the x, y and z components of velocity. Similarly “foamCalc
mag U” writes a scalar ﬁeld magU to each time directory representing the magnitude of
velocity.
The user can run foamCalc with the components calcType on both cavity and cavityFine
cases. For example, for the cavity case the user should execute the following command:
foamCalc components U -case $FOAM RUN/tutorials1.5/icoFoam/cavity
The individual components can be plotted as a graph in ParaView. It is quick, con-
venient and has reasonably good control over labelling and formatting, so the printed
output is a fairly good standard. However, to produce graphs for publication, users may
prefer to write raw data and plot it with a dedicated graphing tool, such as gnuplot or
Grace/xmgr. To do this, we recommend using the sample utility, described in section 6.5
and section 2.2.3.
Before commencing plotting, the user needs to load the newly generated Ux, Uy and Uz
ﬁelds into ParaView. To do this, the user should check the Update GUI button at the top
of the Properties panel of the base module they are working on, e.g.cavity.OpenFOAM.
Clicking Apply will then cause the new ﬁelds to be loaded into ParaView which will appear
in the Vol Field Status window. Ensure the new ﬁelds are selected and the changes
are applied, i.e. click Apply again if necessary. Also, data is interpolated incorrectly at
boundaries if the boundary regions are selected in the Region Status panel. Therefore the
user should deselect the patches in the Region Status panel, i.e.movingWall, fixedWall
and frontAndBack, and apply the changes.
Now, in order to display a graph in ParaView the user should select the module of inter-
est, e.g.cavity.OpenFOAM and apply the Plot Over Line ﬁlter from the Filter->Data
Analysis menu. This opens up a new XY Plot window beside the existing 3D View win-
dow. A ProbeLine module is created in which the user can specify the end points of the
line in the Properties panel. In this example, the user should position the line vertically
up the centre of the domain, i.e. from (0.05, 0, 0.005) to (0.05, 0.1, 0.005), in the Point1
and Point2 text boxes. The Resolution can be set to 100.
On clicking Apply, a graph is generated in the XY Plot window. In the Display panel,
the user should choose Scatter Plot from the Plot Type menu, with Attribute Mode
Point Data. The Use Data Array option can be selected for the X Axis Data, taking the
arc length option so that the x-axis of the graph represents distance from the base of
the cavity.
The user can choose the ﬁelds to be displayed in the Line Series panel of the Display
window. From the list of scalar ﬁelds to be displayed, it can be seen that the magnitude
and components of vector ﬁelds are available by default, e.g. displayed as U:X, so that
it was not necessary to create Ux using foamCalc. Nevertheless, the user should deselect
all series except Ux (or U:x). A square colour box in the adjacent column to the selected
series indicates the line colour. The user can edit this most easily by a double click of the
mouse over that selection.
Open∇FOAM-1.6
U-36 Tutorials
Figure 2.11: Plotting graphs in paraFoam.
In order to format the graph, the user should move over to the XY Plot itself. Now,
with the cursor over the graph, the user can click the right mouse-button and select
Properties from the small ﬂoating menu produced. A Chart Options window appears
with General settings for title and legend and menus for each axis. The menu for each
axis can be expanded by a double click to reveal individual menus for Layout and Title,
one for each axis. The user can set font, colour and alignment of the axes titles, and has
several options for axis range and labels in linear or logarithmic scales.
Figure 2.11 is a graph produced using ParaView. The user can produce a graph how-
ever he/she wishes. For information, the graph in Figure 2.11 was produced with the
options for axes of: Standard type of Notation; Specify Axis Range selected; titles in
Sans Serif 12 font. The graph is displayed as a set of points rather than a line by acti-
vating the Enable Line Series button in the Display window. Note: if this button appears to
be inactive by being “greyed out”, it can be made active by selecting and deselecting the
sets of variables in the Line Series panel. Once the Enable Line Series button is selected,
the Line Style and Marker Style can be adjusted to the user’s preference.
2.1.6 Introducing mesh grading
The error in any solution will be more pronounced in regions where the form of the
true solution diﬀer widely from the form assumed in the chosen numerical schemes. For
example a numerical scheme based on linear variations of variables over cells can only
generate an exact solution if the true solution is itself linear in form. The error is largest
in regions where the true solution deviates greatest from linear form, i.e. where the change
in gradient is largest. Error decreases with cell size.
It is useful to have an intuitive appreciation of the form of the solution before setting
up any problem. It is then possible to anticipate where the errors will be largest and
to grade the mesh so that the smallest cells are in these regions. In the cavity case the
large variations in velocity can be expected near a wall and so in this part of the tutorial
the mesh will be graded to be smaller in this region. By using the same number of cells,
greater accuracy can be achieved without a signiﬁcant increase in computational cost.
A mesh of 20 × 20 cells with grading towards the walls will be created for the lid-
driven cavity problem and the results from the ﬁner mesh of section 2.1.5.2 will then be
mapped onto the graded mesh to use as an initial condition. The results from the graded
mesh will be compared with those from the previous meshes. Since the changes to the
blockMeshDict dictionary are fairly substantial, the case used for this part of the tutorial,
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-37
cavityGrade, is supplied in the $FOAM RUN/tutorials/incompressible/icoFoam directory.
2.1.6.1 Creating the graded mesh
The mesh now needs 4 blocks as diﬀerent mesh grading is needed on the left and right and
top and bottom of the domain. The block structure for this mesh is shown in Figure 2.12.
The user can view the blockMeshDict ﬁle in the constant/polyMesh subdirectory of cavi-
0
z
x
y
3 4 5
6 87
1 2
1715
9 1110
16
12 13 14
0 1
2 3
Figure 2.12: Block structure of the graded mesh for the cavity (block numbers encircled).
tyGrade; for completeness the key elements of the blockMeshDict ﬁle are also reproduced
below. Each block now has 10 cells in the x and y directions and the ratio between largest
and smallest cells is 2.
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (0.5 0 0)
23 (1 0 0)
24 (0 0.5 0)
25 (0.5 0.5 0)
26 (1 0.5 0)
27 (0 1 0)
28 (0.5 1 0)
29 (1 1 0)
30 (0 0 0.1)
31 (0.5 0 0.1)
32 (1 0 0.1)
33 (0 0.5 0.1)
34 (0.5 0.5 0.1)
35 (1 0.5 0.1)
36 (0 1 0.1)
37 (0.5 1 0.1)
38 (1 1 0.1)
39 );
40
41 blocks
42 (
43 hex (0 1 4 3 9 10 13 12) (10 10 1) simpleGrading (2 2 1)
44 hex (1 2 5 4 10 11 14 13) (10 10 1) simpleGrading (0.5 2 1)
45 hex (3 4 7 6 12 13 16 15) (10 10 1) simpleGrading (2 0.5 1)
46 hex (4 5 8 7 13 14 17 16) (10 10 1) simpleGrading (0.5 0.5 1)
47 );
48
49 edges
50 (
51 );
52
53 patches
54 (
55 wall movingWall
56 (
Open∇FOAM-1.6
U-38 Tutorials
57 (6 15 16 7)
58 (7 16 17 8)
59 )
60 wall fixedWalls
61 (
62 (3 12 15 6)
63 (0 9 12 3)
64 (0 1 10 9)
65 (1 2 11 10)
66 (2 5 14 11)
67 (5 8 17 14)
68 )
69 empty frontAndBack
70 (
71 (0 3 4 1)
72 (1 4 5 2)
73 (3 6 7 4)
74 (4 7 8 5)
75 (9 10 13 12)
76 (10 11 14 13)
77 (12 13 16 15)
78 (13 14 17 16)
79 )
80 );
81
82 mergePatchPairs
83 (
84 );
85
86 // ************************************************************************* //
Once familiar with the blockMeshDict ﬁle for this case, the user can execute blockMesh
from the command line. The graded mesh can be viewed as before using paraFoam as
described in section 2.1.2.
2.1.6.2 Changing time and time step
The highest velocities and smallest cells are next to the lid, therefore the highest Courant
number will be generated next to the lid, for reasons given in section 2.1.1.4. It is therefore
useful to estimate the size of the cells next to the lid to calculate an appropriate time
step for this case.
When a nonuniform mesh grading is used, blockMesh calculates the cell sizes using a
geometric progression. Along a length l, if n cells are requested with a ratio of R between
the last and ﬁrst cells, the size of the smallest cell, δxs, is given by:
δxs = l
r − 1
αr − 1
(2.5)
where r is the ratio between one cell size and the next which is given by:
r = R
1
n−1 (2.6)
and
α =
R for R > 1,
1 − r−n
+ r−1
for R < 1.
(2.7)
For the cavityGrade case the number of cells in each direction in a block is 10, the ratio
between largest and smallest cells is 2 and the block height and width is 0.05 m. Therefore
the smallest cell length is 3.45 mm. From Equation 2.2, the time step should be less than
3.45 ms to maintain a Courant of less than 1. To ensure that results are written out
at convenient time intervals, the time step deltaT should be reduced to 2.5 ms and the
writeInterval set to 40 so that results are written out every 0.1 s. These settings can
be viewed in the cavityGrade/system/controlDict ﬁle.
The startTime needs to be set to that of the ﬁnal conditions of the case cavityFine,
i.e.0.7. Since cavity and cavityFine converged well within the prescribed run time, we can
set the run time for case cavityGrade to 0.1 s, i.e. the endTime should be 0.8.
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-39
2.1.6.3 Mapping ﬁelds
As in section 2.1.5.3, use mapFields to map the ﬁnal results from case cavityFine onto the
mesh for case cavityGrade. Enter the cavityGrade directory and execute mapFields by:
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavityGrade
mapFields ../cavityFine -consistent
Now run icoFoam from the case directory and monitor the run time information. View
the converged results for this case and compare with other results using post-processing
tools described previously in section 2.1.5.6 and section 2.1.5.7.
2.1.7 Increasing the Reynolds number
The cases solved so far have had a Reynolds number of 10. This is very low and leads
to a stable solution quickly with only small secondary vortices at the bottom corners of
the cavity. We will now increase the Reynolds number to 50, at which point the solution
takes a noticeably longer time to converge. The coarsest mesh in case cavity will be used
initially. The user should make a copy of the cavity case and name it cavityHighRe by
typing:
cd $FOAM_RUN/tutorials/incompressible/icoFoam
cp -r cavity cavityHighRe
2.1.7.1 Pre-processing
Enter the the cavityHighRe case and edit the transportProperties dictionary. Since the
Reynolds number is required to be increased by a factor of 10, decrease the kinematic
viscosity by a factor of 10, i.e. to 1×10−3
m2
s−1
. We can now run this case by restarting
from the solution at the end of the cavity case run. To do this we can use the option of
setting the startFrom keyword to latestTime so that icoFoam takes as its initial data
the values stored in the directory corresponding to the most recent time, i.e. 0.5. The
endTime should be set to 2 s.
2.1.7.2 Running the code
Run icoFoam for this case from the case directory and view the run time information.
When running a job in the background, the following UNIX commands can be useful:
nohup enables a command to keep running after the user who issues the command has
logged out;
nice changes the priority of the job in the kernel’s scheduler; a niceness of -20 is the
highest priority and 19 is the lowest priority.
This is useful, for example, if a user wishes to set a case running on a remote machine
and does not wish to monitor it heavily, in which case they may wish to give it low
priority on the machine. In that case the nohup command allows the user to log out of a
remote machine he/she is running on and the job continues running, while nice can set
the priority to 19. For our case of interest, we can execute the command in this manner
as follows:
Open∇FOAM-1.6
U-40 Tutorials
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavityHighRe
nohup nice -n 19 icoFoam > log &
cat log
In previous runs you may have noticed that icoFoam stops solving for velocity U quite
quickly but continues solving for pressure p for a lot longer or until the end of the run.
In practice, once icoFoam stops solving for U and the initial residual of p is less than
the tolerance set in the fvSolution dictionary (typically 10−6
), the run has eﬀectively
converged and can be stopped once the ﬁeld data has been written out to a time directory.
For example, at convergence a sample of the log ﬁle from the run on the cavityHighRe
case appears as follows in which the velocity has already converged after 1.62 s and
initial pressure residuals are small; No Iterations 0 indicates that the solution of U has
stopped:
1
2 Time = 1.63
3
4 Courant Number mean: 0.108642 max: 0.818175
5 DILUPBiCG: Solving for Ux, Initial residual = 7.86044e-06, Final residual = 7.86044e-06,
6 No Iterations 0
7 DILUPBiCG: Solving for Uy, Initial residual = 9.4171e-06, Final residual = 9.4171e-06,
8 No Iterations 0
9 DICPCG: Solving for p, Initial residual = 3.54721e-06, Final residual = 7.13506e-07,
10 No Iterations 4
11 time step continuity errors : sum local = 6.46788e-09, global = -9.44516e-19,
12 cumulative = 1.04595e-17
13 DICPCG: Solving for p, Initial residual = 2.15824e-06, Final residual = 9.95068e-07,
14 No Iterations 3
15 time step continuity errors : sum local = 8.67501e-09, global = 7.54182e-19,
16 cumulative = 1.12136e-17
17 ExecutionTime = 1.02 s ClockTime = 1 s
18
19 Time = 1.635
20
21 Courant Number mean: 0.108643 max: 0.818176
22 DILUPBiCG: Solving for Ux, Initial residual = 7.6728e-06, Final residual = 7.6728e-06,
23 No Iterations 0
24 DILUPBiCG: Solving for Uy, Initial residual = 9.19442e-06, Final residual = 9.19442e-06,
25 No Iterations 0
26 DICPCG: Solving for p, Initial residual = 3.13107e-06, Final residual = 8.60504e-07,
27 No Iterations 4
28 time step continuity errors : sum local = 8.15435e-09, global = -5.84817e-20,
29 cumulative = 1.11552e-17
30 DICPCG: Solving for p, Initial residual = 2.16689e-06, Final residual = 5.27197e-07,
31 No Iterations 14
32 time step continuity errors : sum local = 3.45666e-09, global = -5.62297e-19,
33 cumulative = 1.05929e-17
34 ExecutionTime = 1.02 s ClockTime = 1 s
2.1.8 High Reynolds number ﬂow
View the results in paraFoam and display the velocity vectors. The secondary vortices in
the corners have increased in size somewhat. The user can then increase the Reynolds
number further by decreasing the viscosity and then rerun the case. The number of
vortices increases so the mesh resolution around them will need to increase in order to
resolve the more complicated ﬂow patterns. In addition, as the Reynolds number increases
the time to convergence increases. The user should monitor residuals and extend the
endTime accordingly to ensure convergence.
The need to increase spatial and temporal resolution then becomes impractical as
the ﬂow moves into the turbulent regime, where problems of solution stability may also
occur. Of course, many engineering problems have very high Reynolds numbers and it
is infeasible to bear the huge cost of solving the turbulent behaviour directly. Instead
Reynolds-averaged stress (RAS) turbulence models are used to solve for the mean ﬂow
behaviour and calculate the statistics of the ﬂuctuations. The standard k − ε model
with wall functions will be used in this tutorial to solve the lid-driven cavity case with
a Reynolds number of 104
. Two extra variables are solved for: k, the turbulent kinetic
energy; and, ε, the turbulent dissipation rate. The additional equations and models for
turbulent ﬂow are implemented into a OpenFOAM solver called pisoFoam.
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-41
2.1.8.1 Pre-processing
Change directory to the cavity case in the $FOAM RUN/tutorials/incompressible/pisoFoam/-
ras directory (N.B: the pisoFoam/ras directory). Generate the mesh by running blockMesh
as before. Mesh grading towards the wall is not necessary when using the standard k − ε
model with wall functions since the ﬂow in the near wall cell is modelled, rather than
having to be resolved.
From version 1.6 onwards, a range of wall function models is available in OpenFOAM
that are applied as boundary conditions on individual patches. This enables diﬀerent
wall function models to be applied to diﬀerent wall regions. The choice of wall function
models are speciﬁed through the turbulent viscosity ﬁeld, νt in the 0/nut ﬁle:
17
18 dimensions [0 2 -1 0 0 0 0];
19
20 internalField uniform 0;
21
22 boundaryField
23 {
24 movingWall
25 {
26 type nutWallFunction;
27 value uniform 0;
28 }
29 fixedWalls
30 {
31 type nutWallFunction;
32 value uniform 0;
33 }
34 frontAndBack
35 {
36 type empty;
37 }
38 }
39
40
41 // ************************************************************************* //
This case uses standard wall functions, speciﬁed by the nutWallFunction keyword entry
one the movingWall and fixedWalls patches. Other wall function models include the
rough wall functions, speciﬁed though the nutRoughWallFunction keyword.
The user should now open the ﬁeld ﬁles for k and ε (0/k and 0/epsilon) and examine
their boundary conditions. For a wall boundary condition, ε is assigned a epsilonWall-
Function boundary condition and a kqRwallFunction boundary condition is assigned to k.
The latter is a generic boundary condition that can be applied to any ﬁeld that are of a
turbulent kinetic energy type, e.g. k, q or Reynolds Stress R. The initial values for k and
ε are set using an estimated ﬂuctuating component of velocity U′
and a turbulent length
scale, l. k and ε are deﬁned in terms of these parameters as follows:
k =
1
2
U′ • U′ (2.8)
ε =
C0.75
µ k1.5
l
(2.9)
where Cµ is a constant of the k − ε model equal to 0.09. For a Cartesian coordinate
system, k is given by:
k =
1
2
(U′ 2
x + U′ 2
y + U′ 2
z ) (2.10)
where U′ 2
x , U′ 2
y and U′ 2
z are the ﬂuctuating components of velocity in the x, y and z
directions respectively. Let us assume the initial turbulence is isotropic, i.e. U′ 2
x = U′ 2
y =
U′ 2
z , and equal to 5% of the lid velocity and that l, is equal to 20% of the box width, 0.1
Open∇FOAM-1.6
U-42 Tutorials
m, then k and ε are given by:
U′
x = U′
y = U′
z =
5
100
1 m s−1
(2.11)
⇒ k =
3
2
5
100
2
m2
s−2
= 3.75 × 10−3
m2
s−2
(2.12)
ε =
C0.75
µ k1.5
l
≈ 7.65 × 10−4
m2
s−3
(2.13)
These form the initial conditions for k and ε. The initial conditions for U and p are
(0, 0, 0) and 0 respectively as before.
Prior to version 1.6 of OpenFOAM, the type of turbulence modelling method, e.g.
RAS or large-eddy simulation (LES), was declared within each solver. This resulted in
a lot of duplication of code in solver applications, where for most solvers that used RAS
turbulence modelling, there would be an equivalent LES solver.
From version 1.6 however, the choice of turbulence modelling method is selectable at
run-time through the simulationType keyword in turbulenceProperties dictionary. The
user can view this ﬁle in the constant directory:
17
18 simulationType RASModel;
19
20
21 // ************************************************************************* //
The options for simulationType are laminar, RASmodel and LESmodel. With RASmodel
selected in this case, the choice of RAS modelling is speciﬁed in a RASProperties ﬁle, also
in the constant directory. The turbulence model is selected by the RASModel entry from a
long list of available models that are listed in Table 3.9. The kEpsilon model should be
selected which is is the standard k−ε model; the user should also ensure that turbulence
calculation is switched on.
The coeﬃcients for each turbulence model are stored within the respective code with
a set of default values. Setting the optional switch called printCoeffs to on will make
the default values be printed to standard output, i.e. the terminal, when the model
is called at run time. The coeﬃcients are printed out as a subdictionary whose name
is that of the model name with the word Coeffs appended, e.g. kEpsilonCoeffs in
the case of the kEpsilon model. The coeﬃcients of the model, e.g. kEpsilon, can be
modiﬁed by optionally including that subdictionary within the RASProperties dictionary
and adjusting values accordingly.
The user should next set the laminar kinematic viscosity in the transportProperties
dictionary. To achieve a Reynolds number of 104
, a kinematic viscosity of 10−5
m is
required based on the Reynolds number deﬁnition given in Equation 2.1.
Finally the user should set the startTime, stopTime, deltaT and the writeInterval
in the controlDict. Set deltaT to 0.005 s to satisfy the Courant number restriction and
the endTime to 10 s.
2.1.8.2 Running the code
Execute pisoFoam by entering the case directory and typing “pisoFoam”. In this case,
where the viscosity is low, the boundary layer next to the moving lid is very thin and
the cells next to the lid are comparatively large so the velocity at their centres are much
less than the lid velocity. In fact, after ≈ 100 time steps it becomes apparent that the
velocity in the cells adjacent to the lid reaches an upper limit of around 0.2 m s−1
hence
the maximum Courant number does not rise much above 0.2. It is sensible to increase
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-43
the solution time by increasing the time step to a level where the Courant number is
much closer to 1. Therefore reset deltaT to 0.02 s and, on this occasion, set startFrom
to latestTime. This instructs pisoFoam to read the start data from the latest time
directory, i.e.10.0. The endTime should be set to 20 s since the run converges a lot slower
than the laminar case. Restart the run as before and monitor the convergence of the
solution. View the results at consecutive time steps as the solution progresses to see if
the solution converges to a steady-state or perhaps reaches some periodically oscillating
state. In the latter case, convergence may never occur but this does not mean the results
are inaccurate.
2.1.9 Changing the case geometry
A user may wish to make changes to the geometry of a case and perform a new simulation.
It may be useful to retain some or all of the original solution as the starting conditions
for the new simulation. This is a little complex because the ﬁelds of the original solution
are not consistent with the ﬁelds of the new case. However the mapFields utility can map
ﬁelds that are inconsistent, either in terms of geometry or boundary types or both.
As an example, let us go to the cavityClipped case in the icoFoam directory which
consists of the standard cavity geometry but with a square of length 0.04 m removed from
the bottom right of the cavity, according to the blockMeshDict below:
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (0.6 0 0)
23 (0 0.4 0)
24 (0.6 0.4 0)
25 (1 0.4 0)
26 (0 1 0)
27 (0.6 1 0)
28 (1 1 0)
29
30 (0 0 0.1)
31 (0.6 0 0.1)
32 (0 0.4 0.1)
33 (0.6 0.4 0.1)
34 (1 0.4 0.1)
35 (0 1 0.1)
36 (0.6 1 0.1)
37 (1 1 0.1)
38
39 );
40
41 blocks
42 (
43 hex (0 1 3 2 8 9 11 10) (12 8 1) simpleGrading (1 1 1)
44 hex (2 3 6 5 10 11 14 13) (12 12 1) simpleGrading (1 1 1)
45 hex (3 4 7 6 11 12 15 14) (8 12 1) simpleGrading (1 1 1)
46 );
47
48 edges
49 (
50 );
51
52 patches
53 (
54 wall lid
55 (
56 (5 13 14 6)
57 (6 14 15 7)
58 )
59 wall fixedWalls
60 (
61 (0 8 10 2)
62 (2 10 13 5)
63 (7 15 12 4)
64 (4 12 11 3)
65 (3 11 9 1)
66 (1 9 8 0)
67 )
Open∇FOAM-1.6
U-44 Tutorials
68 empty frontAndBack
69 (
70 (0 2 3 1)
71 (2 5 6 3)
72 (3 6 7 4)
73 (8 9 11 10)
74 (10 11 14 13)
75 (11 12 15 14)
76 )
77 );
78
79 mergePatchPairs
80 (
81 );
82
83 // ************************************************************************* //
Generate the mesh with blockMesh. The patches are set accordingly as in previous cavity
cases. For the sake of clarity in describing the ﬁeld mapping process, the upper wall patch
is renamed lid, previously the movingWall patch of the original cavity.
In an inconsistent mapping, there is no guarantee that all the ﬁeld data can be mapped
from the source case. The remaining data must come from ﬁeld ﬁles in the target case
itself. Therefore ﬁeld data must exist in the time directory of the target case before
mapping takes place. In the cavityClipped case the mapping is set to occur at time 0.5 s,
since the startTime is set to 0.5 s in the controlDict. Therefore the user needs to copy
initial ﬁeld data to that directory, e.g. from time 0:
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavityClipped
cp -r 0 0.5
Before mapping the data, the user should view the geometry and ﬁelds at 0.5 s.
Now we wish to map the velocity and pressure ﬁelds from cavity onto the new ﬁelds
of cavityClipped. Since the mapping is inconsistent, we need to edit the mapFieldsDict
dictionary, located in the system directory. The dictionary contains 2 keyword entries:
patchMap and cuttingPatches. The patchMap list contains a mapping of patches from
the source ﬁelds to the target ﬁelds. It is used if the user wishes a patch in the target
ﬁeld to inherit values from a corresponding patch in the source ﬁeld. In cavityClipped, we
wish to inherit the boundary values on the lid patch from movingWall in cavity so we
must set the patchMap as:
patchMap
(
lid movingWall
);
The cuttingPatches list contains names of target patches whose values are to be
mapped from the source internal ﬁeld through which the target patch cuts. In this case
we will include the fixedWalls to demonstrate the interpolation process.
cuttingPatches
(
fixedWalls
);
Now the user should run mapFields, from within the cavityClipped directory:
mapFields ../cavity
Open∇FOAM-1.6
2.1 Lid-driven cavity ﬂow U-45
Figure 2.13: cavity solution velocity ﬁeld mapped onto cavityClipped.
Figure 2.14: cavityClipped solution for velocity ﬁeld.
Open∇FOAM-1.6
U-46 Tutorials
The user can view the mapped ﬁeld as shown in Figure 2.13. The boundary patches
have inherited values from the source case as we expected. Having demonstrated this,
however, we actually wish to reset the velocity on the fixedWalls patch to (0, 0, 0). Edit
the U ﬁeld, go to the fixedWalls patch and change the ﬁeld from nonuniform to uniform
(0, 0, 0). The nonuniform ﬁeld is a list of values that requires deleting in its entirety. Now
run the case with icoFoam.
2.1.10 Post-processing the modiﬁed geometry
Velocity glyphs can be generated for the case as normal, ﬁrst at time 0.5 s and later at
time 0.6 s, to compare the initial and ﬁnal solutions. In addition, we provide an outline of
the geometry which requires some care to generate for a 2D case. The user should select
Extract Block from the Filter menu and, in the Parameter panel, highlight the patches
of interest, namely the lid and ﬁxedWalls. On clicking Apply, these items of geometry can
be displayed by selecting Wireframe in the Display panel. Figure 2.14 displays the patches
in black and shows vortices forming in the bottom corners of the modiﬁed geometry.
2.2 Stress analysis of a plate with a hole
This tutorial describes how to pre-process, run and post-process a case involving linear-
elastic, steady-state stress analysis on a square plate with a circular hole at its centre.
The plate dimensions are: side length 4 m and radius R = 0.5 m. It is loaded with a
uniform traction of σ = 10 kPa over its left and right faces as shown in Figure 2.15. Two
symmetry planes can be identiﬁed for this geometry and therefore the solution domain
need only cover a quarter of the geometry, shown by the shaded area in Figure 2.15.
xsymmetry plane
4.0 m
y
σ = 10 kPaσ = 10 kPa
R = 0.5 m
symmetryplane
Figure 2.15: Geometry of the plate with a hole.
The problem can be approximated as 2-dimensional since the load is applied in the
plane of the plate. In a Cartesian coordinate system there are two possible assumptions
to take in regard to the behaviour of the structure in the third dimension: (1) the plane
Open∇FOAM-1.6
2.2 Stress analysis of a plate with a hole U-47
stress condition, in which the stress components acting out of the 2D plane are assumed
to be negligible; (2) the plane strain condition, in which the strain components out of
the 2D plane are assumed negligible. The plane stress condition is appropriate for solids
whose third dimension is thin as in this case; the plane strain condition is applicable for
solids where the third dimension is thick.
An analytical solution exists for loading of an inﬁnitely large, thin plate with a circular
hole. The solution for the stress normal to the vertical plane of symmetry is
(σxx)x=0 =



σ 1 +
R2
2y2
+
3R4
2y4
for |y| ≥ R
0 for |y| < R
(2.14)
Results from the simulation will be compared with this solution. At the end of the
tutorial, the user can: investigate the sensitivity of the solution to mesh resolution and
mesh grading; and, increase the size of the plate in comparison to the hole to try to
estimate the error in comparing the analytical solution for an inﬁnite plate to the solution
of this problem of a ﬁnite plate.
2.2.1 Mesh generation
The domain consists of four blocks, some of which have arc-shaped edges. The block
structure for the part of the mesh in the x − y plane is shown in Figure 2.16. As already
mentioned in section 2.1.1.1, all geometries are generated in 3 dimensions in OpenFOAM
even if the case is to be as a 2 dimensional problem. Therefore a dimension of the block
in the z direction has to be chosen; here, 0.5 m is selected. It does not aﬀect the solution
since the traction boundary condition is speciﬁed as a stress rather than a force, thereby
making the solution independent of the cross-sectional area.
The user should change into the plateHole case in the $FOAM RUN/tutorials/stress-
Analysis/solidDisplacementFoam directory and open the constant/polyMesh/blockMeshDict
ﬁle in an editor, as listed below
17 convertToMeters 1;
18
19 vertices
20 (
21 (0.5 0 0)
22 (1 0 0)
23 (2 0 0)
24 (2 0.707107 0)
25 (0.707107 0.707107 0)
26 (0.353553 0.353553 0)
27 (2 2 0)
28 (0.707107 2 0)
29 (0 2 0)
30 (0 1 0)
31 (0 0.5 0)
32 (0.5 0 0.5)
33 (1 0 0.5)
34 (2 0 0.5)
35 (2 0.707107 0.5)
36 (0.707107 0.707107 0.5)
37 (0.353553 0.353553 0.5)
38 (2 2 0.5)
39 (0.707107 2 0.5)
40 (0 2 0.5)
41 (0 1 0.5)
42 (0 0.5 0.5)
43 );
44
45 blocks
46 (
47 hex (5 4 9 10 16 15 20 21) (10 10 1) simpleGrading (1 1 1)
48 hex (0 1 4 5 11 12 15 16) (10 10 1) simpleGrading (1 1 1)
49 hex (1 2 3 4 12 13 14 15) (20 10 1) simpleGrading (1 1 1)
50 hex (4 3 6 7 15 14 17 18) (20 20 1) simpleGrading (1 1 1)
51 hex (9 4 7 8 20 15 18 19) (10 20 1) simpleGrading (1 1 1)
Open∇FOAM-1.6
U-48 Tutorials
x
y x2
x1 x1
x2
x2
x1
x1
x2
x2
x1
left
left
up 7 up
right
3
down
hole
0
down
right
6
9
8
4
10
10 2
5
2
1
4 3
Figure 2.16: Block structure of the mesh for the plate with a hole.
52 );
53
54 edges
55 (
56 arc 0 5 (0.469846 0.17101 0)
57 arc 5 10 (0.17101 0.469846 0)
58 arc 1 4 (0.939693 0.34202 0)
59 arc 4 9 (0.34202 0.939693 0)
60 arc 11 16 (0.469846 0.17101 0.5)
61 arc 16 21 (0.17101 0.469846 0.5)
62 arc 12 15 (0.939693 0.34202 0.5)
63 arc 15 20 (0.34202 0.939693 0.5)
64 );
65
66 patches
67 (
68 symmetryPlane left
69 (
70 (8 9 20 19)
71 (9 10 21 20)
72 )
73 patch right
74 (
75 (2 3 14 13)
76 (3 6 17 14)
77 )
78 symmetryPlane down
79 (
80 (0 1 12 11)
81 (1 2 13 12)
82 )
83 patch up
84 (
85 (7 8 19 18)
86 (6 7 18 17)
87 )
88 patch hole
89 (
90 (10 5 16 21)
Open∇FOAM-1.6
2.2 Stress analysis of a plate with a hole U-49
91 (5 0 11 16)
92 )
93 empty frontAndBack
94 (
95 (10 9 4 5)
96 (5 4 1 0)
97 (1 4 3 2)
98 (4 7 6 3)
99 (4 9 8 7)
100 (21 16 15 20)
101 (16 11 12 15)
102 (12 13 14 15)
103 (15 14 17 18)
104 (15 18 19 20)
105 )
106 );
107
108 mergePatchPairs
109 (
110 );
111
112 // ************************************************************************* //
Until now, we have only speciﬁed straight edges in the geometries of previous tutorials but
here we need to specify curved edges. These are speciﬁed under the edges keyword entry
which is a list of non-straight edges. The syntax of each list entry begins with the type
of curve, including arc, simpleSpline, polyLine etc., described further in section 5.3.1.
In this example, all the edges are circular and so can be speciﬁed by the arc keyword
entry. The following entries are the labels of the start and end vertices of the arc and a
point vector through which the circular arc passes.
The blocks in this blockMeshDict do not all have the same orientation. As can be seen
in Figure 2.16 the x2 direction of block 0 is equivalent to the −x1 direction for block 4.
This means care must be taken when deﬁning the number and distribution of cells in each
block so that the cells match up at the block faces.
6 patches are deﬁned: one for each side of the plate, one for the hole and one for the
front and back planes. The left and down patches are both a symmetry plane. Since this
is a geometric constraint, it is included in the deﬁnition of the mesh, rather than being
purely a speciﬁcation on the boundary condition of the ﬁelds. Therefore they are deﬁned
as such using a special symmetryPlane type as shown in the blockMeshDict.
The frontAndBack patch represents the plane which is ignored in a 2D case. Again
this is a geometric constraint so is deﬁned within the mesh, using the empty type as shown
in the blockMeshDict. For further details of boundary types and geometric constraints,
the user should refer to section 5.2.1.
The remaining patches are of the regular patch type. The mesh should be generated
using blockMesh and can be viewed in paraFoam as described in section 2.1.2. It should
appear as in Figure 2.17.
2.2.1.1 Boundary and initial conditions
Once the mesh generation is complete, the initial ﬁeld with boundary conditions must be
set. For a stress analysis case without thermal stresses, only displacement D needs to be
set. The 0/D is as follows:
17 dimensions [0 1 0 0 0 0 0];
18
19 internalField uniform (0 0 0);
20
21 boundaryField
22 {
23 left
24 {
25 type symmetryPlane;
26 }
27 right
28 {
Open∇FOAM-1.6
U-50 Tutorials
Figure 2.17: Mesh of the hole in a plate problem.
29 type tractionDisplacement;
30 traction uniform ( 10000 0 0 );
31 pressure uniform 0;
32 value uniform (0 0 0);
33 }
34 down
35 {
36 type symmetryPlane;
37 }
38 up
39 {
40 type tractionDisplacement;
41 traction uniform ( 0 0 0 );
42 pressure uniform 0;
43 value uniform (0 0 0);
44 }
45 hole
46 {
47 type tractionDisplacement;
48 traction uniform ( 0 0 0 );
49 pressure uniform 0;
50 value uniform (0 0 0);
51 }
52 frontAndBack
53 {
54 type empty;
55 }
56 }
57
58 // ************************************************************************* //
Firstly, it can be seen that the displacement initial conditions are set to (0, 0, 0) m. The
left and down patches must be both of symmetryPlane type since they are speciﬁed
as such in the mesh description in the constant/polyMesh/boundary ﬁle. Similarly the
frontAndBack patch is declared empty.
The other patches are traction boundary conditions, set by a specialist traction bound-
ary type. The traction boundary conditions are speciﬁed by a linear combination of: (1)
a boundary traction vector under keyword traction; (2) a pressure that produces a trac-
tion normal to the boundary surface that is deﬁned as negative when pointing out of
the surface, under keyword pressure. The up and hole patches are zero traction so the
boundary traction and pressure are set to zero. For the right patch the traction should
be (1e4, 0, 0) Pa and the pressure should be 0 Pa.
Open∇FOAM-1.6
2.2 Stress analysis of a plate with a hole U-51
2.2.1.2 Mechanical properties
The physical properties for the case are set in the mechanicalProperties dictionary in the
constant directory. For this problem, we need to specify the mechanical properties of
steel given in Table 2.1. In the mechanical properties dictionary, the user must also set
planeStress to yes.
Property Units Keyword Value
Density kg m−3
rho 7854
Young’s modulus Pa E 2 × 1011
Poisson’s ratio — nu 0.3
Table 2.1: Mechanical properties for steel
2.2.1.3 Thermal properties
The temperature ﬁeld variable T is present in the solidDisplacementFoam solver since the
user may opt to solve a thermal equation that is coupled with the momentum equation
through the thermal stresses that are generated. The user speciﬁes at run time whether
OpenFOAM should solve the thermal equation by the thermalStress switch in the ther-
malProperties dictionary. This dictionary also sets the thermal properties for the case,
e.g. for steel as listed in Table 2.2.
Property Units Keyword Value
Speciﬁc heat capacity Jkg−1
K−1
C 434
Thermal conductivity Wm−1
K−1
k 60.5
Thermal expansion coeﬀ. K−1
alpha 1.1 × 10−5
Table 2.2: Thermal properties for steel
In this case we do not want to solve for the thermal equation. Therefore we must set
the thermalStress keyword entry to no in the thermalProperties dictionary.
2.2.1.4 Control
As before, the information relating to the control of the solution procedure are read in
from the controlDict dictionary. For this case, the startTime is 0 s. The time step is
not important since this is a steady state case; in this situation it is best to set the time
step deltaT to 1 so it simply acts as an iteration counter for the steady-state case. The
endTime, set to 100, then acts as a limit on the number of iterations. The writeInterval
can be set to 20.
The controlDict entries are as follows:
17
18 application solidDisplacementFoam;
19
20 startFrom startTime;
21
22 startTime 0;
23
24 stopAt endTime;
25
26 endTime 100;
27
28 deltaT 1;
29
30 writeControl timeStep;
Open∇FOAM-1.6
U-52 Tutorials
31
32 writeInterval 20;
33
34 purgeWrite 0;
35
36 writeFormat ascii;
37
38 writePrecision 6;
39
40 writeCompression uncompressed;
41
42 timeFormat general;
43
44 timePrecision 6;
45
46 graphFormat raw;
47
48 runTimeModifiable yes;
49
50
51 // ************************************************************************* //
2.2.1.5 Discretisation schemes and linear-solver control
Let us turn our attention to the fvSchemes dictionary. Firstly, the problem we are
analysing is steady-state so the user should select SteadyState for the time derivatives
in timeScheme. This essentially switches oﬀ the time derivative terms. Not all solvers,
especially in ﬂuid dynamics, work for both steady-state and transient problems but solid-
DisplacementFoam does work, since the base algorithm is the same for both types of
simulation.
The momentum equation in linear-elastic stress analysis includes several explicit terms
containing the gradient of displacement. The calculations beneﬁt from accurate and
smooth evaluation of the gradient. Normally, in the ﬁnite volume method the discreti-
sation is based on Gauss’s theorem The Gauss method is suﬃciently accurate for most
purposes but, in this case, the least squares method will be used. The user should there-
fore open the fvSchemes dictionary in the system directory and ensure the leastSquares
method is selected for the grad(U) gradient discretisation scheme in the gradSchemes
sub-dictionary:
17
18 d2dt2Schemes
19 {
20 default steadyState;
21 }
22
23 gradSchemes
24 {
25 default leastSquares;
26 grad(D) leastSquares;
27 grad(T) leastSquares;
28 }
29
30 divSchemes
31 {
32 default none;
33 div(sigmaD) Gauss linear;
34 }
35
36 laplacianSchemes
37 {
38 default none;
39 laplacian(DD,D) Gauss linear corrected;
40 laplacian(DT,T) Gauss linear corrected;
41 }
42
43 interpolationSchemes
44 {
45 default linear;
46 }
47
48 snGradSchemes
49 {
50 default none;
Open∇FOAM-1.6
2.2 Stress analysis of a plate with a hole U-53
51 }
52
53 fluxRequired
54 {
55 default no;
56 D yes;
57 T no;
58 }
59
60
61 // ************************************************************************* //
The fvSolution dictionary in the system directory controls the linear equation solvers and
algorithms used in the solution. The user should ﬁrst look at the solvers sub-dictionary
and notice that the choice of solver for D is GAMG. The solver tolerance should be set to
10−6
for this problem. The solver relative tolerance, denoted by relTol, sets the required
reduction in the residuals within each iteration. It is uneconomical to set a tight (low)
relative tolerance within each iteration since a lot of terms in each equation are explicit
and are updated as part of the segregated iterative procedure. Therefore a reasonable
value for the relative tolerance is 0.01, or possibly even higher, say 0.1, or in some cases
even 0.9 (as in this case).
17
18 solvers
19 {
20 D
21 {
22 solver GAMG;
23 tolerance 1e-06;
24 relTol 0.9;
25 smoother GaussSeidel;
26 cacheAgglomeration true;
27 nCellsInCoarsestLevel 20;
28 agglomerator faceAreaPair;
29 mergeLevels 1;
30 }
31
32 T
33 {
34 solver GAMG;
35 tolerance 1e-06;
36 relTol 0.9;
37 smoother GaussSeidel;
38 cacheAgglomeration true;
39 nCellsInCoarsestLevel 20;
40 agglomerator faceAreaPair;
41 mergeLevels 1;
42 }
43 }
44
45 stressAnalysis
46 {
47 compactNormalStress yes;
48 nCorrectors 1;
49 D 1e-06;
50 }
51
52
53 // ************************************************************************* //
The fvSolution dictionary contains a sub-dictionary, stressAnalysis that contains some con-
trol parameters speciﬁc to the application solver. Firstly there is nCorrectors which
speciﬁes the number of outer loops around the complete system of equations, including
traction boundary conditions within each time step. Since this problem is steady-state,
we are performing a set of iterations towards a converged solution with the ’time step’
acting as an iteration counter. We can therefore set nCorrectors to 1.
The D keyword speciﬁes a convergence tolerance for the outer iteration loop, i.e. sets
a level of initial residual below which solving will cease. It should be set to the desired
solver tolerance speciﬁed earlier, 10−6
for this problem.
Open∇FOAM-1.6
U-54 Tutorials
2.2.2 Running the code
The user should run the code here in the background from the command line as speciﬁed
below, so he/she can look at convergence information in the log ﬁle afterwards.
cd $FOAM RUN/tutorials/stressAnalysis/solidDisplacementFoam/plateHole
solidDisplacementFoam > log &
The user should check the convergence information by viewing the generated log ﬁle which
shows the number of iterations and the initial and ﬁnal residuals of the displacement in
each direction being solved. The ﬁnal residual should always be less than 0.9 times the
initial residual as this iteration tolerance set. Once both initial residuals have dropped
below the convergence tolerance of 10−6
the run has converged and can be stopped by
killing the batch job.
2.2.3 Post-processing
Post processing can be performed as in section 2.1.4. The solidDisplacementFoam solver
outputs the stress ﬁeld σ as a symmetric tensor ﬁeld sigma. This is consistent with the
way variables are usually represented in OpenFOAM solvers by the mathematical symbol
by which they are represented; in the case of Greek symbols, the variable is named
phonetically.
For post-processing individual scalar ﬁeld components, σxx, σxy etc., can be generated
by running the foamCalc utility as before in section 2.1.5.7, this time on sigma:
foamCalc components sigma
Components named sigmaxx, sigmaxy etc. are written to time directories of the case.
The σxx stresses can be viewed in paraFoam as shown in Figure 2.18.
0
5
10
15
20
25
30
σxx(kPa)
Figure 2.18: σxx stress ﬁeld in the plate with hole.
We would like to compare the analytical solution of Equation 2.14 to our solution.
We therefore must output a set of data of σxx along the left edge symmetry plane of
our domain. The user may generate the required graph data using the sample utility.
The utility uses a sampleDict dictionary located in the system directory, whose entries are
summarised in Table 6.3. The sample line speciﬁed in sets is set between (0.0, 0.5, 0.25)
and (0.0, 2.0, 0.25), and the ﬁelds are speciﬁed in the fields list:
Open∇FOAM-1.6
2.2 Stress analysis of a plate with a hole U-55
0
5
10
15
20
25
30
35
0.6 0.8 1.0 1.2 1.4 1.6 1.8 2.0
Stress(σxx)x=0(kPa)
Distance, y (m)
Numerical prediction Analytical solution
Figure 2.19: Normal stress along the vertical symmetry (σxx)x=0
17
18 interpolationScheme cellPoint;
19
20 setFormat raw;
21
22 sets
23 (
24 leftPatch
25 {
26 type uniform;
27 axis y;
28 start ( 0 0.5 0.25 );
29 end ( 0 2 0.25 );
30 nPoints 100;
31 }
32 );
33
34 surfaces ();
35
36 fields ( sigmaxx );
37
38
39 // ************************************************************************* //
The user should execute sample as normal. The writeFormat is raw 2 column format.
The data is written into ﬁles within time subdirectories of a sets directory, e.g. the data
at t = 100 s is found within the ﬁle sets/100/leftPatch sigmaxx.xy. In an application such
as GnuPlot, one could type the following at the command prompt would be suﬃcient to
plot both the numerical data and analytical solution:
plot [0.5:2] [0:] ’sets/100/leftPatch sigmaxx.xy’,
1e4*(1+(0.125/(x**2))+(0.09375/(x**4)))
An example plot is shown in Figure 2.19.
2.2.4 Exercises
The user may wish to experiment with solidDisplacementFoam by trying the following
exercises:
2.2.4.1 Increasing mesh resolution
Increase the mesh resolution in each of the x and y directions. Use mapFields to map the
ﬁnal coarse mesh results from section 2.2.3 to the initial conditions for the ﬁne mesh.
Open∇FOAM-1.6
U-56 Tutorials
2.2.4.2 Introducing mesh grading
Grade the mesh so that the cells near the hole are ﬁner than those away from the hole.
Design the mesh so that the ratio of sizes between adjacent cells is no more than 1.1
and so that the ratio of cell sizes between blocks is similar to the ratios within blocks.
Mesh grading is described in section 2.1.6. Again use mapFields to map the ﬁnal coarse
mesh results from section 2.2.3 to the initial conditions for the graded mesh. Compare
the results with those from the analytical solution and previous calculations. Can this
solution be improved upon using the same number of cells with a diﬀerent solution?
2.2.4.3 Changing the plate size
The analytical solution is for an inﬁnitely large plate with a ﬁnite sized hole in it. There-
fore this solution is not completely accurate for a ﬁnite sized plate. To estimate the error,
increase the plate size while maintaining the hole size at the same value.
2.3 Breaking of a dam
In this tutorial we shall solve a problem of simpliﬁed dam break in 2 dimensions using
the interFoam.The feature of the problem is a transient ﬂow of two ﬂuids separated by
a sharp interface, or free surface. The two-phase algorithm in interFoam is based on the
volume of ﬂuid (VOF) method in which a specie transport equation is used to determine
the relative volume fraction of the two phases, or phase fraction α1, in each computational
cell. Physical properties are calculated as weighted averages based on this fraction. The
nature of the VOF method means that an interface between the species is not explicitly
computed, but rather emerges as a property of the phase fraction ﬁeld. Since the phase
fraction can have any value between 0 and 1, the interface is never sharply deﬁned, but
occupies a volume around the region where a sharp interface should exist.
The test setup consists of a column of water at rest located behind a membrane on
the left side of a tank. At time t = 0 s, the membrane is removed and the column of
water collapses. During the collapse, the water impacts an obstacle at the bottom of the
tank and creates a complicated ﬂow structure, including several captured pockets of air.
The geometry and the initial setup is shown in Figure 2.20.
2.3.1 Mesh generation
The user should go to the damBreak case in their $FOAM RUN/tutorials/multiphase/inter-
Foam/laminar directory. Generate the mesh running blockMesh as described previously.
The damBreak mesh consist of 5 blocks; the blockMeshDict entries are given below.
17 convertToMeters 0.146;
18
19 vertices
20 (
21 (0 0 0)
22 (2 0 0)
23 (2.16438 0 0)
24 (4 0 0)
25 (0 0.32876 0)
26 (2 0.32876 0)
27 (2.16438 0.32876 0)
28 (4 0.32876 0)
29 (0 4 0)
30 (2 4 0)
31 (2.16438 4 0)
32 (4 4 0)
33 (0 0 0.1)
34 (2 0 0.1)
35 (2.16438 0 0.1)
Open∇FOAM-1.6
2.3 Breaking of a dam U-57
0.584 m
0.048 m
0.024 m
0.584 m
0.292 m
0.1459 m0.1461 m
water column
Figure 2.20: Geometry of the dam break.
36 (4 0 0.1)
37 (0 0.32876 0.1)
38 (2 0.32876 0.1)
39 (2.16438 0.32876 0.1)
40 (4 0.32876 0.1)
41 (0 4 0.1)
42 (2 4 0.1)
43 (2.16438 4 0.1)
44 (4 4 0.1)
45 );
46
47 blocks
48 (
49 hex (0 1 5 4 12 13 17 16) (23 8 1) simpleGrading (1 1 1)
50 hex (2 3 7 6 14 15 19 18) (19 8 1) simpleGrading (1 1 1)
51 hex (4 5 9 8 16 17 21 20) (23 42 1) simpleGrading (1 1 1)
52 hex (5 6 10 9 17 18 22 21) (4 42 1) simpleGrading (1 1 1)
53 hex (6 7 11 10 18 19 23 22) (19 42 1) simpleGrading (1 1 1)
54 );
55
56 edges
57 (
58 );
59
60 patches
61 (
62 wall leftWall
63 (
64 (0 12 16 4)
65 (4 16 20 8)
66 )
67 wall rightWall
68 (
69 (7 19 15 3)
70 (11 23 19 7)
71 )
72 wall lowerWall
73 (
74 (0 1 13 12)
75 (1 5 17 13)
76 (5 6 18 17)
77 (2 14 18 6)
78 (2 3 15 14)
79 )
80 patch atmosphere
81 (
82 (8 20 21 9)
Open∇FOAM-1.6
U-58 Tutorials
83 (9 21 22 10)
84 (10 22 23 11)
85 )
86 );
87
88 mergePatchPairs
89 (
90 );
91
92 // ************************************************************************* //
2.3.2 Boundary conditions
The user can examine the boundary geometry generated by blockMesh by viewing the
boundary ﬁle in the constant/polyMesh directory. The ﬁle contains a list of 5 boundary
patches: leftWall, rightWall, lowerWall, atmosphere and defaultFaces. The user
should notice the type of the patches. The atmosphere is a standard patch, i.e. has no
special attributes, merely an entity on which boundary conditions can be speciﬁed. The
defaultFaces patch is empty since the patch normal is in the direction we will not solve
in this 2D case. The leftWall, rightWall and lowerWall patches are each a wall. Like
the plain patch, the wall type contains no geometric or topological information about the
mesh and only diﬀers from the plain patch in that it identiﬁes the patch as a wall, should
an application need to know, e.g. to apply special wall surface modelling.
A good example is that the interFoam solver includes modelling of surface tension at
the contact point between the interface and wall surface. The models are applied by
specifying the alphaContactAngle boundary condition on the alpha1 (α1) ﬁeld. With it,
the user must specify the following: a static contact angle, theta0 θ0; leading and trailing
edge dynamic contact angles, thetaA θA and thetaR θR respectively; and a velocity scaling
function for dynamic contact angle, uTheta.
In this tutorial we would like to ignore surface tension eﬀects between the wall and
interface. We can do this by setting the static contact angle, θ0 = 90◦
and the velocity
scaling function to 0. However, the simpler option which we shall choose here is to specify
a zeroGradient type on alpha1, rather than use the alphaContactAngle boundary condition.
The top boundary is free to the atmosphere and so is given an atmosphere boundary
type; the defaultFaces representing the front and back planes of the 2D problem, is, as
usual, an empty type.
2.3.3 Setting initial ﬁeld
Unlike the previous cases, we shall now specify a non-uniform initial condition for the
phase fraction α1 where
α1 =
1 for the liquid phase
0 for the gas phase
(2.15)
This will be done by running the setFields utility. It requires a setFieldsDict dictionary,
located in the system directory, whose entries for this case are shown below.
17
18 defaultFieldValues
19 (
20 volScalarFieldValue alpha1 0
21 );
22
23 regions
24 (
25 boxToCell
26 {
27 box (0 0 -1) (0.1461 0.292 1);
28 fieldValues
Open∇FOAM-1.6
2.3 Breaking of a dam U-59
29 (
30 volScalarFieldValue alpha1 1
31 );
32 }
33 );
34
35
36 // ************************************************************************* //
The defaultFieldValues sets the default value of the ﬁelds, i.e. the value the ﬁeld
takes unless speciﬁed otherwise in the regions sub-dictionary. That sub-dictionary con-
tains a list of subdictionaries containing fieldValues that override the defaults in a
speciﬁed region. The region is expressed in terms of a topoSetSource that creates a set
of points, cells or faces based on some topological constraint. Here, boxToCell creates
a bounding box within a vector minimum and maximum to deﬁne the set of cells of the
liquid region. The phase fraction α1 is deﬁned as 1 in this region.
The user should execute setFields as any other utility is executed. Using paraFoam,
check that the initial alpha1 ﬁeld corresponds to the desired distribution as in Figure 2.21.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
Figure 2.21: Initial conditions for phase fraction alpha1.
2.3.4 Fluid properties
Let us examine the transportProperties ﬁle in the constant directory. It dictionary con-
tains the material properties for each ﬂuid, separated into two subdictionaries phase1
and phase2. The transport model for each phase is selected by the transportModel
keyword. The user should select Newtonian in which case the kinematic viscosity is sin-
gle valued and speciﬁed under the keyword nu. The viscosity parameters for the other
models, e.g.CrossPowerLaw, are speciﬁed within subdictionaries with the generic name
<model>Coeﬀs, i.e.CrossPowerLawCoeﬀs in this example. The density is speciﬁed under
the keyword rho.
The surface tension between the two phases is speciﬁed under the keyword sigma.
The values used in this tutorial are listed in Table 2.3.
Gravitational acceleration is uniform across the domain and is speciﬁed in a ﬁle named
g in the constant directory. Unlike a normal ﬁeld ﬁle, e.g. U and p, g is a uniformDimen-
sionedVectorField and so simply contains a set of dimensions and a value that represents
(0, 9.81, 0) m s−2
for this tutorial:
Open∇FOAM-1.6
U-60 Tutorials
phase1 properties
Kinematic viscosity m2
s−1
nu 1.0 × 10−6
Density kg m−3
rho 1.0 × 103
phase2 properties
Kinematic viscosity m2
s−1
nu 1.48 × 10−5
Density kg m−3
rho 1.0
Properties of both phases
Surface tension N m−1
sigma 0.07
Table 2.3: Fluid properties for the damBreak tutorial
17
18 dimensions [0 1 -2 0 0 0 0];
19 value ( 0 -9.81 0 );
20
21
22 // ************************************************************************* //
2.3.5 Turbulence modelling
As in the cavity example, the choice of turbulence modelling method is selectable at run-
time through the simulationType keyword in turbulenceProperties dictionary. In this
example, we wish to run without turbulence modelling so we set laminar:
17
18 simulationType laminar;
19
20
21 // ************************************************************************* //
2.3.6 Time step control
Time step control is an important issue in free surface tracking since the surface-tracking
algorithm is considerably more sensitive to the Courant number Co than in standard ﬂuid
ﬂow calculations. Ideally, we should not exceed an upper limit Co ≈ 0.5 in the region
of the interface. In some cases, where the propagation velocity is easy to predict, the
user should specify a ﬁxed time-step to satisfy the Co criterion. For more complex cases,
this is considerably more diﬃcult. interFoam therefore oﬀers automatic adjustment of the
time step as standard in the controlDict. The user should specify adjustTimeStep to be
on and the the maximum Co, maxCo to be 0.5. The upper limit on time step maxDeltaT
can be set to a value that will not be exceeded in this simulation, e.g. 1.0.
By using automatic time step control, the steps themselves are never rounded to a
convenient value. Consequently if we request that OpenFOAM saves results at a ﬁxed
number of time step intervals, the times at which results are saved are somewhat arbitrary.
However even with automatic time step adjustment, OpenFOAM allows the user to specify
that results are written at ﬁxed times; in this case OpenFOAM forces the automatic time
stepping procedure to adjust time steps so that it ‘hits’ on the exact times speciﬁed for
write output. The user selects this with the adjustableRunTime option for writeControl
in the controlDict dictionary. The controlDict dictionary entries should be:
17
18 application interFoam;
19
20 startFrom startTime;
21
Open∇FOAM-1.6
2.3 Breaking of a dam U-61
22 startTime 0;
23
24 stopAt endTime;
25
26 endTime 1;
27
28 deltaT 0.001;
29
30 writeControl adjustableRunTime;
31
32 writeInterval 0.05;
33
34 purgeWrite 0;
35
36 writeFormat ascii;
37
38 writePrecision 6;
39
40 writeCompression uncompressed;
41
42 timeFormat general;
43
44 timePrecision 6;
45
46 runTimeModifiable yes;
47
48 adjustTimeStep yes;
49
50 maxCo 0.5;
51
52 maxDeltaT 1;
53
54
55 // ************************************************************************* //
2.3.7 Discretisation schemes
The free surface treatment in OpenFOAM does not account for the eﬀects of turbulence.
This is a consequence of the fact that the Reynolds averaged approach to turbulence
modelling does not match the notion of an inﬁnitesimally thin interface between air and
water. As a consequence, all free surface simulations can be viewed as a direct numerical
simulation (DNS) of ﬂuid ﬂow. DNS is associated with certain requirements on the mesh
size, far beyond the mesh resolution of our test case.
This solver uses the multidimensional universal limiter for explicit solution (MULES)
method, created by OpenCFD, to maintain boundedness of the phase fraction indepen-
dent of underlying numerical scheme, mesh structure, etc. The choice of schemes for
convection are therfore not restricted to those that are strongly stable or bounded, e.g.
upwind diﬀerencing.
The convection schemes settings are made in the divSchemes sub-dictionary of the
fvSchemes dictionary. In this example, the convection term in the momentum equation
(∇ • (ρUU)), denoted by the div(rho*phi,U) keyword, uses Gauss limitedLinearV
1.0 to produce good accuracy. The limited linear schemes require a coeﬃcient φ as
described in section 4.4.1. Here, we have opted for best stability with φ = 1.0. The
∇ • (Uα1) term, represented by the div(phi,alpha) keyword uses the vanLeer scheme.
The ∇ • (Urbα1) term, represented by the div(phirb,alpha) keyword, can similarly use
the vanLeer scheme, but generally produces smoother interfaces using the specialised
interfaceCompression scheme.
The other discretised terms use commonly employed schemes so that the fvSchemes
dictionary entries should therefore be:
17
18 ddtSchemes
19 {
20 default Euler;
21 }
22
23 gradSchemes
24 {
Open∇FOAM-1.6
U-62 Tutorials
25 default Gauss linear;
26 grad(U) Gauss linear;
27 grad(alpha1) Gauss linear;
28 }
29
30 divSchemes
31 {
32 div(rho*phi,U) Gauss limitedLinearV 1;
33 div(phi,alpha) Gauss vanLeer;
34 div(phirb,alpha) Gauss interfaceCompression;
35 }
36
37 laplacianSchemes
38 {
39 default Gauss linear corrected;
40 }
41
42 interpolationSchemes
43 {
44 default linear;
45 }
46
47 snGradSchemes
48 {
49 default corrected;
50 }
51
52 fluxRequired
53 {
54 default no;
55 p;
56 pcorr;
57 alpha1;
58 }
59
60
61 // ************************************************************************* //
2.3.8 Linear-solver control
In the fvSolution, the PISO sub-dictionary contains elements that are speciﬁc to interFoam.
There are the usual correctors to the momentum equation but also correctors to a PISO
loop around the α1 phase equation. Of particular interest are the nAlphaSubCycles and
cAlpha keywords. nAlphaSubCycles represents the number of sub-cycles within the α1
equation; sub-cycles are additional solutions to an equation within a given time step. It
is used to enable the solution to be stable without reducing the time step and vastly
increasing the solution time. Here we specify 2 sub-cycles, which means that the α1
equation is solved in 2× half length time steps within each actual time step.
The cAlpha keyword is a factor that controls the compression of the interface where: 0
corresponds to no compression; 1 corresponds to conservative compression; and, anything
larger than 1, relates to enhanced compression of the interface. We generally recommend
a value of 1.0 which is employed in this example.
2.3.9 Running the code
Running of the code has been described in detail in previous tutorials. Try the following,
that uses tee, a command that enables output to be written to both standard output and
ﬁles:
cd $FOAM RUN/tutorials/multiphase/interFoam/laminar/damBreak
interFoam | tee log
The code will now be run interactively, with a copy of output stored in the log ﬁle.
Open∇FOAM-1.6
2.3 Breaking of a dam U-63
2.3.10 Post-processing
Post-processing of the results can now be done in the usual way. The user can monitor
the development of the phase fraction alpha1 in time; Figure 2.22.
2.3.11 Running in parallel
The results from the previous example are generated using a fairly coarse mesh. We now
wish to increase the mesh resolution and re-run the case. The new case will typically
take a few hours to run with a single processor so, should the user have access to multiple
processors, we can demonstrate the parallel processing capability of OpenFOAM.
The user should ﬁrst make a copy of the damBreak case, e.g. by
cd $FOAM RUN/tutorials/multiphase/interFoam/laminar
mkdir damBreakFine
cp -r damBreak/0 damBreakFine
cp -r damBreak/system damBreakFine
cp -r damBreak/constant damBreakFine
Enter the new case directory and change the blocks description in the blockMeshDict
dictionary to
blocks
(
hex (0 1 5 4 12 13 17 16) (46 10 1) simpleGrading (1 1 1)
hex (2 3 7 6 14 15 19 18) (40 10 1) simpleGrading (1 1 1)
hex (4 5 9 8 16 17 21 20) (46 76 1) simpleGrading (1 2 1)
hex (5 6 10 9 17 18 22 21) (4 76 1) simpleGrading (1 2 1)
hex (6 7 11 10 18 19 23 22) (40 76 1) simpleGrading (1 2 1)
);
Here, the entry is presented as printed from the blockMeshDict ﬁle; in short the user must
change the mesh densities, e.g. the 46 10 1 entry, and some of the mesh grading entries
to 1 2 1. Once the dictionary is correct, generate the mesh.
As the mesh has now changed from the damBreak example, the user must re-initialise
the phase ﬁeld alpha1 in the 0 time directory since it contains a number of elements that
is inconsistent with the new mesh. Note that there is no need to change the U and p
ﬁelds since they are speciﬁed as uniform which is independent of the number of elements
in the ﬁeld. We wish to initialise the ﬁeld with a sharp interface, i.e. it elements would
have α1 = 1 or α1 = 0. Updating the ﬁeld with mapFields may produce interpolated
values 0 < α1 < 1 at the interface, so it is better to rerun the setFields utility. There is a
backup copy of the initial uniform α1 ﬁeld named 0/alpha1.org that the user should copy
to 0/alpha1 before running setFields:
cd $FOAM RUN/tutorials/multiphase/interFoam/laminar/damBreakFine
cp -r 0/alpha1.org 0/alpha1
setFields
The method of parallel computing used by OpenFOAM is known as domain de-
composition, in which the geometry and associated ﬁelds are broken into pieces and
allocated to separate processors for solution. The ﬁrst step required to run a parallel
Open∇FOAM-1.6
U-64 Tutorials
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
(a) At t = 0.25 s.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
(b) At t = 0.50 s.
Figure 2.22: Snapshots of phase α1.
Open∇FOAM-1.6
2.3 Breaking of a dam U-65
case is therefore to decompose the domain using the decomposePar utility. There is a
dictionary associated with decomposePar named decomposeParDict which is located in
the system directory of the tutorial case; also, like with many utilities, a default dic-
tionary can be found in the directory of the source code of the speciﬁc utility, i.e. in
$FOAM UTILITIES/parallelProcessing/decomposePar for this case.
The ﬁrst entry is numberOfSubdomains which speciﬁes the number of subdomains into
which the case will be decomposed, usually corresponding to the number of processors
available for the case.
In this tutorial, the method of decomposition should be simple and the corresponding
simpleCoeffs should be edited according to the following criteria. The domain is split
into pieces, or subdomains, in the x, y and z directions, the number of subdomains in
each direction being given by the vector n. As this geometry is 2 dimensional, the 3rd
direction, z, cannot be split, hence nz must equal 1. The nx and ny components of n
split the domain in the x and y directions and must be speciﬁed so that the number
of subdomains speciﬁed by nx and ny equals the speciﬁed numberOfSubdomains, i.e.
nxny = numberOfSubdomains. It is beneﬁcial to keep the number of cell faces adjoining
the subdomains to a minimum so, for a square geometry, it is best to keep the split
between the x and y directions should be fairly even. The delta keyword should be set
to 0.001.
For example, let us assume we wish to run on 4 processors. We would set number-
OfSubdomains to 4 and n = (2, 2, 1). When running decomposePar, we can see from the
screen messages that the decomposition is distributed fairly even between the processors.
The user should consult section 3.4 for details of how to run a case in parallel; in
this tutorial we merely present an example of running in parallel. We use the openMPI
implementation of the standard message-passing interface (MPI). As a test here, the user
can run in parallel on a single node, the local host only, by typing:
mpirun -np 4 interFoam -parallel > log &
The user may run on more nodes over a network by creating a ﬁle that lists the host
names of the machines on which the case is to be run as described in section 3.4.2. The
case should run in the background and the user can follow its progress by monitoring the
log ﬁle as usual.
Figure 2.23: Mesh of processor 2 in parallel processed case.
Open∇FOAM-1.6
U-66 Tutorials
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
(a) At t = 0.25 s.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
(b) At t = 0.50 s.
Figure 2.24: Snapshots of phase α1 with reﬁned mesh.
Open∇FOAM-1.6
2.3 Breaking of a dam U-67
2.3.12 Post-processing a case run in parallel
Once the case has completed running, the decomposed ﬁelds and mesh must be reassem-
bled for post-processing using the reconstructPar utility. Simply execute it from the com-
mand line. The results from the ﬁne mesh are shown in Figure 2.24. The user can see
that the resolution of interface has improved signiﬁcantly compared to the coarse mesh.
The user may also post-process a segment of the decomposed domain individually by
simply treating the individual processor directory as a case in its own right. For example
if the user starts paraFoam by
paraFoam -case processor1
then processor1 will appear as a case module in ParaView. Figure 2.23 shows the mesh
from processor 1 following the decomposition of the domain using the simple method.
Open∇FOAM-1.6
U-68 Tutorials
Open∇FOAM-1.6
Chapter 3
Applications and libraries
We should reiterate from the outset that OpenFOAM is a C++ library used primarily to
create executables, known as applications. OpenFOAM is distributed with a large set of
precompiled applications but users also have the freedom to create their own or modify
existing ones. Applications are split into two main categories:
solvers that are each designed to solve a speciﬁc problem in computational continuum
mechanics;
utilities that perform simple pre-and post-processing tasks, mainly involving data ma-
nipulation and algebraic calculations.
OpenFOAM is divided into a set of precompiled libraries that are dynamically linked
during compilation of the solvers and utilities. Libraries such as those for physical models
are supplied as source code so that users may conveniently add their own models to the
libraries.
This chapter gives an overview of solvers, utilities and libraries, their creation, mod-
iﬁcation, compilation and execution. The actual writing of code for solvers and utilities
is not described here but is within the Programmer’s Guide. The Programmer’s Guide is
currently under development so, if users have any queries, further information may also
available at the OpenFOAM web site.
3.1 The programming language of OpenFOAM
In order to understand the way in which the OpenFOAM library works, some background
knowledge of C++, the base language of OpenFOAM, is required; the necessary infor-
mation will be presented in this chapter. Before doing so, it is worthwhile addressing the
concept of language in general terms to explain some of the ideas behind object-oriented
programming and our choice of C++ as the main programming language of OpenFOAM.
3.1.1 Language in general
The success of verbal language and mathematics is based on eﬃciency, especially in
expressing abstract concepts. For example, in ﬂuid ﬂow, we use the term “velocity ﬁeld”,
which has meaning without any reference to the nature of the ﬂow or any speciﬁc velocity
data. The term encapsulates the idea of movement with direction and magnitude and
relates to other physical properties. In mathematics, we can represent velocity ﬁeld by
a single symbol, e.g. U, and express certain concepts using symbols, e.g. “the ﬁeld of
velocity magnitude” by |U|. The advantage of mathematics over verbal language is its
greater eﬃciency, making it possible to express complex concepts with extreme clarity.
U-70 Applications and libraries
The problems that we wish to solve in continuum mechanics are not presented in
terms of intrinsic entities, or types, known to a computer, e.g. bits, bytes, integers. They
are usually presented ﬁrst in verbal language, then as partial diﬀerential equations in 3
dimensions of space and time. The equations contain the following concepts: scalars,
vectors, tensors, and ﬁelds thereof; tensor algebra; tensor calculus; dimensional units.
The solution to these equations involves discretisation procedures, matrices, solvers, and
solution algorithms. The topics of tensor mathematics and numerics are the subjects of
chapter 1 and chapter 2 of the Programmer’s Guide.
3.1.2 Object-orientation and C++
Progamming languages that are object-oriented, such as C++, provide the mechanism
— classes — to declare types and associated operations that are part of the verbal and
mathematical languages used in science and engineering. Our velocity ﬁeld introduced
earlier can be represented in programming code by the symbol U and “the ﬁeld of velocity
magnitude” can be mag(U). The velocity is a vector ﬁeld for which there should exist,
in an object-oriented code, a vectorField class. The velocity ﬁeld U would then be an
instance, or object, of the vectorField class; hence the term object-oriented.
The clarity of having objects in programming that represent physical objects and
abstract entities should not be underestimated. The class structure concentrates code
development to contained regions of the code, i.e. the classes themselves, thereby making
the code easier to manage. New classes can be derived or inherit properties from other
classes, e.g. the vectorField can be derived from a vector class and a Field class. C++
provides the mechanism of template classes such that the template class Field<Type> can
represent a ﬁeld of any <Type>, e.g.scalar, vector, tensor. The general features of the
template class are passed on to any class created from the template. Templating and
inheritance reduce duplication of code and create class hierarchies that impose an overall
structure on the code.
3.1.3 Equation representation
A central theme of the OpenFOAM design is that the solver applications, written using the
OpenFOAM classes, have a syntax that closely resembles the partial diﬀerential equations
being solved. For example the equation
∂ρU
∂t
+ ∇ • φU − ∇ • µ∇U = −∇p
is represented by the code
solve
(
fvm::ddt(rho, U)
+ fvm::div(phi, U)
- fvm::laplacian(mu, U)
==
- fvc::grad(p)
);
This and other requirements demand that the principal programming language of Open-
FOAM has object-oriented features such as inheritance, template classes, virtual functions
Open∇FOAM-1.6
3.2 Compiling applications and libraries U-71
and operator overloading. These features are not available in many languages that pur-
port to be object-orientated but actually have very limited object-orientated capability,
such as FORTRAN-90. C++, however, possesses all these features while having the ad-
ditional advantage that it is widely used with a standard speciﬁcation so that reliable
compilers are available that produce eﬃcient executables. It is therefore the primary
language of OpenFOAM.
3.1.4 Solver codes
Solver codes are largely procedural since they are a close representation of solution algo-
rithms and equations, which are themselves procedural in nature. Users do not need a
deep knowledge of object-orientation and C++ programming to write a solver but should
know the principles behind object-orientation and classes, and to have a basic knowledge
of some C++ code syntax. An understanding of the underlying equations, models and
solution method and algorithms is far more important.
There is often little need for a user to immerse themselves in the code of any of the
OpenFOAM classes. The essence of object-orientation is that the user should not have
to; merely the knowledge of the class’ existence and its functionality are suﬃcient to use
the class. A description of each class, its functions etc. is supplied with the OpenFOAM
distribution in HTML documentation generated with Doxygen at $WM PROJECT DIR/-
doc/Doxygen/html/index.html.
3.2 Compiling applications and libraries
Compilation is an integral part of application development that requires careful man-
agement since every piece of code requires its own set instructions to access dependent
components of the OpenFOAM library. In UNIX/Linux systems these instructions are of-
ten organised and delivered to the compiler using the standard UNIXmake utility. Open-
FOAM, however, is supplied with the wmake compilation script that is based on make
but is considerably more versatile and easier to use; wmake can, in fact, be used on any
code, not simply the OpenFOAM library. To understand the compilation process, we
ﬁrst need to explain certain aspects of C++ and its ﬁle structure, shown schematically
in Figure 3.1. A class is deﬁned through a set of instructions such as object construction,
data storage and class member functions. The ﬁle containing the class deﬁnition takes
a .C extension, e.g. a class nc would be written in the ﬁle nc.C. This ﬁle can be com-
piled independently of other code into a binary executable library ﬁle known as a shared
object library with the .so ﬁle extension, i.e.nc.so. When compiling a piece of code, say
newApp.C, that uses the nc class, nc.C need not be recompiled, rather newApp.C calls
nc.so at runtime. This is known as dynamic linking.
3.2.1 Header .H ﬁles
As a means of checking errors, the piece of code being compiled must know that the classes
it uses and the operations they perform actually exist. Therefore each class requires a
class declaration, contained in a header ﬁle with a .H ﬁle extension, e.g.nc.H, that includes
the names of the class and its functions. This ﬁle is included at the beginning of any piece
of code using the class, including the class declaration code itself. Any piece of .C code
can resource any number of classes and must begin with all the .H ﬁles required to declare
these classes. The classes in turn can resource other classes and begin with the relevant
.H ﬁles. By searching recursively down the class hierarchy we can produce a complete list
Open∇FOAM-1.6
U-72 Applications and libraries
int main()
...
...
return(0);
{
}
nc.so
Library
option-I#include "nc.H"
Main code
Code...
Compiled
nc.H
nc.C
#include "nc.H"
nc class
Definition...
Compiled
Executable
Header ﬁle
Linked
option-l
newApp.C
newApp
Figure 3.1: Header ﬁles, source ﬁles, compilation and linking.
of header ﬁles for all the classes on which the top level .C code ultimately depends; these
.H ﬁles are known as the dependencies. With a dependency list, a compiler can check
whether the source ﬁles have been updated since their last compilation and selectively
compile only those that need to be.
Header ﬁles are included in the code using # include statements, e.g.
# include "otherHeader.H";
causes the compiler to suspend reading from the current ﬁle to read the ﬁle speciﬁed.
Any self-contained piece of code can be put into a header ﬁle and included at the rel-
evant location in the main code in order to improve code readability. For example, in
most OpenFOAM applications the code for creating ﬁelds and reading ﬁeld input data is
included in a ﬁle createFields.H which is called at the beginning of the code. In this way,
header ﬁles are not solely used as class declarations. It is wmake that performs the task
of maintaining ﬁle dependency lists amongst other functions listed below.
• Automatic generation and maintenance of ﬁle dependency lists, i.e. lists of ﬁles
which are included in the source ﬁles and hence on which they depend.
• Multi-platform compilation and linkage, handled through appropriate directory
structure.
• Multi-language compilation and linkage, e.g. C, C++, Java.
• Multi-option compilation and linkage, e.g. debug, optimised, parallel and proﬁling.
• Support for source code generation programs, e.g. lex, yacc, IDL, MOC.
• Simple syntax for source ﬁle lists.
• Automatic creation of source ﬁle lists for new codes.
• Simple handling of multiple shared or static libraries.
• Extensible to new machine types.
Open∇FOAM-1.6
3.2 Compiling applications and libraries U-73
• Extremely portable, works on any machine with: make; sh, ksh or csh; lex, cc.
• Has been tested on Apollo, SUN, SGI, HP (HPUX), Compaq (DEC), IBM (AIX),
Cray, Ardent, Stardent, PC Linux, PPC Linux, NEC, SX4, Fujitsu VP1000.
3.2.2 Compiling with wmake
OpenFOAM applications are organised using a standard convention that the source code
of each application is placed in a directory whose name is that of the application. The
top level source ﬁle takes the application name with the .C extension. For example, the
source code for an application called newApp would reside is a directory newApp and the
top level ﬁle would be newApp.C as shown in Figure 3.2. The directory must also contain
newApp
newApp.C
otherHeader.H
Make
ﬁles
options
Figure 3.2: Directory structure for an application
a Make subdirectory containing 2 ﬁles, options and ﬁles, that are described in the following
sections.
3.2.2.1 Including headers
The compiler searches for the included header ﬁles in the following order, speciﬁed with
the -I option in wmake:
1. the $WM PROJECT DIR/src/OpenFOAM/lnInclude directory;
2. a local lnInclude directory, i.e.newApp/lnInclude;
3. the local directory, i.e.newApp;
4. platform dependent paths set in ﬁles in the $WM PROJECT DIR/wmake/rules/-
$WM ARCH/ directory, e.g./usr/X11/include and $(MPICH ARCH PATH)/include;
5. other directories speciﬁed explicitly in the Make/options ﬁle with the -I option.
The Make/options ﬁle contains the full directory paths to locate header ﬁles using the
syntax:
EXE INC = \
-I<directoryPath1> \
-I<directoryPath2> \
... \
-I<directoryPathN>
Notice ﬁrst that the directory names are preceeded by the -I ﬂag and that the syntax
uses the \ to continue the EXE INC across several lines, with no \ after the ﬁnal entry.
Open∇FOAM-1.6
U-74 Applications and libraries
3.2.2.2 Linking to libraries
The compiler links to shared object library ﬁles in the following directory paths, speciﬁed
with the -L option in wmake:
1. the $FOAM LIBBIN directory;
2. platform dependent paths set in ﬁles in the $WM DIR/rules/$WM ARCH/ directory,
e.g./usr/X11/lib and $(MPICH ARCH PATH)/lib;
3. other directories speciﬁed in the Make/options ﬁle.
The actual library ﬁles to be linked must be speciﬁed using the -l option and removing
the lib preﬁx and .so extension from the library ﬁle name, e.g.libnew.so is included with
the ﬂag -lnew. By default, wmake loads the following libraries:
1. the libOpenFOAM.so library from the $FOAM LIBBIN directory;
2. platform dependent libraries speciﬁed in set in ﬁles in the $WM DIR/rules/$WM ARCH/
directory, e.g.libm.so from /usr/X11/lib and liblam.so from $(LAM ARCH PATH)/lib;
3. other libraries speciﬁed in the Make/options ﬁle.
The Make/options ﬁle contains the full directory paths and library names using the syntax:
EXE LIBS = \
-L<libraryPath1> \
-L<libraryPath2> \
... \
-L<libraryPathN> \
-l<library1> \
-l<library2> \
... \
-l<libraryN>
Let us reiterate that the directory paths are preceeded by the -L ﬂag, the library names
are preceeded by the -l ﬂag.
3.2.2.3 Source ﬁles to be compiled
The compiler requires a list of .C source ﬁles that must be compiled. The list must contain
the main .C ﬁle but also any other source ﬁles that are created for the speciﬁc application
but are not included in a class library. For example, users may create a new class or
some new functionality to an existing class for a particular application. The full list of
.C source ﬁles must be included in the Make/ﬁles ﬁle. As might be expected, for many
applications the list only includes the name of the main .C ﬁle, e.g.newApp.C in the case
of our earlier example.
The Make/ﬁles ﬁle also includes a full path and name of the compiled executable,
speciﬁed by the EXE = syntax. Standard convention stipulates the name is that of the ap-
plication, i.e.newApp in our example. The OpenFOAM release oﬀers two useful choices for
path: standard release applications are stored in $FOAM APPBIN; applications developed
by the user are stored in $FOAM USER APPBIN.
If the user is developing their own applications, we recommend they create an appli-
cations subdirectory in their $WM PROJECT USER DIR directory containing the source
Open∇FOAM-1.6
3.2 Compiling applications and libraries U-75
code for personal OpenFOAM applications. As with standard applications, the source
code for each OpenFOAM application should be stored within its own directory. The
only diﬀerence between a user application and one from the standard release is that the
Make/ﬁles ﬁle should specify that the user’s executables are written into their $FOAM -
USER APPBIN directory. The Make/ﬁles ﬁle for our example would appear as follows:
newApp.C
EXE = $(FOAM_USER_APPBIN)/newApp
3.2.2.4 Running wmake
The wmake script is executed by typing:
wmake <optionalArguments> <optionalDirectory>
The <optionalDirectory> is the directory path of the application that is being com-
piled. Typically, wmake is executed from within the directory of the application being
compiled, in which case <optionalDirectory> can be omitted.
If a user wishes to build an application executable, then no <optionalArguments>
are required. However <optionalArguments> may be speciﬁed for building libraries etc.
as described in Table 3.1.
Argument Type of compilation
lib Build a statically-linked library
libso Build a dynamically-linked library
libo Build a statically-linked object ﬁle library
jar Build a JAVA archive
exe Build an application independent of the speciﬁed project
Table 3.1: Optional compilation arguments to wmake.
3.2.2.5 wmake environment variables
For information, the environment variable settings used by wmake are listed in Table 3.2.
3.2.3 Removing dependency lists: wclean and rmdepall
On execution, wmake builds a dependency list ﬁle with a .dep ﬁle extension, e.g.newApp.dep
in our example, and a list of ﬁles in a Make/$WM OPTIONS directory. If the user wishes
to remove these ﬁles, perhaps after making code changes, the user can run the wclean
script by typing:
wclean <optionalArguments> <optionalDirectory>
Again, the <optionalDirectory> is a path to the directory of the application that is
being compiled. Typically, wclean is executed from within the directory of the application,
in which case the path can be omitted.
Open∇FOAM-1.6
U-76 Applications and libraries
Main paths
$WM PROJECT INST DIR Full path to installation directory,
e.g.$HOME/OpenFOAM
$WM PROJECT Name of the project being compiled: OpenFOAM
$WM PROJECT VERSION Version of the project being compiled: 1.6
$WM PROJECT DIR Full path to locate binary executables of OpenFOAM
release, e.g.$HOME/OpenFOAM/OpenFOAM-1.6
$WM PROJECT USER DIR Full path to locate binary executables of the user
e.g.$HOME/OpenFOAM/${USER}-1.6
Other paths/settings
$WM ARCH Machine architecture: cray decAlpha dec ibm linux
linuxPPC sgi3 sgi32 sgi64 sgiN32 solaris sx4 t3d
$WM COMPILER Compiler being used: Gcc3 - gcc 4.3.3, KAI - KAI
$WM COMPILER DIR Compiler installation directory
$WM COMPILER BIN Compiler installation binaries $WM COMPILER BIN/bin
$WM COMPILER LIB Compiler installation libraries $WM COMPILER BIN/lib
$WM COMPILE OPTION Compilation option: Debug - debugging, Opt optimisa-
tion.
$WM DIR Full path of the wmake directory
$WM JAVAC OPTION Compilation option for JAVA: Debug - debugging, Opt
optimisation.
$WM LINK LANGUAGE Compiler used to link libraries and executables. In multi-
language projects a $WM LINK LANGUAGE is set to the
primary language.
$WM MPLIB Parallel communications library: LAM, MPI, MPICH, PVM
$WM OPTIONS = $WM ARCH$WM COMPILER...
...$WM COMPILE OPTION$WM MPLIB
e.g.linuxGcc3OptMPICH
$WM PROJECT LANGUAGE Programming language of project, e.g.c++
$WM SHELL Shell used for the wmake scripts bash, csh, ksh, tcsh
Table 3.2: Environment variable settings for wmake.
If a user wishes to remove the dependency ﬁles and ﬁles from the Make directory, then
no <optionalArguments> are required. However if lib is speciﬁed in <optionalArguments>
a local lnInclude directory will be deleted also.
An additional script, rmdepall removes all dependency .dep ﬁles recursively down the
directory tree from the point at which it is executed. This can be useful when updating
OpenFOAM libraries.
3.2.4 Compilation example: the pisoFoam application
The source code for application pisoFoam is in the $FOAM APP/solvers/incompressible/pisoFoam
directory and the top level source ﬁle is named pisoFoam.C. The pisoFoam.C source code
is:
1 /*---------------------------------------------------------------------------*\
2 ========= |
3 \\ / F ield | OpenFOAM: The Open Source CFD Toolbox
4 \\ / O peration |
Open∇FOAM-1.6
3.2 Compiling applications and libraries U-77
5 \\ / A nd | Copyright (C) 1991-2009 OpenCFD Ltd.
6 \\/ M anipulation |
7 -------------------------------------------------------------------------------
8 License
9 This file is part of OpenFOAM.
10
11 OpenFOAM is free software; you can redistribute it and/or modify it
12 under the terms of the GNU General Public License as published by the
13 Free Software Foundation; either version 2 of the License, or (at your
14 option) any later version.
15
16 OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
17 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
18 FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
19 for more details.
20
21 You should have received a copy of the GNU General Public License
22 along with OpenFOAM; if not, write to the Free Software Foundation,
23 Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
24
25 Application
26 pisoFoam
27
28 Description
29 Transient solver for incompressible flow.
30
31 Turbulence modelling is generic, i.e. laminar, RAS or LES may be selected.
32
33 \*---------------------------------------------------------------------------*/
34
35 #include "fvCFD.H"
36 #include "singlePhaseTransportModel.H"
37 #include "turbulenceModel.H"
38
39 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
40
41 int main(int argc, char *argv[])
42 {
43 #include "setRootCase.H"
44
45 #include "createTime.H"
46 #include "createMesh.H"
47 #include "createFields.H"
48 #include "initContinuityErrs.H"
49
50 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
51
52 Info<< "\nStarting time loop\n" << endl;
53
54 while (runTime.loop())
55 {
56 Info<< "Time = " << runTime.timeName() << nl << endl;
57
58 #include "readPISOControls.H"
59 #include "CourantNo.H"
60
61 // Pressure-velocity PISO corrector
62 {
63 // Momentum predictor
64
65 fvVectorMatrix UEqn
66 (
67 fvm::ddt(U)
68 + fvm::div(phi, U)
69 + turbulence->divDevReff(U)
70 );
71
72 UEqn.relax();
73
74 if (momentumPredictor)
75 {
76 solve(UEqn == -fvc::grad(p));
77 }
78
79 // --- PISO loop
80
81 for (int corr=0; corr<nCorr; corr++)
82 {
83 volScalarField rUA = 1.0/UEqn.A();
84
85 U = rUA*UEqn.H();
86 phi = (fvc::interpolate(U) & mesh.Sf())
87 + fvc::ddtPhiCorr(rUA, U, phi);
88
Open∇FOAM-1.6
U-78 Applications and libraries
89 adjustPhi(phi, U, p);
90
91 // Non-orthogonal pressure corrector loop
92 for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
93 {
94 // Pressure corrector
95
96 fvScalarMatrix pEqn
97 (
98 fvm::laplacian(rUA, p) == fvc::div(phi)
99 );
100
101 pEqn.setReference(pRefCell, pRefValue);
102
103 if
104 (
105 corr == nCorr-1
106 && nonOrth == nNonOrthCorr
107 )
108 {
109 pEqn.solve(mesh.solver("pFinal"));
110 }
111 else
112 {
113 pEqn.solve();
114 }
115
116 if (nonOrth == nNonOrthCorr)
117 {
118 phi -= pEqn.flux();
119 }
120 }
121
122 #include "continuityErrs.H"
123
124 U -= rUA*fvc::grad(p);
125 U.correctBoundaryConditions();
126 }
127 }
128
129 turbulence->correct();
130
131 runTime.write();
132
133 Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
134 << " ClockTime = " << runTime.elapsedClockTime() << " s"
135 << nl << endl;
136 }
137
138 Info<< "End\n" << endl;
139
140 return 0;
141 }
142
143
144 // ************************************************************************* //
The code begins with a brief description of the application contained within comments
over 1 line (//) and multiple lines (/*...*/). Following that, the code contains several
# include statements, e.g.# include "fvCFD.H", which causes the compiler to suspend
reading from the current ﬁle, pisoFoam.C to read the fvCFD.H.
pisoFoam resources the cfdTools, incompressibleRASModels and incompressibleTransport-
Models libraries and therefore requires the necessary header ﬁles, speciﬁed by the EXE INC
= -I... option, and links to the libraries with the EXE LIBS = -l... option. The
Make/options therefore contains the following:
1 EXE_INC = \
2 -I$(LIB_SRC)/turbulenceModels/incompressible/turbulenceModel \
3 -I$(LIB_SRC)/transportModels \
4 -I$(LIB_SRC)/transportModels/incompressible/singlePhaseTransportModel \
5 -I$(LIB_SRC)/finiteVolume/lnInclude
6
7 EXE_LIBS = \
8 -lincompressibleRASModels \
9 -lincompressibleLESModels \
10 -lincompressibleTransportModels \
11 -lfiniteVolume \
12 -lmeshTools
Open∇FOAM-1.6
3.2 Compiling applications and libraries U-79
pisoFoam contains only the pisoFoam.C source and the executable is written to the $FOAM APPBIN
directory as all standard applications are. The Make/ﬁles therefore contains:
1 pisoFoam.C
2
3 EXE = $(FOAM_APPBIN)/pisoFoam
The user can compile pisoFoam by going to the $FOAM CFD/pisoFoam directory and
typing:
wmake
The code should compile and produce a message similar to the following
Making dependency list for source file pisoFoam.C
SOURCE DIR=.
SOURCE=pisoFoam.C ;
g++ -DFOAM EXCEPTION -Dlinux -DlinuxOptMPICH
-DscalarMachine -DoptSolvers -DPARALLEL -DUSEMPI -Wall -O2 -DNoRepository
-ftemplate-depth-17 -I.../OpenFOAM/OpenFOAM-1.6/src/OpenFOAM/lnInclude
-IlnInclude
-I.
......
-lmpich -L/usr/X11/lib -lm
-o .../OpenFOAM/OpenFOAM-1.6/applications/bin/linuxOptMPICH/pisoFoam
The user can now try recompiling and will receive a message similar to the following to
say that the executable is up to date and compiling is not necessary:
make: Nothing to be done for ‘allFiles’.
make: ‘Make/linuxOptMPICH/dependencies’ is up to date.
make: ‘.../OpenFOAM/OpenFOAM-1.6/applications/bin/linuxOptMPICH/pisoFoam’
is up to date.
The user can compile the application from scratch by removing the dependency list with
wclean
and running wmake.
3.2.5 Debug messaging and optimisation switches
OpenFOAM provides a system of messaging that is written during runtime, most of which
are to help debugging problems encountered during running of a OpenFOAM case. The
switches are listed in the $WM PROJECT DIR/etc/controlDict ﬁle; should the user wish
to change the settings they should make a copy to their $HOME directory, i.e.$HOME/-
.OpenFOAM/1.6/controlDict ﬁle. The list of possible switches is extensive and can be
viewed by running the foamDebugSwitches application. Most of the switches correspond
to a class or range of functionality and can be switched on by their inclusion in the
controlDict ﬁle, and by being set to 1. For example, OpenFOAM can perform the checking
of dimensional units in all calculations by setting the dimensionSet switch to 1. There
are some switches that control messaging at a higher level than most, listed in Table 3.3.
In addition, there are some switches that control certain operational and optimisa-
tion issues. These switches are also listed in Table 3.3. Of particular importance is
Open∇FOAM-1.6
U-80 Applications and libraries
fileModificationSkew. OpenFOAM scans the write time of data ﬁles to check for mod-
iﬁcation. When running over a NFS with some disparity in the clock settings on diﬀerent
machines, ﬁeld data ﬁles appear to be modiﬁed ahead of time. This can cause a problem
if OpenFOAM views the ﬁles as newly modiﬁed and attempting to re-read this data. The
fileModificationSkew keyword is the time in seconds that OpenFOAM will subtract
from the ﬁle write time when assessing whether the ﬁle has been newly modiﬁed.
High level debugging switches - sub-dictionary DebugSwitches
level Overall level of debugging messaging for OpenFOAM- - 3 levels 0,
1, 2
lduMatrix Messaging for solver convergence during a run - 3 levels 0, 1, 2
Optimisation switches - sub-dictionary OptimisationSwitches
fileModific-
ationSkew
A time in seconds that should be set higher than the maximum
delay in NFS updates and clock diﬀerence for running OpenFOAM
over a NFS.
nProcsSimpleSum Optimises global sum for parallel processing; sets number of pro-
cessors above which hierarchical sum is performed rather than a
linear sum (default 16)
Table 3.3: Runtime message switches.
3.2.6 Linking new user-deﬁned libraries to existing applications
The situation may arise that a user creates a new library, say new, and wishes the features
within that library to be available across a range of applications. For example, the
user may create a new boundary condition, compiled into new, that would need to be
recognised by a range of solver applications, pre- and post-processing utilities, mesh tools,
etc. Under normal circumstances, the user would need to recompile every application with
the new linked to it.
Instead there is a simple mechanism to link one or more shared object libraries dy-
namically at run-time in OpenFOAM. Simply add the optional keyword entry libs to
the controlDict ﬁle for a case and enter the full names of the libraries within a list (as
quoted string entries). For example, if a user wished to link the libraries new1 and new2
at run-time, they would simply need to add the following to the case controlDict ﬁle:
libs
(
"libnew1.so"
"libnew2.so"
);
3.3 Running applications
Each application is designed to be executed from a terminal command line, typically
reading and writing a set of data ﬁles associated with a particular case. The data ﬁles
for a case are stored in a directory named after the case as described in section 4.1; the
directory name with full path is here given the generic name <caseDir>.
Open∇FOAM-1.6
3.4 Running applications in parallel U-81
For any application, the form of the command line entry for any can be found by
simply entering the application name at the command line with the -help option, e.g.
typing
blockMesh -help
returns the usage
Usage: blockMesh [-region region name] [-case dir] [-blockTopology]
[-help] [-doc] [-srcDoc]
The arguments in square brackets, [ ], are optional ﬂags. If the application is exe-
cuted from within a case directory, it will operate on that case. Alternatively, the -case
<caseDir> option allows the case to be speciﬁed directly so that the application can be
executed from anywhere in the ﬁling system.
Like any UNIX/Linux executable, applications can be run as as a background process,
i.e. one which does not have to be completed before the user can give the shell additional
commands. If the user wished to run the blockMesh example as a background process
and output the case progress to a log ﬁle, they could enter:
blockMesh > log &
3.4 Running applications in parallel
This section describes how to run OpenFOAM in parallel on distributed processors. The
method of parallel computing used by OpenFOAM is known as domain decomposition, in
which the geometry and associated ﬁelds are broken into pieces and allocated to separate
processors for solution. The process of parallel computation involves: decomposition of
mesh and ﬁelds; running the application in parallel; and, post-processing the decomposed
case as described in the following sections. The parallel running uses the public domain
openMPI implementation of the standard message passing interface (MPI).
3.4.1 Decomposition of mesh and initial ﬁeld data
The mesh and ﬁelds are decomposed using the decomposePar utility. The underlying
aim is to break up the domain with minimal eﬀort but in such a way to guarantee a
fairly economic solution. The geometry and ﬁelds are broken up according to a set of
parameters speciﬁed in a dictionary named decomposeParDict that must be located in
the system directory of the case of interest. An example decomposeParDict dictionary can
be copied from the interFoam/damBreak tutorial if the user requires one; the dictionary
entries within it are reproduced below:
17
18 numberOfSubdomains 4;
19
20 method simple;
21
22 simpleCoeffs
23 {
24 n ( 2 2 1 );
25 delta 0.001;
26 }
27
28 hierarchicalCoeffs
29 {
30 n ( 1 1 1 );
Open∇FOAM-1.6
U-82 Applications and libraries
31 delta 0.001;
32 order xyz;
33 }
34
35 metisCoeffs
36 {
37 processorWeights ( 1 1 1 1 );
38 }
39
40 manualCoeffs
41 {
42 dataFile "";
43 }
44
45 distributed no;
46
47 roots ( );
48
49
50 // ************************************************************************* //
The user has a choice of four methods of decomposition, speciﬁed by the method keyword
as described below.
simple Simple geometric decomposition in which the domain is split into pieces by di-
rection, e.g. 2 pieces in the x direction, 1 in y etc.
hierarchical Hierarchical geometric decomposition which is the same as simple except
the user speciﬁes the order in which the directional split is done, e.g. ﬁrst in the
y-direction, then the x-direction etc.
scotch Scotch decomposition which requires no geometric input from the user and at-
tempts to minimise the number of processor boundaries. The user can specify a
weighting for the decomposition between processors, through an optional process-
orWeights keyword which can be useful on machines with diﬀering performance
between processors. There is also an optional keyword entry strategy that con-
trols the decomposition strategy through a complex string supplied to Scotch. For
more information, see the source code ﬁle: $FOAM SRC/decompositionMethods/-
decompositionMethods/scotchDecomp/scotchDecomp.C
metis METIS decomposition is similar to Scotch, but the library is non-free for commer-
cial use, so will be discontinued in favour of Scotch in future releases of OpenFOAM.
manual Manual decomposition, where the user directly speciﬁes the allocation of each
cell to a particular processor.
For each method there are a set of coeﬃcients speciﬁed in a sub-dictionary of decom-
positionDict, named <method>Coeﬀs as shown in the dictionary listing. The full set of
keyword entries in the decomposeParDict dictionary are explained in Table 3.4.
The decomposePar utility is executed in the normal manner by typing
decomposePar
On completion, a set of subdirectories will have been created, one for each processor, in
the case directory. The directories are named processorN where N = 0, 1, . . . represents a
processor number and contains a time directory, containing the decomposed ﬁeld descrip-
tions, and a constant/polyMesh directory containing the decomposed mesh description.
Open∇FOAM-1.6
3.4 Running applications in parallel U-83
Compulsory entries
numberOfSubdomains Total number of subdomains N
method Method of decomposition simple/
hierarchical/
scotch/ metis/
manual/
simpleCoeffs entries
n Number of subdomains in x, y, z (nx ny nz)
delta Cell skew factor Typically, 10−3
hierarchicalCoeffs entries
n Number of subdomains in x, y, z (nx ny nz)
delta Cell skew factor Typically, 10−3
order Order of decomposition xyz/xzy/yxz. . .
scotchCoeffs entries
processorWeights List of weighting factors for allocation
of cells to processors; <wt1> is the
weighting factor for processor 1, etc.;
weights are normalised so can take any
range of values.
(<wt1>...<wtN>)
strategy Decomposition strategy; defaults to
"b"
metisCoeffs entries
processorWeights As above (<wt1>...<wtN>)
manualCoeffs entries
dataFile Name of ﬁle containing data of alloca-
tion of cells to processors
"<fileName>"
Distributed data entries (optional) — see section 3.4.3
distributed Is the data distributed across several
disks?
yes/no
roots Root paths to case directories; <rt1>
is the root path for node 1, etc.
(<rt1>...<rtN>)
Table 3.4: Keywords in decompositionDict dictionary.
3.4.2 Running a decomposed case
A decomposed OpenFOAM case is run in parallel using the openMPI implementation of
MPI.
openMPI can be run on a local multiprocessor machine very simply but when run-
ning on machines across a network, a ﬁle must be created that contains the host names
of the machines. The ﬁle can be given any name and located at any path. In the fol-
lowing description we shall refer to such a ﬁle by the generic name, including full path,
<machines>.
The <machines> ﬁle contains the names of the machines listed one machine per line.
Open∇FOAM-1.6
U-84 Applications and libraries
The names must correspond to a fully resolved hostname in the /etc/hosts ﬁle of the
machine on which the openMPI is run. The list must contain the name of the machine
running the openMPI. Where a machine node contains more than one processor, the node
name may be followed by the entry cpu=n where n is the number of processors openMPI
should run on that node.
For example, let us imagine a user wishes to run openMPI from machine aaa on the
following machines: aaa; bbb, which has 2 processors; and ccc. The <machines> would
contain:
aaa
bbb cpu=2
ccc
An application is run in parallel using mpirun.
mpirun --hostfile <machines> -np <nProcs>
<foamExec> <otherArgs> -parallel > log &
where: <nProcs> is the number of processors; <foamExec> is the executable, e.g.icoFoam;
and, the output is redirected to a ﬁle named log. For example, if icoFoam is run on 4
nodes, speciﬁed in a ﬁle named machines, on the cavity tutorial in the $FOAM RUN/-
tutorials/incompressible/icoFoam directory, then the following command should be exe-
cuted:
mpirun --hostfile machines -np 4 icoFoam -parallel > log &
3.4.3 Distributing data across several disks
Data ﬁles may need to be distributed if, for example, if only local disks are used in
order to improve performance. In this case, the user may ﬁnd that the root path to the
case directory may diﬀer between machines. The paths must then be speciﬁed in the
decomposeParDict dictionary using distributed and roots keywords. The distributed
entry should read
distributed yes;
and the roots entry is a list of root paths, <root0>, <root1>, . . . , for each node
roots
<nRoots>
(
"<root0>"
"<root1>"
...
);
where <nRoots> is the number of roots.
Each of the processorN directories should be placed in the case directory at each of
the root paths speciﬁed in the decomposeParDict dictionary. The system directory and
ﬁles within the constant directory must also be present in each case directory. Note: the
ﬁles in the constant directory are needed, but the polyMesh directory is not.
Open∇FOAM-1.6
3.5 Standard solvers U-85
3.4.4 Post-processing parallel processed cases
When post-processing cases that have been run in parallel the user has two options:
• reconstruction of the mesh and ﬁeld data to recreate the complete domain and ﬁelds,
which can be post-processed as normal;
• post-processing each segment of decomposed domain individually.
3.4.4.1 Reconstructing mesh and data
After a case has been run in parallel, it can be reconstructed for post-processing. The case
is reconstructed by merging the sets of time directories from each processorN directory into
a single set of time directories. The reconstructPar utility performs such a reconstruction
by executing the command:
reconstructPar
When the data is distributed across several disks, it must be ﬁrst copied to the local case
directory for reconstruction.
3.4.4.2 Post-processing decomposed cases
The user may post-process decomposed cases using the paraFoam post-processor, de-
scribed in section 6.1. The whole simulation can be post-processed by reconstructing the
case or alternatively it is possible to post-process a segment of the decomposed domain
individually by simply treating the individual processor directory as a case in its own
right.
3.5 Standard solvers
The solvers with the OpenFOAM distribution are in the $FOAM SOLVERS directory,
reached quickly by typing app at the command line. This directory is further subdivided
into several directories by category of continuum mechanics, e.g. incompressible ﬂow,
combustion and solid body stress analysis. Each solver is given a name that is reasonably
descriptive, e.g.icoFoam solves incompressible, laminar ﬂow. The current list of solvers
distributed with OpenFOAM is given in Table 3.5.
‘Basic’ CFD codes
laplacianFoam Solves a simple Laplace equation, e.g. for thermal diﬀusion
in a solid
potentialFoam Simple potential ﬂow solver which can be used to generate
starting ﬁelds for full Navier-Stokes codes
scalarTransportFoam Solves a transport equation for a passive scalar
Incompressible ﬂow
boundaryFoam Steady-state solver for 1D turbulent ﬂow, typically to generate
boundary layer conditions at an inlet, for use in a simulation
channelFoam Incompressible LES solver for ﬂow in a channel
icoFoam Transient solver for incompressible, laminar ﬂow of Newtonian
ﬂuids
Continued on next page
Open∇FOAM-1.6
U-86 Applications and libraries
Continued from previous page
nonNewtonianIcoFoam Transient solver for incompressible, laminar ﬂow of non-
Newtonian ﬂuids
pimpleDyMFoam Transient solver for incompressible, ﬂow of Newtonian ﬂu-
ids on a moving mesh using the PIMPLE (merged PISO-
SIMPLE) algorithm
pimpleFoam Large time-step transient solver for incompressible, ﬂow using
the PIMPLE (merged PISO-SIMPLE) algorithm
pisoFoam Transient solver for incompressible ﬂow
shallowWaterFoam Transient solver for inviscid shallow-water equations with ro-
tation
simpleFoam Steady-state solver for incompressible, turbulent ﬂow
Compressible ﬂow
rhoCentralFoam Density-based compressible ﬂow solver based on central-
upwind schemes of Kurganov and Tadmor
rhoPimpleFoam Transient solver for laminar or turbulent ﬂow of compressible
ﬂuids for HVAC and similar applications
rhoPisoFoam Transient PISO solver for compressible, laminar or turbulent
ﬂow
rhoPorousSimpleFoam Steady-state solver for turbulent ﬂow of compressible ﬂuids
with RANS turbulence modelling, and implicit or explicit
porosity treatment
rhopSonicFoam Pressure-density-based compressible ﬂow solver
rhoSimpleFoam Steady-state SIMPLE solver for laminar or turbulent RANS
ﬂow of compressible ﬂuids
rhoSonicFoam Density-based compressible ﬂow solver
sonicDyMFoam Transient solver for trans-sonic/supersonic, laminar or turbu-
lent ﬂow of a compressible gas with mesh motion
sonicFoam Transient solver for trans-sonic/supersonic, laminar or turbu-
lent ﬂow of a compressible gas
sonicLiquidFoam Transient solver for trans-sonic/supersonic, laminar ﬂow of a
compressible liquid
Multiphase ﬂow
bubbleFoam Solver for a system of 2 incompressible ﬂuid phases with one
phase dispersed, e.g. gas bubbles in a liquid
cavitatingFoam Transient cavitation code based on the barotropic equation of
state
compressibleInterDyM-
Foam
Solver for 2 compressible, isothermal immiscible ﬂuids using a
VOF (volume of ﬂuid) phase-fraction based interface captur-
ing approach, with optional mesh motion and mesh topology
changes including adaptive re-meshing
compressibleInterFoam Solver for 2 compressible, isothermal immiscible ﬂuids using
a VOF (volume of ﬂuid) phase-fraction based interface cap-
turing approach
interDyMFoam Solver for 2 incompressible, isothermal immiscible ﬂuids using
a VOF (volume of ﬂuid) phase-fraction based interface captur-
ing approach, with optional mesh motion and mesh topology
changes including adaptive re-meshing
Continued on next page
Open∇FOAM-1.6
3.5 Standard solvers U-87
Continued from previous page
interFoam Solver for 2 incompressible, isothermal immiscible ﬂuids us-
ing a VOF (volume of ﬂuid) phase-fraction based interface
capturing approach
interPhaseChangeFoam Solver for 2 incompressible, isothermal immiscible ﬂuids with
phase-change (e.g. cavitation). Uses a VOF (volume of ﬂuid)
phase-fraction based interface capturing approach
multiphaseInterFoam Solver for n incompressible ﬂuids which captures the interfaces
and includes surface-tension and contact-angle eﬀects for each
phase
settlingFoam Solver for 2 incompressible ﬂuids for simulating the settling
of the dispersed phase
twoLiquidMixingFoam Solver for mixing 2 incompressible ﬂuids
twoPhaseEulerFoam Solver for a system of 2 incompressible ﬂuid phases with one
phase dispersed, e.g. gas bubbles in a liquid
Direct numerical simulation (DNS)
dnsFoam Direct numerical simulation solver for boxes of isotropic tur-
bulence
Combustion
coldEngineFoam Solver for cold-ﬂow in internal combustion engines
dieselEngineFoam Solver for diesel engine spray and combustion
dieselFoam Solver for diesel spray and combustion
engineFoam Solver for internal combustion engines
PDRFoam Solver for compressible premixed/partially-premixed combus-
tion with turbulence modelling
reactingFoam Solver for combustion with chemical reactions
rhoReactingFoam Solver for combustion with chemical reactions using density
based thermodynamics package
XiFoam Solver for compressible premixed/partially-premixed combus-
tion with turbulence modelling
Heat transfer and buoyancy-driven ﬂows
buoyantBoussinesqPi-
soFoam
Transient solver for buoyant, turbulent ﬂow of incompressible
ﬂuids
buoyantBoussinesqSim-
pleFoam
Steady-state solver for buoyant, turbulent ﬂow of incompress-
ible ﬂuids
buoyantPisoFoam Transient solver for buoyant, turbulent ﬂow of compressible
ﬂuids for ventilation and heat-transfer
buoyantSimpleFoam Steady-state solver for buoyant, turbulent ﬂow of compressible
ﬂuids
buoyantSimpleRadiation-
Foam
Steady-state solver for buoyant, turbulent ﬂow of compressible
ﬂuids, including radiation, for ventilation and heat-transfer
chtMultiRegionFoam Combination of heatConductionFoam and buoyantFoam for
conjugate heat transfer between a solid region and ﬂuid re-
gion
Particle-tracking ﬂows
Continued on next page
Open∇FOAM-1.6
U-88 Applications and libraries
Continued from previous page
coalChemistryFoam Transient solver for compressible, turbulent ﬂow with coal and
limestone parcel injections, and combustion
porousExplicitSource-
ReactingParcelFoam
Transient PISO solver for compressible, laminar or turbulent
ﬂow with reacting Lagrangian parcels for porous media, in-
cluding explicit sources
reactingParcelFoam Transient PISO solver for compressible, laminar or turbulent
ﬂow with reacting Lagrangian parcels
uncoupledKinematic-
ParcelFoam
Transient solver for the passive transport of a single kinematic
particle could
Molecular dynamics methods
mdEquilibrationFoam Equilibrates and/or preconditions molecular dynamics sys-
tems
mdFoam Molecular dynamics solver for ﬂuid dynamics
Direct simulation Monte Carlo methods
dsmcFoam Direct simulation Monte Carlo (DSMC) solver for 3D, tran-
sient, multi- species ﬂows
Electromagnetics
electrostaticFoam Solver for electrostatics
mhdFoam Solver for magnetohydrodynamics (MHD): incompressible,
laminar ﬂow of a conducting ﬂuid under the inﬂuence of a
magnetic ﬁeld
Stress analysis of solids
solidDisplacement-
Foam
Transient segregated ﬁnite-volume solver of linear-elastic,
small-strain deformation of a solid body, with optional ther-
mal diﬀusion and thermal stresses
solidEquilibriumDis-
placementFoam
Steady-state segregated ﬁnite-volume solver of linear-elastic,
small-strain deformation of a solid body, with optional ther-
mal diﬀusion and thermal stresses
Finance
ﬁnancialFoam Solves the Black-Scholes equation to price commodities
Table 3.5: Standard library solvers.
3.6 Standard utilities
The utilities with the OpenFOAM distribution are in the $FOAM UTILITIES directory,
reached quickly by typing util at the command line. Again the names are reasonably
descriptive, e.g.ideasToFoam converts mesh data from the format written by I-DEAS to
the OpenFOAM format. The current list of utilities distributed with OpenFOAM is given
in Table 3.6.
Continued on next page
Open∇FOAM-1.6
3.6 Standard utilities U-89
Continued from previous page
Pre-processing
applyBoundaryLayer Apply a simpliﬁed boundary-layer model to the velocity and
turbulence ﬁelds based on the 1/7th power-law
applyWallFunction-
BoundaryConditions
Updates OpenFOAM RAS cases to use the new wall function
framework Attempts to determine whether case is compress-
ible or incompressible, or can be supplied with -compressible
command line argument
boxTurb Makes a box of turbulence which conforms to a given energy
spectrum and is divergence free
changeDictionary Utility to change dictionary entries, e.g. can be used to change
the patch type in the ﬁeld and polyMesh/boundary ﬁles
dsmcInitialise Initialise a case for dsmcFoam by reading the initialisation
dictionary system/dsmcInitialise
engineSwirl Generates a swirling ﬂow for engine calulations
foamUpgradeFvSolution Simple tool to upgrade the syntax of system/fvSolution::solvers
mapFields Maps volume ﬁelds from one mesh to another, reading and
interpolating all ﬁelds present in the time directory of both
cases. Parallel and non-parallel cases are handled without the
need to reconstruct them ﬁrst
mdInitialise Initialises ﬁelds for a molecular dynamics (MD) simulation
setFields Selects a cell set through a dictionary
Mesh generation
blockMesh A multi-block mesh generator
extrude2DMesh Takes 2D mesh (all faces 2 points only, no front and back
faces) and creates a 3D mesh by extruding with speciﬁed
thickness
extrudeMesh Extrude mesh from existing patch (by default outwards facing
normals; optional ﬂips faces) or from patch read from ﬁle
snappyHexMesh Automatic split hex mesher. Reﬁnes and snaps to surface
Mesh conversion
ansysToFoam Converts an ANSYS input mesh ﬁle, exported from I-DEAS,
to OpenFOAM format
cfx4ToFoam Converts a CFX 4 mesh to OpenFOAM format
ﬂuent3DMeshToFoam Converts a Fluent mesh to OpenFOAM format
ﬂuentMeshToFoam Converts a Fluent mesh to OpenFOAM format including mul-
tiple region and region boundary handling
foamMeshToFluent Writes out the OpenFOAM mesh in Fluent mesh format
foamToStarMesh Reads an OpenFOAM mesh and writes a PROSTAR (v4)
bnd/cel/vrt format
gambitToFoam Converts a GAMBIT mesh to OpenFOAM format
gmshToFoam Reads .msh ﬁle as written by Gmsh
ideasUnvToFoam I-Deas unv format mesh conversion
kivaToFoam Converts a KIVA grid to OpenFOAM format
mshToFoam Converts .msh ﬁle generated by the Adventure system
netgenNeutralToFoam Converts neutral ﬁle format as written by Netgen v4.4
plot3dToFoam Plot3d mesh (ascii/formatted format) converter
Continued on next page
Open∇FOAM-1.6
U-90 Applications and libraries
Continued from previous page
polyDualMesh Calculate the dual of a polyMesh. Adheres to all the feature
and patch edges
sammToFoam Converts a STAR-CD SAMM mesh to OpenFOAM format
star4ToFoam Converts a STAR-CD (v4) PROSTAR mesh into OpenFOAM
format
starToFoam Converts a STAR-CD PROSTAR mesh into OpenFOAM for-
mat
tetgenToFoam Converts .ele and .node and .face ﬁles, written by tetgen
writeMeshObj For mesh debugging: writes mesh as three separate OBJ ﬁles
which can be viewed with e.g. javaview
Mesh manipulation
attachMesh Attach topologically detached mesh using prescribed mesh
modiﬁers
autoPatch Divides external faces into patches based on (user supplied)
feature angle
cellSet Selects a cell set through a dictionary
checkMesh Checks validity of a mesh
createBaﬄes Makes internal faces into boundary faces. Does not duplicate
points, unlike mergeOrSplitBaﬄes
createPatch Utility to create patches out of selected boundary faces. Faces
come either from existing patches or from a faceSet
deformedGeom Deforms a polyMesh using a displacement ﬁeld U and a scaling
factor supplied as an argument
faceSet Selects a face set through a dictionary
ﬂattenMesh Flattens the front and back planes of a 2D cartesian mesh
insideCells Picks up cells with cell centre ’inside’ of surface. Requires
surface to be closed and singly connected
mergeMeshes Merge two meshes
mergeOrSplitBaﬄes Detects faces that share points (baﬄes). Either merge them
or duplicate the points
mirrorMesh Mirrors a mesh around a given plane
moveDynamicMesh Mesh motion and topological mesh changes utility
moveEngineMesh Solver for moving meshes for engine calculations.
moveMesh Solver for moving meshes
objToVTK Read obj line (not surface!) ﬁle and convert into vtk
pointSet Selects a point set through a dictionary
reﬁneMesh Utility to reﬁne cells in multiple directions
renumberMesh Renumbers the cell list in order to reduce the bandwidth,
reading and renumbering all ﬁelds from all the time directories
rotateMesh Rotates the mesh and ﬁelds from the direcion n1 to the direc-
tion n2
setSet Manipulate a cell/face/point set interactively
setsToZones Add pointZones/faceZones/cellZones to the mesh from similar
named pointSets/faceSets/cellSets
splitMesh Splits mesh by making internal faces external. Uses attachDe-
tach
splitMeshRegions Splits mesh into multiple regions
stitchMesh ’Stitches’ a mesh
Continued on next page
Open∇FOAM-1.6
3.6 Standard utilities U-91
Continued from previous page
subsetMesh Selects a section of mesh based on a cellSet
transformPoints Transforms the mesh points in the polyMesh directory accord-
ing to the translate, rotate and scale options
zipUpMesh Reads in a mesh with hanging vertices and zips up the cells
to guarantee that all polyhedral cells of valid shape are closed
Other mesh tools
autoReﬁneMesh Utility to reﬁne cells near to a surface
collapseEdges Collapse short edges and combines edges that are in line
combinePatchFaces Checks for multiple patch faces on same cell and combines
them. These result from e.g. reﬁned neighbouring cells get-
ting removed, leaving 4 exposed faces with same owner
modifyMesh Manipulates mesh elements
reﬁneHexMesh Reﬁnes a hex mesh by 2x2x2 cell splitting
reﬁnementLevel Tries to ﬁgure out what the reﬁnement level is on reﬁned
cartesian meshes. Run before snapping
reﬁneWallLayer Utility to reﬁne cells next to patches
removeFaces Utility to remove faces (combines cells on both sides)
selectCells Select cells in relation to surface
splitCells Utility to split cells with ﬂat faces
Post-processing graphics
ensightFoamReader EnSight library module to read OpenFOAM data directly
without translation
ﬁeldview9Reader Reader module for Fieldview 9 to read OpenFOAM mesh and
data
PV3FoamReader ParaView 3 reader module
PVFoamReader ParaView reader module
Post-processing data converters
foamDataToFluent Translates OpenFOAM data to Fluent format
foamToEnsight Translates OpenFOAM data to EnSight format
foamToEnsightParts Translates OpenFOAM data to Ensight format. An Ensight
part is created for each cellZone and patch
foamToFieldview9 Write out the OpenFOAM mesh in Version 3.0 Fieldview-UNS
format (binary)
foamToGMV Translates foam output to GMV readable ﬁles
foamToVTK Legacy VTK ﬁle format writer
smapToFoam Translates a STAR-CD SMAP data ﬁle into OpenFOAM ﬁeld
format
Post-processing velocity ﬁelds
Co Conﬁgurable graph drawing program
enstrophy Calculates and writes the enstrophy of the velocity ﬁeld U
ﬂowType Calculates and writes the ﬂowType of velocity ﬁeld U
Lambda2 Calculates and writes the second largest eigenvalue of the sum
of the square of the symmetrical and anti-symmetrical parts
of the velocity gradient tensor
Continued on next page
Open∇FOAM-1.6
U-92 Applications and libraries
Continued from previous page
Mach Calculates and optionally writes the local Mach number from
the velocity ﬁeld U at each time
Pe Calculates and writes the Pe number as a
surfaceScalarField obtained from ﬁeld phi
Q Calculates and writes the second invariant of the velocity gra-
dient tensor
streamFunction Calculates and writes the stream function of velocity ﬁeld U
at each time
uprime Calculates and writes the scalar ﬁeld of uprime ( 2k/3)
vorticity Calculates and writes the vorticity of velocity ﬁeld U
Post-processing stress ﬁelds
stressComponents Calculates and writes the scalar ﬁelds of the six components
of the stress tensor sigma for each time
Post-processing scalar ﬁelds
pPrime2 Calculates and writes the scalar ﬁeld of pPrime2 ([p − p]2
) at
each time
Post-processing at walls
wallGradU Calculates and writes the gradient of U at the wall
wallHeatFlux Calculates and writes the heat ﬂux for all patches as the
boundary ﬁeld of a volScalarField and also prints the inte-
grated ﬂux for all wall patches
wallShearStress Calculates and writes the wall shear stress, for the speciﬁed
times
yPlusLES Calculates and reports yPlus for all wall patches, for the spec-
iﬁed times
yPlusRAS Calculates and reports yPlus for all wall patches, for the spec-
iﬁed times
Post-processing turbulence
createTurbulenceFields Creates a full set of turbulence ﬁelds
R Calculates and writes the Reynolds stress R for the current
time step
Post-processing patch data
patchAverage Calculates the average of the speciﬁed ﬁeld over the speciﬁed
patch
patchIntegrate Calculates the integral of the speciﬁed ﬁeld over the speciﬁed
patch
Post-processing Lagrangian simulation
particleTracks Generates a VTK ﬁle of particle tracks for cases that were
computed using a tracked-parcel-type cloud
Sampling post-processing
probeLocations Probe locations
Continued on next page
Open∇FOAM-1.6
3.6 Standard utilities U-93
Continued from previous page
sample Sample ﬁeld data with a choice of interpolation schemes, sam-
pling options and write formats
Miscellaneous post-processing
dsmcFieldsCalc Calculate intensive ﬁelds (U and T) from averaged extensive
ﬁelds from a DSMC calculation
engineCompRatio Calculate the geometric compression ratio. Note that if you
have valves and/or extra volumes it will not work, since it
calculates the volume at BDC and TCD
execFlowFunctionObjects Execute the set of functionObjects speciﬁed in the selected
dictionary (which defaults to system/controlDict) for the se-
lected set of times
pdfPlot Generates an .obj ﬁle to plot a probability distribution func-
tion
postChannel Post-processes data from channel ﬂow calculations
ptot For each time: calculate the total pressure
wdot Calculates and writes wdot for each time
writeCellCentres Write the three components of the cell centres as
volScalarFields so they can be used in postprocessing in
thresholding
Parallel processing
decomposePar Automatically decomposes a mesh and ﬁelds of a case for
parallel execution of OpenFOAM
reconstructPar Reconstructs a mesh and ﬁelds of a case that is decomposed
for parallel execution of OpenFOAM
reconstructParMesh Reconstructs a mesh using geometric information only
redistributeMeshPar Redistributes existing decomposed mesh and ﬁelds according
to the current settings in the decomposeParDict ﬁle
Thermophysical-related utilities
adiabaticFlameT Calculates the adiabatic ﬂame temperature for a given fuel
over a range of unburnt temperatures and equivalence ratios
chemkinToFoam Converts CHEMKIN 3 thermodynamics and reaction data ﬁles
into OpenFOAM format
equilibriumCO Calculates the equilibrium level of carbon monoxide
equilibriumFlameT Calculates the equilibrium ﬂame temperature for a given fuel
and pressure for a range of unburnt gas temperatures and
equivalence ratios; the eﬀects of dissociation on O2, H2O and
CO2 are included
mixtureAdiabaticFlameT Calculates the adiabatic ﬂame temperature for a given mix-
ture at a given temperature
Error estimation
estimateScalarError Estimates the error in the solution for a scalar transport equa-
tion in the standard form
icoErrorEstimate Estimates error for the incompressible laminar CFD applica-
tion icoFoam
Continued on next page
Open∇FOAM-1.6
U-94 Applications and libraries
Continued from previous page
icoMomentError Estimates error for the incompressible laminar CFD applica-
tion icoFoam
momentScalarError Estimates the error in the solution for a scalar transport equa-
tion in the standard form
Miscellaneous utilities
expandDictionary Read the dictionary provided as an argument, expand the
macros etc. and write the resulting dictionary to standard
output
foamDebugSwitches Write out all library debug switches
foamFormatConvert Converts all IOobjects associated with a case into the format
speciﬁed in the controlDict
foamInfoExec Interrogates a case and prints information to screen
patchSummary Writes ﬁelds and boundary condition info for each patch at
each requested time instance
Table 3.6: Standard library utilities.
3.7 Standard libraries
The libraries with the OpenFOAM distribution are in the $FOAM LIB/$WM OPTIONS
directory, reached quickly by typing lib at the command line. Again, the names are
preﬁxed by lib and reasonably descriptive, e.g.incompressibleTransportModels contains
the library of incompressible transport models. For ease of presentation, the libraries are
separated into two types:
General libraries those that provide general classes and associated functions listed in
Table 3.7;
Model libraries those that specify models used in computational continuum mechanics,
listed in Table 3.8, Table 3.9 and Table 3.10.
Library of basic OpenFOAM tools — OpenFOAM
algorithms Algorithms
containers Container classes
db Database classes
dimensionedTypes dimensioned<Type> class and derivatives
dimensionSet dimensionSet class
ﬁelds Field classes
global Global settings
graph graph class
interpolations Interpolation schemes
matrices Matrix classes
memory Memory management tools
meshes Mesh classes
primitives Primitive classes
Continued on next page
Open∇FOAM-1.6
3.7 Standard libraries U-95
Continued from previous page
Finite volume method library — ﬁniteVolume
cfdTools CFD tools
ﬁelds Volume, surface and patch ﬁeld classes; includes boundary
conditions
ﬁniteVolume Finite volume discretisation
fvMatrices Matrices for ﬁnite volume solution
fvMesh Meshes for ﬁnite volume discretisation
interpolation Field interpolation and mapping
surfaceMesh Mesh surface data for ﬁnite volume discretisation
Mesh volume (cell) data for ﬁnite volume discretisation
Post-processing libraries
ﬁeldFunctionObjects Field function objects including ﬁeld averaging, min/max, etc.
foamCalcFunctions Functions for the foamCalc utility
forces Tools for post-processing force/lift/drag data with function
objects
postCalc For using functionality of a function object as a post-
processing activity
sampling Tools for sampling ﬁeld data at prescribed locations in a do-
main
systemCall General function object for making system calls while running
a case
utilityFunctionObjects Utility function objects
Solution and mesh manipulation libraries
autoMesh Library of functionality for the snappyHexMesh utility
dynamicMesh For solving systems with moving meshes
dynamicFvMesh Library for a ﬁnite volume mesh that can move and undergo
topological changes
edgeMesh For handling edge-based mesh descriptions
errorEstimation Error estimation tools
fvMotionSolver Finite volume mesh motion solvers
ODE Solvers for ordinary diﬀerential equations
meshTools Tools for handling a OpenFOAM mesh
surfMesh Library for handling surface meshes of diﬀerent formats
triSurface For handling standard triangulated surface-based mesh de-
scriptions
topoChangerFvMesh Topological changes functionality (largely redundant)
Lagrangian particle tracking libraries
coalCombustion Coal dust combustion modelling
dieselSpray Diesel spray and injection modelling
dsmc Direct simulation Monte Carlo method modelling
lagrangian Basic Lagrangian, or particle-tracking, solution scheme
lagrangianIntermediate Particle-tracking kinematics, thermodynamics, multispecies
reactions, particle forces, etc.
potential Intermolecular potentials for molecular dynamics
molecule Molecule classes for molecular dynamics
molecularMeasurements For making measurements in molecular dynamics
Continued on next page
Open∇FOAM-1.6
U-96 Applications and libraries
Continued from previous page
solidParticle Solid particle implementation
Miscellaneous libraries
conversion Tools for mesh and data conversions
decompositionMethods Tools for domain decomposition
engine Tools for engine calculations
MGridGenGAMGAgglomerationLibrary for cell agglomeration using the MGridGen algorithm
OSspeciﬁc Operating system speciﬁc functions
randomProcesses Tools for analysing and generating random processes
Table 3.7: Shared object libraries for general use.
Basic thermophysical models — basicThermophysicalModels
hPsiThermo General thermophysical model calculation based on en-
thalpy h and compressibility ψ
ePsiThermo General thermophysical model calculation based on inter-
nal energy e and compressibility ψ
hRhoThermo General thermophysical model calculation based on en-
thalpy h
pureMixture General thermophysical model calculation for passive gas
mixtures
Reaction models — reactionThermophysicalModels
hPsiMixtureThermo Calculates enthalpy for combustion mixture based on ψ
hRhoMixtureThermo Calculates enthalpy for combustion mixture based on ρ
hhuMixtureThermo Calculates enthalpy for unburnt gas and combustion mix-
ture
homogeneousMixture Combustion mixture based on normalised fuel mass frac-
tion b
inhomogeneousMixture Combustion mixture based on b and total fuel mass fraction
ft
veryInhomogeneousMixture Combustion mixture based on b, ft and unburnt fuel mass
fraction fu
dieselMixture Combustion mixture based on ft and fu
basicMultiComponent-
Mixture
Basic mixture based on multiple components
multiComponentMixture Derived mixture based on multiple components
reactingMixture Combustion mixture using thermodynamics and reaction
schemes
egrMixture Exhaust gas recirculation mixture
Radiation models — radiation
P1 P1 model
fvDOM Finite volume discrete ordinate method
Continued on next page
Open∇FOAM-1.6
3.7 Standard libraries U-97
Continued from previous page
Laminar ﬂame speed models — laminarFlameSpeedModels
constLaminarFlameSpeed Constant laminar ﬂame speed
GuldersLaminarFlameSpeed G¨ulder’s laminar ﬂame speed model
GuldersEGRLaminar-
FlameSpeed
G¨ulder’s laminar ﬂame speed model with exhaust gas re-
circulation modelling
Barotropic compressibility models — barotropicCompressibilityModels
linear Linear compressibility model
Chung Chung compressibility model
Wallis Wallis compressibility model
Thermophysical properties of gaseous species — specie
icoPolynomial Incompressible polynomial equation of state, e.g. for liquids
perfectGas Perfect gas equation of state
eConstThermo Constant speciﬁc heat cp model with evaluation of internal
energy e and entropy s
hConstThermo Constant speciﬁc heat cp model with evaluation of enthalpy
h and entropy s
hPolynomialThermo cp evaluated by a function with coeﬃcients from polynomi-
als, from which h, s are evaluated
janafThermo cp evaluated by a function with coeﬃcients from JANAF
thermodynamic tables, from which h, s are evaluated
specieThermo Thermophysical properties of species, derived from cp, h
and/or s
constTransport Constant transport properties
polynomialTransport Polynomial based temperature-dependent transport prop-
erties
sutherlandTransport Sutherland’s formula for temperature-dependent transport
properties
Functions/tables of thermophysical properties — thermophysicalFunctions
NSRDSfunctions National Standard Reference Data System (NSRDS) -
American Institute of Chemical Engineers (AICHE) data
compilation tables
APIfunctions American Petroleum Institute (API) function for vapour
mass diﬀusivity
Probability density functions — pdf
RosinRammler Rosin-Rammler distribution
normal Normal distribution
uniform Uniform distribution
exponential Exponential distribution
general General distribution
Chemistry model — chemistryModel
chemistryModel Chemical reaction model
chemistrySolver Chemical reaction solver
Continued on next page
Open∇FOAM-1.6
U-98 Applications and libraries
Continued from previous page
Other libraries
liquids Thermophysical properties of liquids
liquidMixture Thermophysical properties of liquid mixtures
solids Thermophysical properties of solids
solidMixture Thermophysical properties of solid mixtures
Table 3.8: Libraries of thermophysical models.
RAS turbulence models for incompressible ﬂuids — incompressibleRASModels
laminar Dummy turbulence model for laminar ﬂow
kEpsilon Standard high-Re k − ε model
kOmega Standard high-Re k − ω model
kOmegaSST k − ω-SST model
RNGkEpsilon RNG k − ε model
NonlinearKEShih Non-linear Shih k − ε model
LienCubicKE Lien cubic k − ε model
qZeta q − ζ model
LaunderSharmaKE Launder-Sharma low-Re k − ε model
LamBremhorstKE Lam-Bremhorst low-Re k − ε model
LienCubicKELowRe Lien cubic low-Re k − ε model
LienLeschzinerLowRe Lien-Leschziner low-Re k − ε model
LRR Launder-Reece-Rodi RSTM
LaunderGibsonRSTM Launder-Gibson RSTM with wall-reﬂection terms
realizableKE Realizable k − ε model
SpalartAllmaras Spalart-Allmaras 1-eqn mixing-length model
RAS turbulence models for compressible ﬂuids — compressibleRASModels
laminar Dummy turbulence model for laminar ﬂow
kEpsilon Standard k − ε model
kOmegaSST k − ω − SST model
RNGkEpsilon RNG k − ε model
LaunderSharmaKE Launder-Sharma low-Re k − ε model
LRR Launder-Reece-Rodi RSTM
LaunderGibsonRSTM Launder-Gibson RSTM
realizableKE Realizable k − ε model
SpalartAllmaras Spalart-Allmaras 1-eqn mixing-length model
Large-eddy simulation (LES) ﬁlters — LESﬁlters
laplaceFilter Laplace ﬁlters
simpleFilter Simple ﬁlter
anisotropicFilter Anisotropic ﬁlter
Large-eddy simulation deltas — LESdeltas
PrandtlDelta Prandtl delta
cubeRootVolDelta Cube root of cell volume delta
smoothDelta Smoothing of delta
Continued on next page
Open∇FOAM-1.6
3.7 Standard libraries U-99
Continued from previous page
Incompressible LES turbulence models — incompressibleLESModels
Smagorinsky Smagorinsky model
Smagorinsky2 Smagorinsky model with 3-D ﬁlter
dynSmagorinsky Dynamic Smagorinsky
scaleSimilarity Scale similarity model
mixedSmagorinsky Mixed Smagorinsky/scale similarity model
dynMixedSmagorinsky Dynamic mixed Smagorinsky/scale similarity model
kOmegaSST k − ω-SST scale adaptive simulation (SAS) model
oneEqEddy k-equation eddy-viscosity model
dynOneEqEddy Dynamic k-equation eddy-viscosity model
locDynOneEqEddy Localised dynamic k-equation eddy-viscosity model
spectEddyVisc Spectral eddy viscosity model
LRDDiﬀStress LRR diﬀerential stress model
DeardorﬀDiﬀStress Deardorﬀ diﬀerential stress model
SpalartAllmaras Spalart-Allmaras model
SpalartAllmarasDDES Spalart-Allmaras delayed detached eddy simulation
(DDES) model
SpalartAllmarasIDDES Spalart-Allmaras improved DDES (IDDES) model
Compressible LES turbulence models — compressibleLESModels
Smagorinsky Smagorinsky model
oneEqEddy k-equation eddy-viscosity model
dynOneEqEddy Dynamic k-equation eddy-viscosity model
lowReOneEqEddy Low-Re k-equation eddy-viscosity model
DeardorﬀDiﬀStress Deardorﬀ diﬀerential stress model
SpalartAllmaras Spalart-Allmaras 1-eqn mixing-length model
Table 3.9: Libraries of RAS and LES turbulence models.
Transport models for incompressible ﬂuids — incompressibleTransportModels
Newtonian Linear viscous ﬂuid model
CrossPowerLaw Cross Power law nonlinear viscous model
BirdCarreau Bird-Carreau nonlinear viscous model
HerschelBulkley Herschel-Bulkley nonlinear viscous model
powerLaw Power-law nonlinear viscous model
interfaceProperties Models for the interface, e.g. contact angle, in multiphase
simulations
Table 3.10: Shared object libraries of transport models.
Open∇FOAM-1.6
U-100 Applications and libraries
Open∇FOAM-1.6
Chapter 4
OpenFOAM cases
This chapter deals with the ﬁle structure and organisation of OpenFOAM cases. Nor-
mally, a user would assign a name to a case, e.g. the tutorial case of ﬂow in a cav-
ity is simply named cavity. This name becomes the name of a directory in which all
the case ﬁles and subdirectories are stored. The case directories themselves can be
located anywhere but we recommend they are within a run subdirectory of the user’s
project directory, i.e.$HOME/OpenFOAM/${USER}-1.6 as described at the beginning of
chapter 2. One advantage of this is that the $FOAM RUN environment variable is set
to $HOME/OpenFOAM/${USER}-1.6/run by default; the user can quickly move to that
directory by executing a preset alias, run, at the command line.
The tutorial cases that accompany the OpenFOAM distribution provide useful exam-
ples of the case directory structures. The tutorials are located in the $FOAM TUTORIALS
directory, reached quickly by executing the tut alias at the command line. Users can view
tutorial examples at their leisure while reading this chapter.
4.1 File structure of OpenFOAM cases
The basic directory structure for a OpenFOAM case, that contains the minimum set of
ﬁles required to run an application, is shown in Figure 4.1 and described as follows:
<case>
system
controlDict
fvSchemes
polyMesh
points
cells
faces
. . . Properties
boundary
constant
time directories
fvSolution
see section 4.3
see section 4.4
see section 4.5
see section 5.1.2
see section 4.2.8
see chapter 7
Figure 4.1: Case directory structure
U-102 OpenFOAM cases
A constant directory that contains a full description of the case mesh in a subdirec-
tory polyMesh and ﬁles specifying physical properties for the application concerned,
e.g.transportProperties.
A system directory for setting parameters associated with the solution procedure itself.
It contains at least the following 3 ﬁles: controlDict where run control parameters are
set including start/end time, time step and parameters for data output; fvSchemes
where discretisation schemes used in the solution may be selected at run-time; and,
fvSolution where the equation solvers, tolerances and other algorithm controls are
set for the run.
The ‘time’ directories containing individual ﬁles of data for particular ﬁelds. The
data can be: either, initial values and boundary conditions that the user must
specify to deﬁne the problem; or, results written to ﬁle by OpenFOAM. Note that
the OpenFOAM ﬁelds must always be initialised, even when the solution does not
strictly require it, as in steady-state problems. The name of each time directory is
based on the simulated time at which the data is written and is described fully in
section 4.3. It is suﬃcient to say now that since we usually start our simulations
at time t = 0, the initial conditions are usually stored in a directory named 0 or
0.000000e+00, depending on the name format speciﬁed. For example, in the cavity
tutorial, the velocity ﬁeld U and pressure ﬁeld p are initialised from ﬁles 0/U and
0/p respectively.
4.2 Basic input/output ﬁle format
OpenFOAM needs to read a range of data structures such as strings, scalars, vectors,
tensors, lists and ﬁelds. The input/output (I/O) format of ﬁles is designed to be extremely
ﬂexible to enable the user to modify the I/O in OpenFOAM applications as easily as
possible. The I/O follows a simple set of rules that make the ﬁles extremely easy to
understand, in contrast to many software packages whose ﬁle format may not only be
diﬃcult to understand intuitively but also not be published anywhere. The description
of the OpenFOAM ﬁle format is described in the following sections.
4.2.1 General syntax rules
The format follows the following some general principles of C++ source code.
• Files have free form, with no particular meaning assigned to any column and no
need to indicate continuation across lines.
• Lines have no particular meaning except to a // comment delimiter which makes
OpenFOAM ignore any text that follows it until the end of line.
• A comment over multiple lines is done by enclosing the text between /* and */
delimiters.
4.2.2 Dictionaries
OpenFOAM uses dictionaries as the most common means of specifying data. A dictionary
is an entity that contains as set data entries that can be retrieved by the I/O by means
of keywords. The keyword entries follow the general format
Open∇FOAM-1.6
4.2 Basic input/output ﬁle format U-103
<keyword> <dataEntry1> ... <dataEntryN>;
Most entries are single data entries of the form:
<keyword> <dataEntry>;
Most OpenFOAM data ﬁles are themselves dictionaries containing a set of keyword en-
tries. Dictionaries provide the means for organising entries into logical categories and can
be speciﬁed hierarchically so that any dictionary can itself contain one or more dictionary
entries. The format for a dictionary is to specify the dictionary name followed the the
entries enclosed in curly braces {} as follows
<dictionaryName>
{
... keyword entries ...
}
4.2.3 The data ﬁle header
All data ﬁles that are read and written by OpenFOAM begin with a dictionary named
FoamFile containing a standard set of keyword entries, listed in Table 4.1. The table
Keyword Description Entry
version I/O format version 2.0
format Data format ascii / binary
location Path to the ﬁle, in "..." (optional)
class OpenFOAM class constructed from the
data ﬁle concerned
typically dictionary or a
ﬁeld, e.g.volVectorField
object Filename e.g.controlDict
Table 4.1: Header keywords entries for data ﬁles.
provides brief descriptions of each entry, which is probably suﬃcient for most entries with
the notable exception of class. The class entry is the name of the C++ class in the
OpenFOAM library that will be constructed from the data in the ﬁle. Without knowledge
of the underlying code which calls the ﬁle to be read, and knowledge of the OpenFOAM
classes, the user will probably be unable to surmise the class entry correctly. However,
most data ﬁles with simple keyword entries are read into an internal dictionary class and
therefore the class entry is dictionary in those cases.
The following example shows the use of keywords to provide data for a case using the
types of entry described so far. The extract, from an fvSolution dictionary ﬁle, contains
2 dictionaries, solvers and PISO. The solvers dictionary contains multiple data entries for
solver and tolerances for each of the pressure and velocity equations, represented by the
p and U keywords respectively; the PISO dictionary contains algorithm controls.
17
18 solvers
19 {
20 p
21 {
22 solver PCG;
23 preconditioner DIC;
24 tolerance 1e-06;
Open∇FOAM-1.6
U-104 OpenFOAM cases
25 relTol 0;
26 }
27
28 U
29 {
30 solver PBiCG;
31 preconditioner DILU;
32 tolerance 1e-05;
33 relTol 0;
34 }
35 }
36
37 PISO
38 {
39 nCorrectors 2;
40 nNonOrthogonalCorrectors 0;
41 pRefCell 0;
42 pRefValue 0;
43 }
44
45
46 // ************************************************************************* //
4.2.4 Lists
OpenFOAM applications contain lists, e.g. a list of vertex coordinates for a mesh de-
scription. Lists are commonly found in I/O and have a format of their own in which the
entries are contained within round braces ( ). There is also a choice of format preceeding
the round braces:
simple the keyword is followed immediately by round braces
<listName>
(
... entries ...
);
numbered the keyword is followed by the number of elements <n> in the list
<listName>
<n>
(
... entries ...
);
token identiﬁer the keyword is followed by a class name identiﬁer Label<Type> where
<Type> states what the list contains, e.g. for a list of scalar elements is
<listName>
List<scalar>
<n> // optional
(
... entries ...
);
Note that <scalar> in List<scalar> is not a generic name but the actual text that
should be entered.
The simple format is a convenient way of writing a list. The other formats allow
the code to read the data faster since the size of the list can be allocated to memory
in advance of reading the data. The simple format is therefore preferred for short lists,
where read time is minimal, and the other formats are preferred for long lists.
Open∇FOAM-1.6
4.2 Basic input/output ﬁle format U-105
4.2.5 Scalars, vectors and tensors
A scalar is a single number represented as such in a data ﬁle. A vector is a VectorSpace
of rank 1 and dimension 3, and since the number of elements is always ﬁxed to 3, the
simple List format is used. Therefore a vector (1.0, 1.1, 1.2) is written:
(1.0 1.1 1.2)
In OpenFOAM, a tensor is a VectorSpace of rank 2 and dimension 3 and therefore the
data entries are always ﬁxed to 9 real numbers. Therefore the identity tensor, described
in section 1.3.7 of the Programmer’s Guide, can be written:
(
1 0 0
0 1 0
0 0 1
)
This example demonstrates the way in which OpenFOAM ignores the line return is so
that the entry can be written over multiple lines. It is treated no diﬀerently to listing the
numbers on a single line:
( 1 0 0 0 1 0 0 0 1 )
4.2.6 Dimensional units
In continuum mechanics, properties are represented in some chosen units, e.g. mass in
kilograms (kg), volume in cubic metres (m3
), pressure in Pascals (kg m−1
s−2
). Algebraic
operations must be performed on these properties using consistent units of measurement;
in particular, addition, subtraction and equality are only physically meaningful for prop-
erties of the same dimensional units. As a safeguard against implementing a meaningless
operation, OpenFOAM attaches dimensions to ﬁeld data and physical properties and
performs dimension checking on any tensor operation.
The I/O format for a dimensionSet is 7 scalars delimited by square brackets, e.g.
[0 2 -1 0 0 0 0]
No. Property SI unit USCS unit
1 Mass kilogram (kg) pound-mass (lbm)
2 Length metre (m) foot (ft)
3 Time — — — — second (s) — — — —
4 Temperature Kelvin (K) degree Rankine (◦
R)
5 Quantity kilogram-mole (kgmol) pound-mole (lbmol)
6 Current — — — — ampere (A) — — — —
7 Luminous intensity — — — — candela (cd) — — — —
Table 4.2: Base units for SI and USCS
where each of the values corresponds to the power of each of the base units of measure-
ment listed in Table 4.2. The table gives the base units for the Syst`eme International
(SI) and the United States Customary System (USCS) but OpenFOAM can be used
Open∇FOAM-1.6
U-106 OpenFOAM cases
with any system of units. All that is required is that the input data is correct for the
chosen set of units. It is particularly important to recognise that OpenFOAM requires
some dimensioned physical constants, e.g. the Universal Gas Constant R, for certain cal-
culations, e.g. thermophysical modelling. These dimensioned constants are speciﬁed in
a DimensionedConstant sub-dictionary of main controlDict ﬁle of the OpenFOAM instal-
lation ($WM PROJECT DIR/etc/controlDict). By default these constants are set in SI
units. Those wishing to use the USCS or any other system of units should modify these
constants to their chosen set of units accordingly.
4.2.7 Dimensioned types
Physical properties are typically speciﬁed with their associated dimensions. These entries
have the format that the following example of a dimensionedScalar demonstrates:
nu nu [0 2 -1 0 0 0 0] 1;
The ﬁrst nu is the keyword; the second nu is the word name stored in class word, usually
chosen to be the same as the keyword; the next entry is the dimensionSet and the ﬁnal
entry is the scalar value.
4.2.8 Fields
Much of the I/O data in OpenFOAM are tensor ﬁelds, e.g. velocity, pressure data, that
are read from and written into the time directories. OpenFOAM writes ﬁeld data using
keyword entries as described in Table 4.3.
Keyword Description Example
dimensions Dimensions of ﬁeld [1 1 -2 0 0 0 0]
internalField Value of internal ﬁeld uniform (1 0 0)
boundaryField Boundary ﬁeld see ﬁle listing in section 4.2.8
Table 4.3: Main keywords used in ﬁeld dictionaries.
The data begins with an entry for its dimensions. Following that, is the internalField,
described in one of the following ways.
Uniform ﬁeld a single value is assigned to all elements within the ﬁeld, taking the form:
internalField uniform <entry>;
Nonuniform ﬁeld each ﬁeld element is assigned a unique value from a list, taking the
following form where the token identiﬁer form of list is recommended:
internalField nonuniform <List>;
The boundaryField is a dictionary containing a set of entries whose names correspond
to each of the names of the boundary patches listed in the boundary ﬁle in the polyMesh
directory. Each patch entry is itself a dictionary containing a list of keyword entries.
The compulsory entry, type, describes the patch ﬁeld condition speciﬁed for the ﬁeld.
The remaining entries correspond to the type of patch ﬁeld condition selected and can
Open∇FOAM-1.6
4.2 Basic input/output ﬁle format U-107
typically include ﬁeld data specifying initial conditions on patch faces. A selection of
patch ﬁeld conditions available in OpenFOAM are listed in Table 5.3 and Table 5.4 with
a description and the data that must be speciﬁed with it. Example ﬁeld dictionary entries
for velocity U are shown below:
17 dimensions [0 1 -1 0 0 0 0];
18
19 internalField uniform (0 0 0);
20
21 boundaryField
22 {
23 movingWall
24 {
25 type fixedValue;
26 value uniform (1 0 0);
27 }
28
29 fixedWalls
30 {
31 type fixedValue;
32 value uniform (0 0 0);
33 }
34
35 frontAndBack
36 {
37 type empty;
38 }
39 }
40
41 // ************************************************************************* //
4.2.9 Directives and macro substitutions
There is additional ﬁle syntax that oﬀers great ﬂexibility for the setting up of OpenFOAM
case ﬁles, namely directives and macro substitutions. Directives are commands that can
be contained within case ﬁles that begin with the hash (#) symbol. Macro substitutions
begin with the dollar ($) symbol.
At present there are 2 directive commands available in OpenFOAM:
#include "<fileName>" reads the ﬁle of name <ﬁleName>;
#inputMode has two options: merge, which merges keyword entries in successive dictio-
naries, so that a keyword entry speciﬁed in one place will be overridden by a later
speciﬁcation of the same keyword entry; overwrite, which overwrites the contents
of an entire dictionary; generally, use merge.
For example, let us say a user wishes to set an initial value of pressure once to be used
as the internal ﬁeld and initial value at a boundary. We could create a ﬁle, e.g. named
initialConditions, which contains the following entries:
pressure 1e+05;
#inputMode merge
In order to use this pressure for both the internal and initial boundary ﬁelds, the user
would simply include the following macro substitutions in the pressure ﬁeld ﬁle p:
#include "initialConditions"
internalField $pressure
boundaryField
{
patch1
{
Open∇FOAM-1.6
U-108 OpenFOAM cases
type fixedValue;
value $pressure;
}
}
This is a fairly trivial example that simply demonstrates how this functionality works.
However, the functionality can be used in many, more powerful ways particularly as a
means of generalising case data to suit the user’s needs. For example, if a user has a set
of cases that require the same RAS turbulence model settings, a single ﬁle can be created
with those settings which is simply included in the RASProperties ﬁle of each case. Macro
substitutions can extend well beyond a singe value so that, for example, sets of boundary
conditions can be predeﬁned and called by a single macro. The extent to which such
functionality can be used is almost endless.
4.3 Time and data input/output control
The OpenFOAM solvers begin all runs by setting up a database. The database controls
I/O and, since output of data is usually requested at intervals of time during the run, time
is an inextricable part of the database. The controlDict dictionary sets input parameters
essential for the creation of the database. The keyword entries in controlDict are listed in
Table 4.4. Only the time control and writeInterval entries are truly compulsory, with
the database taking default values indicated by † in Table 4.4 for any of the optional
entries that are omitted.
Time control
startFrom Controls the start time of the simulation.
- firstTime Earliest time step from the set of time directories.
- startTime Time speciﬁed by the startTime keyword entry.
- latestTime Most recent time step from the set of time directories.
startTime Start time for the simulation with startFrom startTime;
stopAt Controls the end time of the simulation.
- endTime Time speciﬁed by the endTime keyword entry.
- writeNow Stops simulation on completion of current time step and writes
data.
- noWriteNow Stops simulation on completion of current time step and does not
write out data.
- nextWrite Stops simulation on completion of next scheduled write time, spec-
iﬁed by writeControl.
endTime End time for the simulation when stopAt endTime; is speciﬁed.
deltaT Time step of the simulation.
Data writing
writeControl Controls the timing of write output to ﬁle.
- timeStep† Writes data every writeInterval time steps.
- runTime Writes data every writeInterval seconds of simulated time.
Continued on next page
Open∇FOAM-1.6
4.3 Time and data input/output control U-109
Continued from previous page
- adjustableRunTime Writes data every writeInterval seconds of simulated time,
adjusting the time steps to coincide with the writeInterval if
necessary — used in cases with automatic time step adjustment.
- cpuTime Writes data every writeInterval seconds of CPU time.
- clockTime Writes data out every writeInterval seconds of real time.
writeInterval Scalar used in conjunction with writeControl described above.
purgeWrite Integer representing a limit on the number of time directories that
are stored by overwriting time directories on a cyclic basis. Exam-
ple of t0 = 5s, ∆t = 1s and purgeWrite 2;: data written into 2
directories, 6 and 7, before returning to write the data at 8 s in 6,
data at 9 s into 7, etc.
To disable the time directory limit, specify purgeWrite 0;†
For steady-state solutions, results from previous iterations can be
continuously overwritten by specifying purgeWrite 1;
writeFormat Speciﬁes the format of the data ﬁles.
- ascii† ASCII format, written to writePrecision signiﬁcant ﬁgures.
- binary Binary format.
writePrecision Integer used in conjunction with writeFormat described above, 6†
by default
writeCompression Speciﬁes the compression of the data ﬁles.
- uncompressed No compression.†
- compressed gzip compression.
timeFormat Choice of format of the naming of the time directories.
- fixed ±m.dddddd where the number of ds is set by timePrecision.
- scientific ±m.dddddde±xx where the number of ds is set by timePrecision.
- general† Speciﬁes scientific format if the exponent is less than -4 or
greater than or equal to that speciﬁed by timePrecision.
timePrecision Integer used in conjunction with timeFormat described above, 6†
by default
graphFormat Format for graph data written by an application.
- raw† Raw ASCII format in columns.
- gnuplot Data in gnuplot format.
- xmgr Data in Grace/xmgr format.
- jplot Data in jPlot format.
Data reading
runTimeModifiable yes†/no switch for whether dictionaries, e.g.controlDict, are re-
read by OpenFOAM at the beginning of each time step.
Continued on next page
Open∇FOAM-1.6
U-110 OpenFOAM cases
Continued from previous page
Run-time loadable functionality
libs List of additional libraries (on $LD LIBRARY PATH) to be loaded
at run-time, e.g.( "libUser1.so" "libUser2.so" )
functions List of functions, e.g. probes to be loaded at run-time; see examples
in $FOAM TUTORIALS
† denotes default entry if associated keyword is omitted.
Table 4.4: Keyword entries in the controlDict dictionary.
Example entries from a controlDict dictionary are given below:
17
18 application icoFoam;
19
20 startFrom startTime;
21
22 startTime 0;
23
24 stopAt endTime;
25
26 endTime 0.5;
27
28 deltaT 0.005;
29
30 writeControl timeStep;
31
32 writeInterval 20;
33
34 purgeWrite 0;
35
36 writeFormat ascii;
37
38 writePrecision 6;
39
40 writeCompression uncompressed;
41
42 timeFormat general;
43
44 timePrecision 6;
45
46 runTimeModifiable yes;
47
48
49 // ************************************************************************* //
4.4 Numerical schemes
The fvSchemes dictionary in the system directory sets the numerical schemes for terms,
such as derivatives in equations, that appear in applications being run. This section
describes how to specify the schemes in the fvSchemes dictionary; a description of the
numerics of the schemes is in section 2.4 of the Programmer’s Guide.
The terms that must typically be assigned a numerical scheme in fvSchemes range from
derivatives, e.g. gradient ∇, and interpolations of values from one set of points to another.
The aim in OpenFOAM is to oﬀer an unrestricted choice to the user. For example, while
linear interpolation is eﬀective in many cases, OpenFOAM oﬀers complete freedom to
choose from a wide selection of interpolation schemes for all interpolation terms.
The derivative terms further exemplify this freedom of choice. The user ﬁrst has a
choice of discretisation practice where standard Gaussian ﬁnite volume integration is the
common choice. Gaussian integration is based on summing values on cell faces, which
must be interpolated from cell centres. The user again has a completely free choice
of interpolation scheme, with certain schemes being speciﬁcally designed for particular
derivative terms, especially the convection divergence ∇ • terms.
Open∇FOAM-1.6
4.4 Numerical schemes U-111
The set of terms, for which numerical schemes must be speciﬁed, are subdivided within
the fvSchemes dictionary into the categories listed in Table 4.5. Each keyword in Table 4.5
is the name of a sub-dictionary which contains terms of a particular type, e.g.gradSchemes
contains all the gradient derivative terms such as grad(p) (which represents ∇p). Further
examples can be seen in the extract from an fvSchemes dictionary below:
Keyword Category of mathematical terms
interpolationSchemes Point-to-point interpolations of values
snGradSchemes Component of gradient normal to a cell face
gradSchemes Gradient ∇
divSchemes Divergence ∇ •
laplacianSchemes Laplacian ∇2
timeScheme First and second time derivatives ∂/∂t, ∂2
/∂2
t
fluxRequired Fields which require the generation of a ﬂux
Table 4.5: Main keywords used in fvSchemes.
17
18 ddtSchemes
19 {
20 default Euler;
21 }
22
23 gradSchemes
24 {
25 default Gauss linear;
26 grad(p) Gauss linear;
27 }
28
29 divSchemes
30 {
31 default none;
32 div(phi,U) Gauss linear;
33 }
34
35 laplacianSchemes
36 {
37 default none;
38 laplacian(nu,U) Gauss linear corrected;
39 laplacian((1|A(U)),p) Gauss linear corrected;
40 }
41
42 interpolationSchemes
43 {
44 default linear;
45 interpolate(HbyA) linear;
46 }
47
48 snGradSchemes
49 {
50 default corrected;
51 }
52
53 fluxRequired
54 {
55 default no;
56 p ;
57 }
58
59
60 // ************************************************************************* //
The example shows that the fvSchemes dictionary contains the following:
• 6 . . . Schemes subdictionaries containing keyword entries for each term speciﬁed
within including: a default entry; other entries whose names correspond to a word
identiﬁer for the particular term speciﬁed, e.g.grad(p) for ∇p
Open∇FOAM-1.6
U-112 OpenFOAM cases
• a ﬂuxRequired sub-dictionary containing ﬁelds for which the ﬂux is generated in the
application, e.g.p in the example.
If a default scheme is speciﬁed in a particular . . . Schemes sub-dictionary, it is assigned
to all of the terms to which the sub-dictionary refers, e.g. specifying a default in grad-
Schemes sets the scheme for all gradient terms in the application, e.g. ∇p, ∇U. When
a default is speciﬁed, it is not necessary to specify each speciﬁc term itself in that sub-
dictionary, i.e. the entries for grad(p), grad(U) in this example. However, if any of these
terms are included, the speciﬁed scheme overrides the default scheme for that term.
Alternatively the user may insist on no default scheme by the none entry. In this
instance the user is obliged to specify all terms in that sub-dictionary individually. Setting
default to none may appear superﬂuous since default can be overridden. However,
specifying none forces the user to specify all terms individually which can be useful to
remind the user which terms are actually present in the application.
The following sections describe the choice of schemes for each of the categories of
terms in Table 4.5.
4.4.1 Interpolation schemes
The interpolationSchemes sub-dictionary contains terms that are interpolations of val-
ues typically from cell centres to face centres. A selection of interpolation schemes in
OpenFOAM are listed in Table 4.6, being divided into 4 categories: 1 category of gen-
eral schemes; and, 3 categories of schemes used primarily in conjunction with Gaussian
discretisation of convection (divergence) terms in ﬂuid ﬂow, described in section 4.4.5.
It is highly unlikely that the user would adopt any of the convection-speciﬁc schemes
for general ﬁeld interpolations in the interpolationSchemes sub-dictionary, but, as valid
interpolation schemes, they are described here rather than in section 4.4.5. Note that
additional schemes such as UMIST are available in OpenFOAM but only those schemes
that are generally recommended are listed in Table 4.6.
A general scheme is simply speciﬁed by quoting the keyword and entry, e.g. a linear
scheme is speciﬁed as default by:
default linear;
The convection-speciﬁc schemes calculate the interpolation based on the ﬂux of the
ﬂow velocity. The speciﬁcation of these schemes requires the name of the ﬂux ﬁeld
on which the interpolation is based; in most OpenFOAM applications this is phi, the
name commonly adopted for the surfaceScalarField velocity ﬂux φ. The 3 categories of
convection-speciﬁc schemes are referred to in this text as: general convection; normalised
variable (NV); and, total variation diminishing (TVD). With the exception of the blended
scheme, the general convection and TVD schemes are speciﬁed by the scheme and ﬂux,
e.g. an upwind scheme based on a ﬂux phi is speciﬁed as default by:
default upwind phi;
Some TVD/NVD schemes require a coeﬃcient ψ, 0 ≤ ψ ≤ 1 where ψ = 1 corresponds
to TVD conformance, usually giving best convergence and ψ = 0 corresponds to best
accuracy. Running with ψ = 1 is generally recommended. A limitedLinear scheme
based on a ﬂux phi with ψ = 1.0 is speciﬁed as default by:
default limitedLinear 1.0 phi;
Open∇FOAM-1.6
4.4 Numerical schemes U-113
4.4.1.1 Schemes for strictly bounded scalar ﬁelds
There are enhanced versions of some of the limited schemes for scalars that need to be
strictly bounded. To bound between user-speciﬁed limits, the scheme name should be
preprended by the word limited and followed by the lower and upper limits respectively.
For example, to bound the vanLeer scheme strictly between -2 and 3, the user would
specify:
default limitedVanLeer -2.0 3.0;
There are specialised versions of these schemes for scalar ﬁelds that are commonly bounded
between 0 and 1. These are selected by adding 01 to the name of the scheme. For example,
to bound the vanLeer scheme strictly between 0 and 1, the user would specify:
default vanLeer01;
Strictly bounded versions are available for the following schemes: limitedLinear, vanLeer,
Gamma, limitedCubic, MUSCL and SuperBee.
4.4.1.2 Schemes for vector ﬁelds
There are improved versions of some of the limited schemes for vector ﬁelds in which
the limited is formulated to take into account the direction of the ﬁeld. These schemes
are selected by adding V to the name of the general scheme, e.g.limitedLinearV for
limitedLinear. ‘V’ versions are available for the following schemes: limitedLinearV,
vanLeerV, GammaV, limitedCubicV and SFCDV.
Centred schemes
linear Linear interpolation (central diﬀerencing)
cubicCorrection Cubic scheme
midPoint Linear interpolation with symmetric weighting
Upwinded convection schemes
upwind Upwind diﬀerencing
linearUpwind Linear upwind diﬀerencing
skewLinear Linear with skewness correction
QUICK Quadratic upwind diﬀerencing
TVD schemes
limitedLinear limited linear diﬀerencing
vanLeer van Leer limiter
MUSCL MUSCL limiter
limitedCubic Cubic limiter
NVD schemes
SFCD Self-ﬁltered central diﬀerencing
Gamma ψ Gamma diﬀerencing
Table 4.6: Interpolation schemes.
Open∇FOAM-1.6
U-114 OpenFOAM cases
4.4.2 Surface normal gradient schemes
The snGradSchemes sub-dictionary contains surface normal gradient terms. A surface
normal gradient is evaluated at a cell face; it is the component, normal to the face, of the
gradient of values at the centres of the 2 cells that the face connects. A surface normal
gradient may be speciﬁed in its own right and is also required to evaluate a Laplacian
term using Gaussian integration.
The available schemes are listed in Table 4.7 and are speciﬁed by simply quoting the
keyword and entry, with the exception of limited which requires a coeﬃcient ψ, 0 ≤ ψ ≤
1 where
ψ =



0 corresponds to uncorrected,
0.333 non-orthogonal correction ≤ 0.5 × orthogonal part,
0.5 non-orthogonal correction ≤ orthogonal part,
1 corresponds to corrected.
(4.1)
A limited scheme with ψ = 0.5 is therefore speciﬁed as default by:
default limited 0.5;
Scheme Description
corrected Explicit non-orthogonal correction
uncorrected No non-orthogonal correction
limited ψ Limited non-orthogonal correction
bounded Bounded correction for positive scalars
fourth Fourth order
Table 4.7: Surface normal gradient schemes.
4.4.3 Gradient schemes
The gradSchemes sub-dictionary contains gradient terms. The discretisation scheme for
each term can be selected from those listed in Table 4.8.
Discretisation scheme Description
Gauss <interpolationScheme> Second order, Gaussian integration
leastSquares Second order, least squares
fourth Fourth order, least squares
limited <gradScheme> Limited version of one of the above schemes
Table 4.8: Discretisation schemes available in gradSchemes.
The discretisation scheme is suﬃcient to specify the scheme completely in the cases
of leastSquares and fourth, e.g.
grad(p) leastSquares;
Open∇FOAM-1.6
4.4 Numerical schemes U-115
The Gauss keyword speciﬁes the standard ﬁnite volume discretisation of Gaussian
integration which requires the interpolation of values from cell centres to face centres.
Therefore, the Gauss entry must be followed by the choice of interpolation scheme from
Table 4.6. It would be extremely unusual to select anything other than general interpo-
lation schemes and in most cases the linear scheme is an eﬀective choice, e.g.
grad(p) Gauss linear;
Limited versions of any of the 3 base gradient schemes — Gauss, leastSquares and
fourth — can be selected by preceding the discretisation scheme by limited, e.g. a
limited Gauss scheme
grad(p) limited Gauss linear;
4.4.4 Laplacian schemes
The laplacianSchemes sub-dictionary contains Laplacian terms. Let us discuss the syntax
of the entry in reference to a typical Laplacian term found in ﬂuid dynamics, ∇ • (ν∇U),
given the word identiﬁer laplacian(nu,U). The Gauss scheme is the only choice of dis-
cretisation and requires a selection of both an interpolation scheme for the diﬀusion
coeﬃcient, i.e. ν in our example, and a surface normal gradient scheme, i.e. ∇U. To
summarise, the entries required are:
Gauss <interpolationScheme> <snGradScheme>
The interpolation scheme is selected from Table 4.6, the typical choices being from the
general schemes and, in most cases, linear. The surface normal gradient scheme is
selected from Table 4.7; the choice of scheme determines numerical behaviour as described
in Table 4.9. A typical entry for our example Laplacian term would be:
laplacian(nu,U) Gauss linear corrected;
Scheme Numerical behaviour
corrected Unbounded, second order, conservative
uncorrected Bounded, ﬁrst order, non-conservative
limited ψ Blend of corrected and uncorrected
bounded First order for bounded scalars
fourth Unbounded, fourth order, conservative
Table 4.9: Behaviour of surface normal schemes used in laplacianSchemes.
4.4.5 Divergence schemes
The divSchemes sub-dictionary contains divergence terms. Let us discuss the syntax of
the entry in reference to a typical convection term found in ﬂuid dynamics ∇ • (ρUU),
which in OpenFOAM applications is commonly given the identiﬁer div(phi,U), where
phi refers to the ﬂux φ = ρU.
The Gauss scheme is only choice of discretisation and requires a selection of the
interpolation scheme for the dependent ﬁeld, i.e. U in our example. To summarise, the
entries required are:
Open∇FOAM-1.6
U-116 OpenFOAM cases
Gauss <interpolationScheme>
The interpolation scheme is selected from the full range of schemes in Table 4.6, both
general and convection-speciﬁc. The choice critically determines numerical behaviour as
described in Table 4.10. The syntax here for specifying convection-speciﬁc interpolation
schemes does not include the ﬂux as it is already known for the particular term, i.e. for
div(phi,U), we know the ﬂux is phi so specifying it in the interpolation scheme would
only invite an inconsistency. Speciﬁcation of upwind interpolation in our example would
therefore be:
div(phi,U) Gauss upwind;
Scheme Numerical behaviour
linear Second order, unbounded
skewLinear Second order, (more) unbounded, skewness correction
cubicCorrected Fourth order, unbounded
upwind First order, bounded
linearUpwind First/second order, bounded
QUICK First/second order, bounded
TVD schemes First/second order, bounded
SFCD Second order, bounded
NVD schemes First/second order, bounded
Table 4.10: Behaviour of interpolation schemes used in divSchemes.
4.4.6 Time schemes
The ﬁrst time derivative (∂/∂t) terms are speciﬁed in the ddtSchemes sub-dictionary. The
discretisation scheme for each term can be selected from those listed in Table 4.11.
There is an oﬀ-centering coeﬃcient ψ with the CrankNicholson scheme that blends
it with the Euler scheme. A coeﬃcient of ψ = 1 corresponds to pure CrankNicholson
and and ψ = 0 corresponds to pure Euler. The blending coeﬃcient can help to improve
stability in cases where pure CrankNicholson are unstable.
Scheme Description
Euler First order, bounded, implicit
CrankNicholson ψ Second order, bounded, implicit
backward Second order, implicit
steadyState Does not solve for time derivatives
Table 4.11: Discretisation schemes available in ddtSchemes.
When specifying a time scheme it must be noted that an application designed for
transient problems will not necessarily run as steady-state and visa versa. For example
the solution will not converge if steadyState is speciﬁed when running icoFoam, the
transient, laminar incompressible ﬂow code; rather, simpleFoam should be used for steady-
state, incompressible ﬂow.
Any second time derivative (∂2
/∂t2
) terms are speciﬁed in the d2dt2Schemes sub-
dictionary. Only the Euler scheme is available for d2dt2Schemes.
Open∇FOAM-1.6
4.5 Solution and algorithm control U-117
4.4.7 Flux calculation
The ﬂuxRequired sub-dictionary lists the ﬁelds for which the ﬂux is generated in the
application. For example, in many ﬂuid dynamics applications the ﬂux is generated after
solving a pressure equation, in which case the ﬂuxRequired sub-dictionary would simply
be entered as follows, p being the word identiﬁer for pressure:
fluxRequired
{
p;
}
4.5 Solution and algorithm control
The equation solvers, tolerances and algorithms are controlled from the fvSolution dic-
tionary in the system directory. Below is an example set of entries from the fvSolution
dictionary required for the icoFoam solver.
17
18 solvers
19 {
20 p
21 {
22 solver PCG;
23 preconditioner DIC;
24 tolerance 1e-06;
25 relTol 0;
26 }
27
28 U
29 {
30 solver PBiCG;
31 preconditioner DILU;
32 tolerance 1e-05;
33 relTol 0;
34 }
35 }
36
37 PISO
38 {
39 nCorrectors 2;
40 nNonOrthogonalCorrectors 0;
41 pRefCell 0;
42 pRefValue 0;
43 }
44
45
46 // ************************************************************************* //
fvSolution contains a set of subdictionaries that are speciﬁc to the solver being run. How-
ever, there is a small set of standard subdictionaries that cover most of those used by
the standard solvers. These subdictionaries include solvers, relaxationFactors, PISO and
SIMPLE which are described in the remainder of this section.
4.5.1 Linear solver control
The ﬁrst sub-dictionary in our example, and one that appears in all solver applications,
is solvers. It speciﬁes each linear-solver that is used for each discretised equation; it
is emphasised that the term linear-solver refers to the method of number-crunching to
solve the set of linear equations, as opposed to application solver which describes the set
of equations and algorithms to solve a particular problem. The term ‘linear-solver’ is
abbreviated to ‘solver’ in much of the following discussion; we hope the context of the
term avoids any ambiguity.
Open∇FOAM-1.6
U-118 OpenFOAM cases
The syntax for each entry within solvers uses a keyword that is the word relating to the
variable being solved in the particular equation. For example, icoFoam solves equations
for velocity U and pressure p, hence the entries for U and p. The keyword is followed
by a dictionary containing the type of solver and the parameters that the solver uses.
The solver is selected through the solver keyword from the choice in OpenFOAM, listed
in Table 4.12. The parameters, including tolerance, relTol, preconditioner, etc. are
described in following sections.
Solver Keyword
Preconditioned (bi-)conjugate gradient PCG/PBiCG†
Solver using a smoother smoothSolver
Generalised geometric-algebraic multi-grid GAMG
†PCG for symmetric matrices, PBiCG for asymmetric
Table 4.12: Linear solvers.
The solvers distinguish between symmetric matrices and asymmetric matrices. The
symmetry of the matrix depends on the structure of the equation being solved and, while
the user may be able to determine this, it is not essential since OpenFOAM will produce
an error message to advise the user if an inappropriate solver has been selected, e.g.
--> FOAM FATAL IO ERROR : Unknown asymmetric matrix solver PCG
Valid asymmetric matrix solvers are :
3
(
PBiCG
smoothSolver
GAMG
)
4.5.1.1 Solution tolerances
The sparse matrix solvers are iterative, i.e. they are based on reducing the equation
residual over a succession of solutions. The residual is ostensibly a measure of the error
in the solution so that the smaller it is, the more accurate the solution. More precisely,
the residual is evaluated by substituting the current solution into the equation and taking
the magnitude of the diﬀerence between the left and right hand sides; it is also normalised
in to make it independent of the scale of problem being analysed.
Before solving an equation for a particular ﬁeld, the initial residual is evaluated based
on the current values of the ﬁeld. After each solver iteration the residual is re-evaluated.
The solver stops if either of the following conditions are reached:
• the residual falls below the solver tolerance, tolerance;
• the ratio of current to initial residuals falls below the solver relative tolerance,
relTol;
The solver tolerance should represents the level at which the residual is small enough
that the solution can be deemed suﬃciently accurate. The solver relative tolerance limits
the relative improvement from initial to ﬁnal solution. It is quite common to set the
solver relative tolerance to 0 to force the solution to converge to the solver tolerance. The
tolerances, tolerance and relTol must be speciﬁed in the dictionaries for all solvers.
Open∇FOAM-1.6
4.5 Solution and algorithm control U-119
4.5.1.2 Preconditioned conjugate gradient solvers
There are a range of options for preconditioning of matrices in the conjugate gradient
solvers, represented by the preconditioner keyword in the solver dictionary. The pre-
conditioners are listed in Table 4.13.
Preconditioner Keyword
Diagonal incomplete-Cholesky (symmetric) DIC
Faster diagonal incomplete-Cholesky (DIC with caching) FDIC
Diagonal incomplete-LU (asymmetric) DILU
Diagonal diagonal
Geometric-algebraic multi-grid GAMG
No preconditioning none
Table 4.13: Preconditioner options.
4.5.1.3 Smooth solvers
The solvers that use a smoother require the smoother to be speciﬁed. The smoother op-
tions are listed in Table 4.14. Generally GaussSeidel is the most reliable option, but for
bad matrices DIC can oﬀer better convergence. In some cases, additional post-smoothing
using GaussSeidel is further beneﬁcial, i.e. the method denoted as DICGaussSeidel
Smoother Keyword
Gauss-Seidel GaussSeidel
Diagonal incomplete-Cholesky (symmetric) DIC
Diagonal incomplete-Cholesky with Gauss-Seidel (symmetric) DICGaussSeidel
Table 4.14: Smoother options.
The user must also pecify the number of sweeps, by the nSweeps keyword, before the
residual is recalculated, following the tolerance parameters.
4.5.1.4 Geometric-algebraic multi-grid solvers
The generalised method of geometric-algebraic multi-grid (GAMG) uses the principle of:
generating a quick solution on a mesh with a small number of cells; mapping this solution
onto a ﬁner mesh; using it as an initial guess to obtain an accurate solution on the ﬁne
mesh. GAMG is faster than standard methods when the increase in speed by solving ﬁrst
on coarser meshes outweighs the additional costs of mesh reﬁnement and mapping of ﬁeld
data. In practice, GAMG starts with the mesh speciﬁed by the user and coarsens/reﬁnes
the mesh in stages. The user is only required to specify an approximate mesh size at the
most coarse level in terms of the number of cells nCoarsestCells.
The agglomeration of cells is performed by the algorithm speciﬁed by the agglomerator
keyword. Presently we recommend the faceAreaPair method. It is worth noting there is
an MGridGen option that requires an additional entry specifying the shared object library
for MGridGen:
geometricGamgAgglomerationLibs ("libMGridGenGamgAgglomeration.so");
Open∇FOAM-1.6
U-120 OpenFOAM cases
In the experience of OpenCFD, the MGridGen method oﬀers no obvious beneﬁt over the
faceAreaPair method. For all methods, agglomeration can be optionally cached by the
cacheAgglomeration switch.
Smoothing is speciﬁed by the smoother as described in section 4.5.1.3. The number
of sweeps used by the smoother at diﬀerent levels of mesh density are speciﬁed by the
nPreSweeps, nPostSweeps and nFinestSweeps keywords. The nPreSweeps entry is used
as the algorithm is coarsening the mesh, nPostSweeps is used as the algorithm is reﬁning,
and nFinestSweeps is used when the solution is at its ﬁnest level.
The mergeLevels keyword controls the speed at which coarsening or reﬁnement levels
is performed. It is often best to do so only at one level at a time, i.e. set mergeLevels
1. In some cases, particularly for simple meshes, the solution can be safely speeded up
by coarsening/reﬁning two levels at a time, i.e. setting mergeLevels 2.
4.5.2 Solution under-relaxation
A second sub-dictionary of fvSolution that is often used in OpenFOAM is relaxationFactors
which controls under-relaxation, a technique used for improving stability of a computa-
tion, particularly in solving steady-state problems. Under-relaxation works by limiting
the amount which a variable changes from one iteration to the next, either by modifying
the solution matrix and source prior to solving for a ﬁeld or by modifying the ﬁeld di-
rectly. An under-relaxation factor α, 0 < α ≤ 1 speciﬁes the amount of under-relaxation,
ranging from none at all for α = 1 and increasing in strength as α → 0. The limiting case
where α = 0 represents a solution which does not change at all with successive iterations.
An optimum choice of α is one that is small enough to ensure stable computation but
large enough to move the iterative process forward quickly; values of α as high as 0.9
can ensure stability in some cases and anything much below, say, 0.2 are prohibitively
restrictive in slowing the iterative process.
The user can specify the relaxation factor for a particular ﬁeld by specifying ﬁrst the
word associated with the ﬁeld, then the factor. The user can view the relaxation factors
used in a tutorial example of simpleFoam for incompressible, laminar, steady-state ﬂows.
17
18 solvers
19 {
20 p
21 {
22 solver PCG;
23 preconditioner DIC;
24 tolerance 1e-06;
25 relTol 0.01;
26 }
27
28 U
29 {
30 solver PBiCG;
31 preconditioner DILU;
32 tolerance 1e-05;
33 relTol 0.1;
34 }
35
36 k
37 {
38 solver PBiCG;
39 preconditioner DILU;
40 tolerance 1e-05;
41 relTol 0.1;
42 }
43
44 epsilon
45 {
46 solver PBiCG;
47 preconditioner DILU;
48 tolerance 1e-05;
49 relTol 0.1;
50 }
Open∇FOAM-1.6
4.5 Solution and algorithm control U-121
51
52 R
53 {
54 solver PBiCG;
55 preconditioner DILU;
56 tolerance 1e-05;
57 relTol 0.1;
58 }
59
60 nuTilda
61 {
62 solver PBiCG;
63 preconditioner DILU;
64 tolerance 1e-05;
65 relTol 0.1;
66 }
67 }
68
69 SIMPLE
70 {
71 nNonOrthogonalCorrectors 0;
72 }
73
74 relaxationFactors
75 {
76 p 0.3;
77 U 0.7;
78 k 0.7;
79 epsilon 0.7;
80 R 0.7;
81 nuTilda 0.7;
82 }
83
84
85 // ************************************************************************* //
4.5.3 PISO and SIMPLE algorithms
Most ﬂuid dynamics solver applications in OpenFOAM use the pressure-implicit split-
operator (PISO) or semi-implicit method for pressure-linked equations (SIMPLE) algo-
rithms. These algorithms are iterative procedures for solving equations for velocity and
pressure, PISO being used for transient problems and SIMPLE for steady-state.
Both algorithms are based on evaluating some initial solutions and then correcting
them. SIMPLE only makes 1 correction whereas PISO requires more than 1, but typically
not more than 4. The user must therefore specify the number of correctors in the PISO
dictionary by the nCorrectors keyword as shown in the example on page U-117.
An additional correction to account for mesh non-orthogonality is available in both
SIMPLE and PISO in the standard OpenFOAM solver applications. A mesh is orthogonal
if, for each face within it, the face normal is parallel to the vector between the centres of
the cells that the face connects, e.g. a mesh of hexahedral cells whose faces are aligned
with a Cartesian coordinate system. The number of non-orthogonal correctors is speciﬁed
by the nNonOrthogonalCorrectors keyword as shown in the examples above and on
page U-117. The number of non-orthogonal correctors should correspond to the mesh for
the case being solved, i.e. 0 for an orthogonal mesh and increasing with the degree of
non-orthogonality up to, say, 20 for the most non-orthogonal meshes.
4.5.3.1 Pressure referencing
In a closed incompressible system, pressure is relative: it is the pressure range that matters
not the absolute values. In these cases, the solver sets a reference level of pRefValue in
cell pRefCell where p is the name of the pressure solution variable. Where the pressure
is pd, the names are pdRefValue and pdRefCell respectively. These entries are generally
stored in the PISO/SIMPLE sub-dictionary and are used by those solvers that require
them when the case demands it. If ommitted, the solver will not run, but give a message
to alert the user to the problem.
Open∇FOAM-1.6
U-122 OpenFOAM cases
4.5.4 Other parameters
The fvSolutions dictionaries in the majority of standard OpenFOAM solver applications
contain no other entries than those described so far in this section. However, in general
the fvSolution dictionary may contain any parameters to control the solvers, algorithms,
or in fact anything. For a given solver, the user can look at the source code to ﬁnd the
parameters required. Ultimately, if any parameter or sub-dictionary is missing when an
solver is run, it will terminate, printing a detailed error message. The user can then add
missing parameters accordingly.
Open∇FOAM-1.6
Chapter 5
Mesh generation and conversion
This chapter describes all topics relating to the creation of meshes in OpenFOAM:
section 5.1 gives an overview of the ways a mesh may be described in OpenFOAM;
section 5.3 covers the blockMesh utility for generating simple meshes of blocks of hex-
ahedral cells; section 5.4 covers the snappyHexMesh utility for generating complex meshes
of hexahedral and split-hexahedral cells automatically from triangulated surface geome-
tries; section 5.5 describes the options available for conversion of a mesh that has been
generated by a third-party product into a format that OpenFOAM can read.
5.1 Mesh description
This section provides a speciﬁcation of the way the OpenFOAM C++ classes handle a
mesh. The mesh is an integral part of the numerical solution and must satisfy certain
criteria to ensure a valid, and hence accurate, solution. During any run, OpenFOAM
checks that the mesh satisﬁes a fairly stringent set of validity constraints and will cease
running if the constraints are not satisﬁed. The consequence is that a user may experience
some frustration in ‘correcting’ a large mesh generated by third-party mesh generators
before OpenFOAM will run using it. This is unfortunate but we make no apology for
OpenFOAM simply adopting good practice to ensure the mesh is valid; otherwise, the
solution is ﬂawed before the run has even begun.
By default OpenFOAM deﬁnes a mesh of arbitrary polyhedral cells in 3-D, bounded
by arbitrary polygonal faces, i.e. the cells can have an unlimited number of faces where,
for each face, there is no limit on the number of edges nor any restriction on its alignment.
A mesh with this general structure is known in OpenFOAM as a polyMesh. It is described
in further detail in section 2.3 of the Programmer’s Guide, but it is suﬃcient to mention
here that this type of mesh oﬀers great freedom in mesh generation and manipulation
in particular when the geometry of the domain is complex or changes over time. The
price of absolute mesh generality is, however, that it can be diﬃcult to convert meshes
generated using conventional tools. The OpenFOAM library therefore provides cellShape
tools to manage conventional mesh formats based on sets of pre-deﬁned cell shapes.
5.1.1 Mesh speciﬁcation and validity constraints
Before describing the OpenFOAM mesh format, polyMesh, and the cellShape tools, we
will ﬁrst set out the validity constraints used in OpenFOAM. The conditions that a mesh
must satisfy are:
U-124 Mesh generation and conversion
5.1.1.1 Points
A point is a location in 3-D space, deﬁned by a vector in units of metres (m). The points
are compiled into a list and each point is referred to by a label, which represents its
position in the list, starting from zero. The point list cannot contain two diﬀerent points
at an exactly identical position nor any point that is not part at least one face.
5.1.1.2 Faces
A face is an ordered list of points, where a point is referred to by its label. The ordering
of point labels in a face is such that each two neighbouring points are connected by an
edge, i.e. you follow points as you travel around the circumference of the face. Faces are
compiled into a list and each face is referred to by its label, representing its position in
the list. The direction of the face normal vector is deﬁned by the right-hand rule, i.e.
looking towards a face, if the numbering of the points follows an anti-clockwise path, the
normal vector points towards you, as shown in Figure 5.1.
4
3
0
2
1
Sf
Figure 5.1: Face area vector from point numbering on the face
There are two types of face:
Internal faces Those faces that connect two cells (and it can never be more than two).
For each internal face, the ordering of the point labels is such that the face normal
points into the cell with the larger label, i.e. for cells 2 and 5, the normal points
into 5;
Boundary faces Those belonging to one cell since they coincide with the boundary
of the domain. A boundary face is therefore addressed by one cell(only) and a
boundary patch. The ordering of the point labels is such that the face normal
points outside of the computational domain.
Faces are generally expected to be convex; at the very least the face centre needs to
be inside the face. Faces are allowed to be warped, i.e. not all points of the face need to
be coplanar.
5.1.1.3 Cells
A cell is a list of faces in arbitrary order. Cells must have the properties listed below.
Contiguous The cells must completely cover the computational domain and are must
not overlap one another.
Open∇FOAM-1.6
5.1 Mesh description U-125
Convex Every cell must be convex and its cell centre inside the cell.
Closed Every cell must be closed, both geometrically and topologically where:
• geometrical closedness requires that when all face area vectors are oriented to
point outwards of the cell, their sum should equal the zero vector to machine
accuracy;
• topological closedness requires that all the edges in a cell are used by exactly
two faces of the cell in question.
Orthogonality For all internal faces of the mesh, we deﬁne the centre-to-centre vector
as that connecting the centres of the 2 cells that it adjoins oriented from the the
centre of the cell with smaller label to the centre of the cell with larger label. The
orthogonality constraint requires that for each internal face, the angle between the
face area vector, oriented as described above, and the centre-to-centre vector must
always be less than 90◦
.
5.1.1.4 Boundary
A boundary is a list of patches, each of which is associated with a boundary condition.
A patch is a list of face labels which clearly must contain only boundary faces and no
internal faces. The boundary is required to be closed, i.e. the sum all boundary face area
vectors equates to zero to machine tolerance.
5.1.2 The polyMesh description
The constant directory contains a full description of the case polyMesh in a subdirectory
polyMesh. The polyMesh description is based around faces and, as already discussed,
internal cells connect 2 cells and boundary faces address a cell and a boundary patch.
Each face is therefore assigned an ‘owner’ cell and ‘neighbour’ cell so that the connectivity
across a given face can simply be described by the owner and neighbour cell labels. In
the case of boundaries, the connected cell is the owner and the neighbour is assigned the
label ‘-1’. With this in mind, the I/O speciﬁcation consists of the following ﬁles:
points a list of vectors describing the cell vertices, where the ﬁrst vector in the list repre-
sents vertex 0, the second vector represents vertex 1, etc.;
faces a list of faces, each face being a list of indices to vertices in the points list, where
again, the ﬁrst entry in the list represents face 0, etc.;
owner a list of owner cell labels, the index of entry relating directly to the index of the
face, so that the ﬁrst entry in the list is the owner label for face 0, the second entry
is the owner label for face 1, etc;
neighbour a list of neighbour cell labels;
boundary a list of patches, containing a dictionary entry for each patch, declared using
the patch name, e.g.
movingWall
{
type patch;
nFaces 20;
startFace 760;
Open∇FOAM-1.6
U-126 Mesh generation and conversion
}
The startFace is the index into the face list of the ﬁrst face in the patch, and
nFaces is the number of faces in the patch.
Note that if the user wishes to know how many cells are in their domain, there is a
note in the FoamFile header of the owner ﬁle that contains an entry for nCells.
5.1.3 The cellShape tools
We shall describe the alternative cellShape tools that may be used particularly when
converting some standard (simpler) mesh formats for the use with OpenFOAM library.
The vast majority of mesh generators and post-processing systems support only a
fraction of the possible polyhedral cell shapes in existence. They deﬁne a mesh in terms
of a limited set of 3D cell geometries, referred to as cell shapes. The OpenFOAM library
contains deﬁnitions of these standard shapes, to enable a conversion of such a mesh into
the polyMesh format described in the previous section.
The cellShape models supported by OpenFOAM are shown in Table 5.1. The shape is
deﬁned by the ordering of point labels in accordance with the numbering scheme contained
in the shape model. The ordering schemes for points, faces and edges are shown in
Table 5.1. The numbering of the points must not be such that the shape becomes twisted
or degenerate into other geometries, i.e. the same point label cannot be used more that
once is a single shape. Moreover it is unnecessary to use duplicate points in OpenFOAM
since the available shapes in OpenFOAM cover the full set of degenerate hexahedra.
The cell description consists of two parts: the name of a cell model and the ordered
list of labels. Thus, using the following list of points
8
(
(0 0 0)
(1 0 0)
(1 1 0)
(0 1 0)
(0 0 0.5)
(1 0 0.5)
(1 1 0.5)
(0 1 0.5)
)
A hexahedral cell would be written as:
(hex 8(0 1 2 3 4 5 6 7))
Here the hexahedral cell shape is declared using the keyword hex. Other shapes are
described by the keywords listed in Table 5.1.
5.1.4 1- and 2-dimensional and axi-symmetric problems
OpenFOAM is designed as a code for 3-dimensional space and deﬁnes all meshes as
such. However, 1- and 2- dimensional and axi-symmetric problems can be simulated
in OpenFOAM by generating a mesh in 3 dimensions and applying special boundary
conditions on any patch in the plane(s) normal to the direction(s) of interest. More
speciﬁcally, 1- and 2- dimensional problems use the empty patch type and axi-symmetric
problems use the wedge type. The use of both are described in section 5.2.2 and the
generation of wedge geometries for axi-symmetric problems is discussed in section 5.3.3.
Open∇FOAM-1.6
5.2 Boundaries U-127
Cell type Keyword Vertex numbering Face numbering Edge numbering
Hexahedron hex
2
7
3
10
4
6
5
0 1
2
3
5
4
0
1
2
3
4
5
6
7
8 9
1011
Wedge wedge
2
10
3 4
56
0
1
2
35
4
0
1
2
3
5
6
7
8
9
10
4
Prism prism
2
10
3 4
5
0
1
3
4
2
0
1
2
3
4
5
6 7
8
Pyramid pyr
2
10
4
3
0
2
34
1
0
1
2
3
4 5
67
Tetrahedron tet 0 1
2
3
1
2
3
0
0
1
2
3
4
5
Tet-wedge tetWedge
2
10
3 4
0
1
3
2
0
1
2
3
4
5
6
Table 5.1: Vertex, face and edge numbering for cellShapes.
Open∇FOAM-1.6
U-128 Mesh generation and conversion
5.2 Boundaries
In this section we discuss the way in which boundaries are treated in OpenFOAM. The
subject of boundaries is a little involved because their role in modelling is not simply that
of a geometric entity but an integral part of the solution and numerics through boundary
conditions or inter-boundary ‘connections’. A discussion of boundaries sits uncomfortably
between a discussion on meshes, ﬁelds, discretisation, computational processing etc. Its
placement in this Chapter on meshes is a choice of convenience.
We ﬁrst need to consider that, for the purpose of applying boundary conditions, a
boundary is generally broken up into a set of patches. One patch may include one or
more enclosed areas of the boundary surface which do not necessarily need to be physically
connected.
There are three attributes associated with a patch that are described below in their
natural hierarchy and Figure 5.2 shows the names of diﬀerent patch types introduced
at each level of the hierarchy. The hierarchy described below is very similar, but not
identical, to the class hierarchy used in the OpenFOAM library.
Base type The type of patch described purely in terms of geometry or a data ‘commu-
nication link’.
Primitive type The base numerical patch condition assigned to a ﬁeld variable on the
patch.
Derived type A complex patch condition, derived from the primitive type, assigned to
a ﬁeld variable on the patch.
Derived type
ﬁxedGradient
ﬁxedValue
Primitive type
calculated
mixed
directionMixed
zeroGradient
symmetry
empty
wedge
cyclicBase type
processor
patch
wall
e.g.inletOutlet
Figure 5.2: Patch attributes
5.2.1 Speciﬁcation of patch types in OpenFOAM
The patch types are speciﬁed in the mesh and ﬁeld ﬁles of a OpenFOAM case. More
precisely:
• the base type is speciﬁed under the type keyword for each patch in the boundary
ﬁle, located in the constant/polyMesh directory;
Open∇FOAM-1.6
5.2 Boundaries U-129
• the numerical patch type, be it a primitive or derived type, is speciﬁed under the
type keyword for each patch in a ﬁeld ﬁle.
An example boundary ﬁle is shown below for a sonicFoam case, followed by a pressure
ﬁeld ﬁle, p, for the same case:
17
18 6
19 (
20 inlet
21 {
22 type patch;
23 nFaces 50;
24 startFace 10325;
25 }
26 outlet
27 {
28 type patch;
29 nFaces 40;
30 startFace 10375;
31 }
32 bottom
33 {
34 type symmetryPlane;
35 nFaces 25;
36 startFace 10415;
37 }
38 top
39 {
40 type symmetryPlane;
41 nFaces 125;
42 startFace 10440;
43 }
44 obstacle
45 {
46 type patch;
47 nFaces 110;
48 startFace 10565;
49 }
50 defaultFaces
51 {
52 type empty;
53 nFaces 10500;
54 startFace 10675;
55 }
56 )
57
58 // ************************************************************************* //
17 dimensions [1 -1 -2 0 0 0 0];
18
19 internalField uniform 1;
20
21 boundaryField
22 {
23 inlet
24 {
25 type fixedValue;
26 value uniform 1;
27 }
28
29 outlet
30 {
31 type waveTransmissive;
32 field p;
33 phi phi;
34 rho rho;
35 psi psi;
36 gamma 1.4;
37 fieldInf 1;
38 lInf 3;
39 value uniform 1;
40 }
41
42 bottom
43 {
44 type symmetryPlane;
45 }
46
47 top
48 {
49 type symmetryPlane;
50 }
Open∇FOAM-1.6
U-130 Mesh generation and conversion
51
52 obstacle
53 {
54 type zeroGradient;
55 }
56
57 defaultFaces
58 {
59 type empty;
60 }
61 }
62
63 // ************************************************************************* //
The type in the boundary ﬁle is patch for all patches except those that patches that have
some geometrical constraint applied to them, i.e. the symmetryPlane and empty patches.
The p ﬁle includes primitive types applied to the inlet and bottom faces, and a more
complex derived type applied to the outlet. Comparison of the two ﬁles shows that the
base and numerical types are consistent where the base type is not a simple patch, i.e.
for the symmetryPlane and empty patches.
5.2.2 Base types
The base and geometric types are described below; the keywords used for specifying these
types in OpenFOAM are summarised in Table 5.2.
wedge aligned along
coordinate plane
5◦ Axis of symmetry
wedge patch 1
wedge patch 2
Figure 5.3: Axi-symmetric geometry using the wedge patch type.
Selection Key Description
patch generic patch
symmetryPlane plane of symmetry
empty front and back planes of a 2D geometry
wedge wedge front and back for an axi-symmetric geometry
cyclic cyclic plane
wall wall — used for wall functions in turbulent ﬂows
processor inter-processor boundary
Table 5.2: Basic patch types.
Open∇FOAM-1.6
5.2 Boundaries U-131
patch The basic patch type for a patch condition that contains no geometric or topological
information about the mesh (with the exception of wall), e.g. an inlet or an outlet.
wall There are instances where a patch that coincides with a wall needs to be identiﬁable
as such, particularly where specialist modelling is applied at wall boundaries. A
good example is wall turbulence modelling where a wall must be speciﬁed with a
wall patch type, so that the distance from the wall of the cell centres next to the
wall are stored as part of the patch.
symmetryPlane For a symmetry plane.
empty While OpenFOAM always generates geometries in 3 dimensions, it can be in-
structed to solve in 2 (or 1) dimensions by specifying a special empty condition on
each patch whose plane is normal to the 3rd (and 2nd) dimension for which no
solution is required.
wedge For 2 dimensional axi-symmetric cases, e.g. a cylinder, the geometry is speciﬁed as
a wedge of 5◦
angle and 1 cell thick running along the plane of symmetry, straddling
one of the coordinate planes, as shown in Figure 5.3. The axi-symmetric wedge
planes must be speciﬁed as separate patches of wedge type. The details of generating
wedge-shaped geometries using blockMesh are described in section 5.3.3.
cyclic Enables two patches to be treated as if they are physically connected; used for
repeated geometries, e.g. heat exchanger tube bundles. A single cyclic patch splits
the faces in its faceList into two, and links the two sets of faces as shown in Figure 5.4.
Each face-face pair must be of the same area but the faces do not need to be of the
same orientation.
processor If a code is being run in parallel, on a number of processors, then the mesh
must be divided up so that each processor computes on roughly the same number
of cells. The boundaries between the diﬀerent parts of the mesh are called processor
boundaries.
2
3
1
1
2
3
faceList
4
5
6
4
5
6
cyclic
Repeated geometry
computational links
Figure 5.4: Repeated geometry using the cyclic patch type.
Open∇FOAM-1.6
U-132 Mesh generation and conversion
5.2.3 Primitive types
The primitive types are listed in Table 5.3.
Type Description of condition for patch ﬁeld φ Data to specify
ﬁxedValue Value of φ is speciﬁed value
ﬁxedGradient Normal gradient of φ is speciﬁed gradient
zeroGradient Normal gradient of φ is zero —
calculated Boundary ﬁeld φ derived from other ﬁelds —
mixed Mixed ﬁxedValue/ ﬁxedGradient condition depend-
ing on the value in valueFraction
refValue,
refGradient,
valueFraction,
value
directionMixed A mixed condition normal to the patch with a
ﬁxedGradient condition tangential to the patch
refValue,
refGradient,
valueFraction,
value
Table 5.3: Primitive patch ﬁeld types.
5.2.4 Derived types
There are numerous derived types of boundary conditions in OpenFOAM, too many to
list here. Instead a small selection is listed in Table 5.4. If the user wishes to obtain
a list of all available model, they should consult the OpenFOAM source code. Derived
boundary condition source code can be found at the following locations:
• in $FOAM SRC/ﬁniteVolume/ﬁelds/fvPatchFields/derived
• within certain model libraries, that can be located by typing the following command
in a terminal window
find $FOAM SRC -name "*derivedFvPatch*"
• within certain solvers, that can be located by typing the following command in a
terminal window
find $FOAM SOLVERS -name "*fvPatch*"
5.3 Mesh generation with the blockMesh utility
This section describes the mesh generation utility, blockMesh, supplied with OpenFOAM.
The blockMesh utility creates parametric meshes with grading and curved edges.
The mesh is generated from a dictionary ﬁle named blockMeshDict located in the
constant/polyMesh directory of a case. blockMesh reads this dictionary, generates the
mesh and writes out the mesh data to points and faces, cells and boundary ﬁles in the
same directory.
The principle behind blockMesh is to decompose the domain geometry into a set of 1
or more three dimensional, hexahedral blocks. Edges of the blocks can be straight lines,
Open∇FOAM-1.6
5.3MeshgenerationwiththeblockMeshutilityU-133
Types derived from ﬁxedValue Data to specify
movingWallVelocity Replaces the normal of the patch value so the ﬂux across the patch is zero value
pressureInletVelocity When p is known at inlet, U is evaluated from the ﬂux, normal to the patch value
pressureDirectedInletVelocityWhen p is known at inlet, U is calculated from the ﬂux in the inletDirection value,
inletDirection
surfaceNormalFixedValue Speciﬁes a vector boundary condition, normal to the patch, by its magnitude; +ve
for vectors pointing out of the domain
value
totalPressure Total pressure p0 = p + 1
2
ρ|U|2
is ﬁxed; when U changes, p is adjusted accordingly p0
turbulentInlet Calculates a ﬂuctuating variable based on a scale of a mean value referenceField,
fluctuationScale
Types derived from ﬁxedGradient/zeroGradient
ﬂuxCorrectedVelocity Calculates normal component of U at inlet from ﬂux value
wallBuoyantPressure Sets ﬁxedGradient pressure based on the atmospheric pressure gradient —
Types derived from mixed
inletOutlet Switches U and p between ﬁxedValue and zeroGradient depending on direction of U inletValue, value
outletInlet Switches U and p between ﬁxedValue and zeroGradient depending on direction of U outletValue,
value
pressureInletOutletVelocity Combination of pressureInletVelocity and inletOutlet value
pressureDirected-
InletOutletVelocity
Combination of pressureDirectedInletVelocity and inletOutlet value,
inletDirection
pressureTransmissive Transmits supersonic pressure waves to surrounding pressure p∞ pInf
supersonicFreeStream Transmits oblique shocks to surroundings at p∞, T∞, U∞ pInf, TInf, UInf
Other types
slip zeroGradient if φ is a scalar; if φ is a vector, normal component is ﬁxedValue zero,
tangential components are zeroGradient
—
partialSlip Mixed zeroGradient/ slip condition depending on the valueFraction; = 1 for slip valueFraction
Note: p is pressure, U is velocity
Table 5.4: Derived patch ﬁeld types.
Open∇FOAM-1.6
U-134 Mesh generation and conversion
arcs or splines. The mesh is ostensibly speciﬁed as a number of cells in each direction of
the block, suﬃcient information for blockMesh to generate the mesh data.
Each block of the geometry is deﬁned by 8 vertices, one at each corner of a hexahedron.
The vertices are written in a list so that each vertex can be accessed using its label,
remembering that OpenFOAM always uses the C++ convention that the ﬁrst element of
the list has label ‘0’. An example block is shown in Figure 5.5 with each vertex numbered
according to the list. The edge connecting vertices 1 and 5 is curved to remind the reader
that curved edges can be speciﬁed in blockMesh.
It is possible to generate blocks with less than 8 vertices by collapsing one or more
pairs of vertices on top of each other, as described in section 5.3.3.
Each block has a local coordinate system (x1, x2, x3) that must be right-handed. A
right-handed set of axes is deﬁned such that to an observer looking down the Oz axis,
with O nearest them, the arc from a point on the Ox axis to a point on the Oy axis is in
a clockwise sense.
The local coordinate system is deﬁned by the order in which the vertices are presented
in the block deﬁnition according to:
• the axis origin is the ﬁrst entry in the block deﬁnition, vertex 0 in our example;
• the x1 direction is described by moving from vertex 0 to vertex 1;
• the x2 direction is described by moving from vertex 1 to vertex 2;
• vertices 0, 1, 2, 3 deﬁne the plane x3 = 0;
• vertex 4 is found by moving from vertex 0 in the x3 direction;
• vertices 5,6 and 7 are similarly found by moving in the x3 direction from vertices
1,2 and 3 respectively.
3
9
1
2
x2
x3
x10
3
4
5
7 6
0
2
1
4 5
6
7
10
8
11
Figure 5.5: A single block
5.3.1 Writing a blockMeshDict ﬁle
The blockMeshDict ﬁle is a dictionary using keywords described in Table 5.5. The convertToMeters
keyword speciﬁes a scaling factor by which all vertex coordinates in the mesh description
are multiplied. For example,
Open∇FOAM-1.6
5.3 Mesh generation with the blockMesh utility U-135
Keyword Description Example/selection
convertToMeters Scaling factor for the vertex
coordinates
0.001 scales to mm
vertices List of vertex coordinates (0 0 0)
edges Used to describe arc or
spline edges
arc 1 4 (0.939 0.342 -0.5)
block Ordered list of vertex labels
and mesh size
hex (0 1 2 3 4 5 6 7)
(10 10 1)
simpleGrading (1.0 1.0 1.0)
patches List of patches symmetryPlane base
( (0 1 2 3) )
mergePatchPairs List of patches to be merged see section 5.3.2
Table 5.5: Keywords used in blockMeshDict.
convertToMeters 0.001;
means that all coordinates are multiplied by 0.001, i.e. the values quoted in the blockMesh-
Dict ﬁle are in mm.
5.3.1.1 The vertices
The vertices of the blocks of the mesh are given next as a standard list named vertices,
e.g. for our example block in Figure 5.5, the vertices are:
vertices
(
( 0 0 0 ) // vertex number 0
( 1 0 0.1) // vertex number 1
( 1.1 1 0.1) // vertex number 2
( 0 1 0.1) // vertex number 3
(-0.1 -0.1 1 ) // vertex number 4
( 1.3 0 1.2) // vertex number 5
( 1.4 1.1 1.3) // vertex number 6
( 0 1 1.1) // vertex number 7
);
5.3.1.2 The edges
Each edge joining 2 vertex points is assumed to be straight by default. However any edge
may be speciﬁed to be curved by entries in a list named edges. The list is optional; if
the geometry contains no curved edges, it may be omitted.
Each entry for a curved edge begins with a keyword specifying the type of curve from
those listed in Table 5.6.
The keyword is then followed by the labels of the 2 vertices that the edge connects.
Following that, interpolation points must be speciﬁed through which the edge passes.
For a arc, a single interpolation point is required, which the circular arc will intersect.
For simpleSpline, polyLine and polySpline, a list of interpolation points is required.
The line edge is directly equivalent to the option executed by default, and requires no
Open∇FOAM-1.6
U-136 Mesh generation and conversion
Keyword selection Description Additional entries
arc Circular arc Single interpolation point
simpleSpline Spline curve List of interpolation points
polyLine Set of lines List of interpolation points
polySpline Set of splines List of interpolation points
line Straight line —
Table 5.6: Edge types available in the blockMeshDict dictionary.
interpolation points. Note that there is no need to use the line edge but it is included
for completeness. For our example block in Figure 5.5 we specify an arc edge connecting
vertices 1 and 5 as follows through the interpolation point (1.1, 0.0, 0.5):
edges
(
arc 1 5 (1.1 0.0 0.5)
);
5.3.1.3 The blocks
The block deﬁnitions are contained in a list named blocks. Each block deﬁnition is a
compound entry consisting of a list of vertex labels whose order is described in section 5.3,
a vector giving the number of cells required in each direction, the type and list of cell
expansion ratio in each direction.
Then the blocks are deﬁned as follows:
blocks
(
hex (0 1 2 3 4 5 6 7) // vertex numbers
(10 10 10) // numbers of cells in each direction
simpleGrading (1 2 3) // cell expansion ratios
);
The deﬁnition of each block is as follows:
Vertex numbering The ﬁrst entry is the is the shape identiﬁer of the block, as deﬁned
in the .OpenFOAM-1.6/cellModels ﬁle. The shape is always hex since the blocks are
always hexahedra. There follows a list of vertex numbers, ordered in the manner
described on page U-134.
Number of cells The second entry gives the number of cells in each of the x1 x2 and
x3 directions for that block.
Cell expansion ratios The third entry gives the cell expansion ratios for each direction
in the block. The expansion ratio enables the mesh to be graded, or reﬁned, in
speciﬁed directions. The ratio is that of the width of the end cell δe along one edge
of a block to the width of the start cell δs along that edge, as shown in Figure 5.6.
Each of the following keywords specify one of two types of grading speciﬁcation
available in blockMesh.
simpleGrading The simple description speciﬁes uniform expansions in the local x1,
x2 and x3 directions respectively with only 3 expansion ratios, e.g.
Open∇FOAM-1.6
5.3 Mesh generation with the blockMesh utility U-137
simpleGrading (1 2 3)
edgeGrading The full cell expansion description gives a ratio for each edge of the
block, numbered according to the scheme shown in Figure 5.5 with the arrows
representing the direction ‘from ﬁrst cell. . . to last cell’ e.g. something like
edgeGrading (1 1 1 1 2 2 2 2 3 3 3 3)
This means the ratio of cell widths along edges 0-3 is 1, along edges 4-7 is 2
and along 8-11 is 3 and is directly equivalent to the simpleGrading example
given above.
δs
Expansion ratio =
δe
δs
δe
Expansion direction
Figure 5.6: Mesh grading along a block edge
5.3.1.4 The patches
The patches of the mesh are given in a list named patches. Each patch in the list is a
compound entry containing:
• the patch type, either a generic patch on which some boundary conditions are
applied or a particular geometric condition, as listed in Table 5.2 and described in
section 5.2.2;
• a list of block faces that make up the patch and whose name is the choice of the
the user, although we recommend something that conveniently identiﬁes the patch,
e.g. quoteTextinlet; the name is used as an identiﬁer for for for setting boundary
conditions in the ﬁeld data ﬁles.
blockMesh collects faces from any boundary patch that is omitted from the patches
list and assigns them to a default patch named defaultFaces of type empty. This means
that for a 2 dimensional geometry, the user has the option to omit block faces lying in
the 2D plane, knowing that they will be collected into an empty patch as required.
Returning to the example block in Figure 5.5, if it has an inlet on the left face, an
output on the right face and the four other faces are walls then the patches could be
deﬁned as follows:
patches // keyword
(
patch // patch type for patch 0
inlet // patch name
(
(0 4 7 3) // block face in this patch
) // end of 0th patch definition
patch // patch type for patch 1
outlet // arbitrary patch name
(
(1 2 6 5)
Open∇FOAM-1.6
U-138 Mesh generation and conversion
)
wall
walls
(
(0 1 5 4)
(0 3 2 1)
(3 7 6 2)
(4 5 6 7)
)
);
Each block face is deﬁned by a list of 4 vertex numbers. The order in which the vertices
are given must be such that, looking from inside the block and starting with any vertex,
the face must be traversed in a clockwise direction to deﬁne the other vertices.
5.3.2 Multiple blocks
A mesh can be created using more than 1 block. In such circumstances, the mesh is
created as has been described in the preceeding text; the only additional issue is the
connection between blocks, in which there are two distinct possibilities:
face matching the set of faces that comprise a patch from one block are exactly collo-
cated with a set of faces patch that comprise a patch from another block;
face merging a group of faces from a patch from one block are connected to another
group of faces from a patch from another block, to create a new set of internal faces
connecting the two blocks.
To connect two blocks with face matching, the two patches that form the connection
should simply be ignored from the patches list. blockMesh then identiﬁes that the faces
do not form an external boundary and combines each collocated pair into a single internal
faces that connects cells from the two blocks.
The alternative, face merging, requires that the block patches to be merged are ﬁrst
deﬁned in the patches list. Each pair of patches whose faces are to be merged must then
be included in an optional list named mergePatchPairs. The format of mergePatchPairs
is:
mergePatchPairs
(
( <masterPatch> <slavePatch> ) // merge patch pair 0
( <masterPatch> <slavePatch> ) // merge patch pair 1
...
)
The pairs of patches are interpreted such that the ﬁrst patch becomes the master and
the second becomes the slave. The rules for merging are as follows:
• the faces of the master patch remain as originally deﬁned, with all vertices in their
original location;
• the faces of the slave patch are projected onto the master patch where there is some
separation between slave and master patch;
Open∇FOAM-1.6
5.3 Mesh generation with the blockMesh utility U-139
• the location of any vertex of a slave face might be adjusted by blockMesh to eliminate
any face edge that is shorter than a minimum tolerance;
• if patches overlap as shown in Figure 5.7, each face that does not merge remains as
an external face of the original patch, on which boundary conditions must then be
applied;
• if all the faces of a patch are merged, then the patch itself will contain no faces and
is removed.
patch 1
patch 2
region of internal connecting faces
region of external boundary faces
Figure 5.7: Merging overlapping patches
The consequence is that the original geometry of the slave patch will not necessarily be
completely preserved during merging. Therefore in a case, say, where a cylindrical block
is being connected to a larger block, it would be wise to the assign the master patch to the
cylinder, so that its cylindrical shape is correctly preserved. There are some additional
recommendations to ensure successful merge procedures:
• in 2 dimensional geometries, the size of the cells in the third dimension, i.e. out of
the 2D plane, should be similar to the width/height of cells in the 2D plane;
• it is inadvisable to merge a patch twice, i.e. include it twice in mergePatchPairs;
• where a patch to be merged shares a common edge with another patch to be merged,
both should be declared as a master patch.
5.3.3 Creating blocks with fewer than 8 vertices
It is possible to collapse one or more pair(s) of vertices onto each other in order to create
a block with fewer than 8 vertices. The most common example of collapsing vertices is
when creating a 6-sided wedge shaped block for 2-dimensional axi-symmetric cases that
use the wedge patch type described in section 5.2.2. The process is best illustrated by
using a simpliﬁed version of our example block shown in Figure 5.8. Let us say we wished
to create a wedge shaped block by collapsing vertex 7 onto 4 and 6 onto 5. This is simply
done by exchanging the vertex number 7 by 4 and 6 by 5 respectively so that the block
numbering would become:
Open∇FOAM-1.6
U-140 Mesh generation and conversion
hex (0 1 2 3 4 5 5 4)
0
3
4
7 6
5
1
2
Figure 5.8: Creating a wedge shaped block with 6 vertices
The same applies to the patches with the main consideration that the block face
containing the collapsed vertices, previously (4 5 6 7) now becomes (4 5 5 4). This
is a block face of zero area which creates a patch with no faces in the polyMesh, as the
user can see in a boundary ﬁle for such a case. The patch should be speciﬁed as empty
in the blockMeshDict and the boundary condition for any ﬁelds should consequently be
empty also.
5.3.4 Running blockMesh
As described in section 3.3, the following can be executed at the command line to run
blockMesh for a case in the <case> directory:
blockMesh -case <case>
The blockMeshDict ﬁle must exist in subdirectory constant/polyMesh.
5.4 Mesh generation with the snappyHexMesh utility
This section describes the mesh generation utility, snappyHexMesh, supplied with Open-
FOAM. The snappyHexMesh utility generates 3-dimensional meshes containing hexahedra
(hex) and split-hexahedra (split-hex) automatically from triangulated surface geometries
in Stereolithography (STL) format. The mesh approximately conforms to the surface
by iteratively reﬁning a starting mesh and morphing the resulting split-hex mesh to the
surface. An optional phase will shrink back the resulting mesh and insert cell layers. The
speciﬁcation of mesh reﬁnement level is very ﬂexible and the surface handling is robust
with a pre-speciﬁed ﬁnal mesh quality. It runs in parallel with a load balancing step every
iteration.
Open∇FOAM-1.6
5.4 Mesh generation with the snappyHexMesh utility U-141
STL surface
Figure 5.9: Schematic 2D meshing problem for snappyHexMesh
5.4.1 The mesh generation process of snappyHexMesh
The process of generating a mesh using snappyHexMesh will be described using the
schematic in Figure 5.9. The objective is to mesh a rectangular shaped region (shaded
grey in the ﬁgure) surrounding an object described by and STL surface, e.g. typical for
an external aerodynamics simulation. Note that the schematic is 2-dimensional to make
it easier to understand, even though the snappyHexMesh is a 3D meshing tool.
In order to run snappyHexMesh, the user requires the following:
• surface data ﬁles in STL format, either binary or ASCII, located in a triSurface
sub-directory of the case directory;
• a background hex mesh which deﬁnes the extent of the computational domain
and a base level mesh density; typically generated using blockMesh, discussed in
section 5.4.2.
• a snappyHexMeshDict dictionary, with appropriate entries, located in the system
sub-directory of the case.
The snappyHexMeshDict dictionary includes: switches at the top level that control the
various stages of the meshing process; and, individual sub-directories for each process.
The entries are listed in Table 5.7.
All the geometry used by snappyHexMesh is speciﬁed in a geometry sub-dictionary
in the snappyHexMeshDict dictionary. The geometry can be speciﬁed through an STL
surface or bounding geometry entities in OpenFOAM. An example is given below:
geometry
{
sphere.stl // STL filename
{
type triSurfaceMesh;
regions
{
secondSolid // Named region in the STL file
{
name mySecondPatch; // User-defined patch name
} // otherwise given sphere.stl_secondSolid
}
}
box1x1x1 // User defined region name
{
type searchableBox; // region defined by bounding box
min (1.5 1 -0.5);
Open∇FOAM-1.6
U-142 Mesh generation and conversion
Keyword Description Example
castellatedMesh Create the castellated mesh? true
snap Do the surface snapping stage? true
doLayers Add surface layers? true
mergeTolerance Merge tolerance as fraction of bounding box
of initial mesh
1e-06
debug Controls writing of intermediate meshes and
screen printing
— Write ﬁnal mesh only 0
— Write intermediate meshes 1
— Write volScalarField with cellLevel for
post-processing
2
— Write current intersections as .obj ﬁles 4
geometry Sub-dictionary of all surface geometry used
castellatedMeshControls Sub-dictionary of controls for castellated mesh
snapControls Sub-dictionary of controls for surface snapping
addLayersControls Sub-dictionary of controls for layer addition
meshQualityControls Sub-dictionary of controls for mesh quality
Table 5.7: Keywords at the top level of snappyHexMeshDict.
max (3.5 2 0.5);
}
sphere2 // User defined region name
{
type searchableSphere; // region defined by bounding sphere
centre (1.5 1.5 1.5);
radius 1.03;
}
};
5.4.2 Creating the background hex mesh
Before snappyHexMesh is executed the user must create a background mesh of hexahedral
cells that ﬁlls the entire region within by the external boundary as shown in Figure 5.10.
This can be done simply using blockMesh. The following criteria must be observed when
Figure 5.10: Initial mesh generation in snappyHexMesh meshing process
creating the background mesh:
Open∇FOAM-1.6
5.4 Mesh generation with the snappyHexMesh utility U-143
• the mesh must consist purely of hexes;
• the cell aspect ratio should be approximately 1, at least near surfaces at which
the subsequent snapping procedure is applied, otherwise the convergence of the
snapping procedure is slow, possibly to the point of failure;
• there must be at least one intersection of a cell edge with the STL surface, i.e. a
mesh of one cell will not work.
5.4.3 Cell splitting at feature edges and surfaces
Cell splitting is performed according to the speciﬁcation supplied by the user in the
castellatedMeshControls sub-dictionary in the snappyHexMeshDict. The entries for castel-
latedMeshControls are presented in Table 5.8.
Keyword Description Example
locationInMesh Location vector inside the region to be meshed (5 0 0)
N.B. vector must not coincide with a cell face either before
or during reﬁnement
maxLocalCells Max number of cells per processor during re-
ﬁnement
1e+06
maxGlobalCells Overall cell limit during reﬁnement (i.e. before
removal)
2e+06
minRefinementCells If ≥ number of cells to be reﬁned, surface re-
ﬁnement stops
0
nCellsBetweenLevels Number of buﬀer layers of cells between dif-
ferent levels of reﬁnement
1
resolveFeatureAngle Applies maximum level of reﬁnement to cells
that can see intersections whose angle exceeds
this
30
features List of features for reﬁnement
refinementSurfaces Dictionary of surfaces for reﬁnement
refinementRegions Dictionary of regions for reﬁnement
Table 5.8: Keywords in the castellatedMeshControls sub-dictionary of snappyHexMeshDict.
The splitting process begins with cells being selected according to speciﬁed edge fea-
tures ﬁrst within the domain as illustrated in Figure 5.11. The features list in the
castellatedMeshControls sub-dictionary permits dictionary entries containing a name of an
edgeMesh ﬁle and the level of reﬁnement, e.g.:
features
(
{
file "someLine.eMesh"; // file containing edge mesh
level 2; // level of refinement
}
);
Following feature reﬁnement, cells are selected for splitting in the locality of speciﬁed
surfaces as illustrated in Figure 5.12. The refinementSurfaces dictionary in castel-
latedMeshControls requires dictionary entries for each STL surface and a default level
speciﬁcation of the minimum and maximum reﬁnement in the form (<min> <max>).
Open∇FOAM-1.6
U-144 Mesh generation and conversion
Figure 5.11: Cell splitting by feature edge in snappyHexMesh meshing process
Figure 5.12: Cell splitting by surface in snappyHexMesh meshing process
The minimum level is applied generally across the surface; the maximum level is ap-
plied to cells that can see intersections that form an angle in excess of that speciﬁed by
resolveFeatureAngle.
The reﬁnement can optionally be overridden on one or more speciﬁc region of an STL
surface. The region entries are collected in a regions sub-dictionary. The keyword for
each region entry is the name of the region itself and the reﬁnement level is contained
within a further sub-dictionary. An example is given below:
refinementSurfaces
{
sphere.stl
{
level (2 2); // default (min max) refinement for whole surface
regions
{
secondSolid
{
level (3 3); // optional refinement for secondSolid region
}
}
}
}
5.4.4 Cell removal
Once the feature and surface splitting is complete a process of cell removal begins. Cell
removal requires one or more regions enclosed entirely by a bounding surface within the
Open∇FOAM-1.6
5.4 Mesh generation with the snappyHexMesh utility U-145
domain. The region in which cells are retained are simply identiﬁed by a location vector
within that region, speciﬁed by the locationInMesh keyword in castellatedMeshControls.
Cells are retained if, approximately speaking, 50% or more of their volume lies within the
region. The remaining cells are removed accordingly as illustrated in Figure 5.13.
Figure 5.13: Cell removal in snappyHexMesh meshing process
5.4.5 Cell splitting in speciﬁed regions
Those cells that lie within one or more speciﬁed volume regions can be further split as il-
lustrated in Figure 5.14 by a rectangular region shown by dark shading. The refinement-
Figure 5.14: Cell splitting by region in snappyHexMesh meshing process
Regions sub-dictionary in castellatedMeshControls contains entries for reﬁnement of the
volume regions speciﬁed in the geometry sub-dictionary. A reﬁnement mode is applied to
each region which can be:
• inside reﬁnes inside the volume region;
• outside reﬁnes outside the volume region
• distance reﬁnes according to distance to the surface; and can accommodate diﬀer-
ent levels at multiple distances with the levels keyword.
Open∇FOAM-1.6
U-146 Mesh generation and conversion
For the refinementRegions, the reﬁnement level is speciﬁed by the levels list of entries
with the format(<distance> <level>). In the case of inside and outside reﬁnement,
the <distance> is not required so is ignored (but it must be speciﬁed). Examples are
shown below:
refinementRegions
{
box1x1x1
{
mode inside;
levels ((1.0 4)); // refinement level 4 (1.0 entry ignored)
}
sphere.stl
{ // refinement level 5 within 1.0 m
mode distance; // refinement level 3 within 2.0 m
levels ((1.0 5) (2.0 3)); // levels must be ordered nearest first
}
}
5.4.6 Snapping to surfaces
The next stage of the meshing process involves moving cell vertex points onto surface
geometry to remove the jagged castellated surface from the mesh. The process is:
1. displace the vertices in the castellated boundary onto the STL surface;
2. solve for relaxation of the internal mesh with the latest displaced boundary vertices;
3. ﬁnd the vertices that cause mesh quality parameters to be violated;
4. reduce the displacement of those vertices from their initial value (at 1) and repeat
from 2 until mesh quality is satisﬁed.
The method uses the settings in the snapControls sub-dictionary in snappyHexMeshDict,
listed in Table 5.9. An example is illustrated in the schematic in Figure 5.15 (albeit with
Keyword Description Example
nSmoothPatch Number of patch smoothing iterations before
ﬁnding correspondence to surface
3
tolerance Ratio of distance for points to be attracted
by surface feature point or edge, to local
maximum edge length
4.0
nSolveIter Number of mesh displacement relaxation it-
erations
30
nRelaxIter Maximum number of snapping relaxation it-
erations
5
Table 5.9: Keywords in the snapControls dictionary of snappyHexMeshDict.
mesh motion that looks slightly unrealistic).
5.4.7 Mesh layers
The mesh output from the snapping stage may be suitable for the purpose, although it
can produce some irregular cells along boundary surfaces. There is an optional stage of
the meshing process which introduces additional layers of hexahedral cells aligned to the
boundary surface as illustrated by the dark shaded cells in Figure 5.16.
Open∇FOAM-1.6
5.4 Mesh generation with the snappyHexMesh utility U-147
Figure 5.15: Surface snapping in snappyHexMesh meshing process
Figure 5.16: Layer addition in snappyHexMesh meshing process
The process of mesh layer addition involves shrinking the existing mesh from the
boundary and inserting layers of cells, broadly as follows:
1. the mesh is projected back from the surface by a speciﬁed thickness in the direction
normal to the surface;
2. solve for relaxation of the internal mesh with the latest projected boundary vertices;
3. check if validation criteria are satisﬁed otherwise reduce the projected thickness and
return to 2; if validation cannot be satisﬁed for any thickness, do not insert layers;
4. if the validation criteria can be satisﬁed, insert mesh layers;
5. the mesh is checked again; if the checks fail, layers are removed and we return to 2.
The layer addition procedure uses the settings in the addLayersControls sub-dictionary
in snappyHexMeshDict; entries are listed in Table 5.10. The layers sub-dictionary con-
tains entries for each patch on which the layers are to be applied and the number of
surface layers required. The patch name is used because the layers addition relates to the
existing mesh, not the surface geometry; hence applied to a patch, not a surface region.
An example layers entry is as follows:
layers
{
sphere.stl_firstSolid
Open∇FOAM-1.6
U-148 Mesh generation and conversion
Keyword Description Example
layers Dictionary of layers
relativeSizes Are layer thicknesses relative to undistorted cell
size outside layer or absolute?
true/false
expansionRatio Expansion factor for layer mesh 1.0
finalLayerRatio Thickness of layer furthest from the wall, ei-
ther relative or absolute according to the
relativeSizes entry
0.3
minThickness Minimum thickness of cell layer, either relative
or absolute (as above)
0.25
nGrow Number of layers of connected faces that are not
grown if points get not extruded; helps conver-
gence of layer addition close to features
1
featureAngle Angle above which surface is not extruded 60
nRelaxIter Maximum number of snapping relaxation itera-
tions
5
nSmoothSurfaceNormals Number of smoothing iterations of surface nor-
mals
1
nSmoothNormals Number of smoothing iterations of interior mesh
movement direction
3
nSmoothThickness Smooth layer thickness over surface patches 10
maxFaceThicknessRatio Stop layer growth on highly warped cells 0.5
maxThicknessTo-
MedialRatio
Reduce layer growth where ratio thickness to me-
dial distance is large
0.3
minMedianAxisAngle Angle used to pick up medial axis points 130
nBufferCellsNoExtrude Create buﬀer region for new layer terminations 0
nLayerIter Overall max number of layer addition iterations 50
nRelaxedIter Max number of iterations after which the
controls in the relaxed sub dictionary of
meshQuality are used
20
Table 5.10: Keywords in the addLayersControls sub-dictionary of snappyHexMeshDict.
{
nSurfaceLayers 1;
}
maxY
{
nSurfaceLayers 1;
}
}
5.4.8 Mesh quality controls
The mesh quality is controlled by the entries in the meshQualityControls sub-dictionary
in snappyHexMeshDict; entries are listed in Table 5.11.
5.5 Mesh conversion
The user can generate meshes using other packages and convert them into the format
that OpenFOAM uses. There are numerous mesh conversion utilities listed in Table 3.6.
Open∇FOAM-1.6
5.5 Mesh conversion U-149
Keyword Description Example
maxNonOrtho Maximum non-orthogonality allowed; 180 dis-
ables
65
maxBoundarySkewness Max boundary face skewness allowed; <0 dis-
ables
20
maxInternalSkewness Max internal face skewness allowed; <0 disables 4
maxConcave Max concaveness allowed; 180 disables 80
minFlatness Ratio of minimum projected area to actual area;
-1 disables
0.5
minVol Minimum pyramid volume; large negative num-
ber, e.g.-1e30 disables
1e-13
minArea Minimum face area; <0 disables -1
minTwist Minimum face twist; <-1 disables 0.05
minDeterminant Minimum normalised cell determinant; 1 = hex;
≤ 0 illegal cell
0.001
minFaceWeight 0→0.5 0.05
minVolRatio 0→1.0 0.01
minTriangleTwist >0 for Fluent compatability -1
nSmoothScale Number of error distribution iterations 4
errorReduction Amount to scale back displacement at error
points
0.75
relaxed Sub-dictionary that can include modiﬁed values
for the above keyword entries to be used when
nRelaxedIter is exceeded in the layer addition
process
relaxed
{
...
}
Table 5.11: Keywords in the meshQualityControls sub-dictionary of snappyHexMeshDict.
Some of the more popular mesh converters are listed below and their use is presented in
this section.
ﬂuentMeshToFoam reads a Fluent.msh mesh ﬁle, working for both 2-D and 3-D cases;
starToFoam reads STAR-CD/PROSTAR mesh ﬁles.
gambitToFoam reads a GAMBIT.neu neutral ﬁle;
ideasToFoam reads an I-DEAS mesh written in ANSYS.ans format;
cfx4ToFoam reads a CFX mesh written in .geo format;
5.5.1 ﬂuentMeshToFoam
Fluent writes mesh data to a single ﬁle with a .msh extension. The ﬁle must be written
in ASCII format, which is not the default option in Fluent. It is possible to convert
single-stream Fluent meshes, including the 2 dimensional geometries. In OpenFOAM, 2
dimensional geometries are currently treated by deﬁning a mesh in 3 dimensions, where
the front and back plane are deﬁned as the empty boundary patch type. When reading
a 2 dimensional Fluent mesh, the converter automatically extrudes the mesh in the third
direction and adds the empty patch, naming it frontAndBackPlanes.
The following features should also be observed.
Open∇FOAM-1.6
U-150 Mesh generation and conversion
• The OpenFOAM converter will attempt to capture the Fluent boundary condition
deﬁnition as much as possible; however, since there is no clear, direct correspondence
between the OpenFOAM and Fluent boundary conditions, the user should check the
boundary conditions before running a case.
• Creation of axi-symmetric meshes from a 2 dimensional mesh is currently not sup-
ported but can be implemented on request.
• Multiple material meshes are not permitted. If multiple ﬂuid materials exist, they
will be converted into a single OpenFOAM mesh; if a solid region is detected, the
converter will attempt to ﬁlter it out.
• Fluent allows the user to deﬁne a patch which is internal to the mesh, i.e. consists
of the faces with cells on both sides. Such patches are not allowed in OpenFOAM
and the converter will attempt to ﬁlter them out.
• There is currently no support for embedded interfaces and reﬁnement trees.
The procedure of converting a Fluent.msh ﬁle is ﬁrst to create a new OpenFOAM case
by creating the necessary directories/ﬁles: the case directory containing a controlDict ﬁle
in a system subdirectory. Then at a command prompt the user should execute:
fluentMeshToFoam <meshFile>
where <meshFile> is the name of the .msh ﬁle, including the full or relative path.
5.5.2 starToFoam
This section describes how to convert a mesh generated on the STAR-CD code into a form
that can be read by OpenFOAM mesh classes. The mesh can be generated by any of the
packages supplied with STAR-CD, i.e.PROSTAR, SAMM, ProAM and their derivatives.
The converter accepts any single-stream mesh including integral and arbitrary couple
matching and all cell types are supported. The features that the converter does not
support are:
• multi-stream mesh speciﬁcation;
• baﬄes, i.e. zero-thickness walls inserted into the domain;
• partial boundaries, where an uncovered part of a couple match is considered to be
a boundary face;
• sliding interfaces.
For multi-stream meshes, mesh conversion can be achieved by writing each individual
stream as a separate mesh and reassemble them in OpenFOAM.
OpenFOAM adopts a policy of only accepting input meshes that conform to the
fairly stringent validity criteria speciﬁed in section 5.1. It will simply not run using
invalid meshes and cannot convert a mesh that is itself invalid. The following sections
describe steps that must be taken when generating a mesh using a mesh generating
package supplied with STAR-CD to ensure that it can be converted to OpenFOAM format.
To avoid repetition in the remainder of the section, the mesh generation tools supplied
with STAR-CD will be referred to by the collective name STAR-CD.
Open∇FOAM-1.6
5.5 Mesh conversion U-151
5.5.2.1 General advice on conversion
We strongly recommend that the user run the STAR-CD mesh checking tools before
attempting a starToFoam conversion and, after conversion, the checkMesh utility should
be run on the newly converted mesh. Alternatively, starToFoam may itself issue warnings
containing PROSTAR commands that will enable the user to take a closer look at cells with
problems. Problematic cells and matches should be checked and ﬁxed before attempting
to use the mesh with OpenFOAM. Remember that an invalid mesh will not run with
OpenFOAM, but it may run in another environment that does not impose the validity
criteria.
Some problems of tolerance matching can be overcome by the use of a matching
tolerance in the converter. However, there is a limit to its eﬀectiveness and an apparent
need to increase the matching tolerance from its default level indicates that the original
mesh suﬀers from inaccuracies.
5.5.2.2 Eliminating extraneous data
When mesh generation in is completed, remove any extraneous vertices and compress the
cells boundary and vertex numbering, assuming that ﬂuid cells have been created and all
other cells are discarded. This is done with the following PROSTAR commands:
CSET NEWS FLUID
CSET INVE
The CSET should be empty. If this is not the case, examine the cells in CSET and adjust
the model. If the cells are genuinely not desired, they can be removed using the PROSTAR
command:
CDEL CSET
Similarly, vertices will need to be discarded as well:
CSET NEWS FLUID
VSET NEWS CSET
VSET INVE
Before discarding these unwanted vertices, the unwanted boundary faces have to be col-
lected before purging:
CSET NEWS FLUID
VSET NEWS CSET
BSET NEWS VSET ALL
BSET INVE
If the BSET is not empty, the unwanted boundary faces can be deleted using:
BDEL BSET
At this time, the model should contain only the ﬂuid cells and the supporting vertices,
as well as the deﬁned boundary faces. All boundary faces should be fully supported by the
vertices of the cells, if this is not the case, carry on cleaning the geometry until everything
is clean.
Open∇FOAM-1.6
U-152 Mesh generation and conversion
5.5.2.3 Removing default boundary conditions
By default, STAR-CD assigns wall boundaries to any boundary faces not explicitly associ-
ated with a boundary region. The remaining boundary faces are collected into a default
boundary region, with the assigned boundary type 0. OpenFOAM deliberately does not
have a concept of a default boundary condition for undeﬁned boundary faces since it
invites human error, e.g. there is no means of checking that we meant to give all the
unassociated faces the default condition.
Therefore all boundaries for each OpenFOAM mesh must be speciﬁed for a mesh to
be successfully converted. The default boundary needs to be transformed into a real
one using the procedure described below:
1. Plot the geometry with Wire Surface option.
2. Deﬁne an extra boundary region with the same parameters as the default region
0 and add all visible faces into the new region, say 10, by selecting a zone option
in the boundary tool and drawing a polygon around the entire screen draw of the
model. This can be done by issuing the following commands in PROSTAR:
RDEF 10 WALL
BZON 10 ALL
3. We shall remove all previously deﬁned boundary types from the set. Go through
the boundary regions:
BSET NEWS REGI 1
BSET NEWS REGI 2
... 3, 4, ...
Collect the vertices associated with the boundary set and then the boundary faces
associated with the vertices (there will be twice as many of them as in the original
set).
BSET NEWS REGI 1
VSET NEWS BSET
BSET NEWS VSET ALL
BSET DELE REGI 1
REPL
This should give the faces of boundary Region 10 which have been deﬁned on top
of boundary Region 1. Delete them with BDEL BSET. Repeat these for all regions.
5.5.2.4 Renumbering the model
Renumber and check the model using the commands:
CSET NEW FLUID
CCOM CSET
VSET NEWS CSET
VSET INVE (Should be empty!)
VSET INVE
VCOM VSET
Open∇FOAM-1.6
5.5 Mesh conversion U-153
BSET NEWS VSET ALL
BSET INVE (Should be empty also!)
BSET INVE
BCOM BSET
CHECK ALL
GEOM
Internal PROSTAR checking is performed by the last two commands, which may reveal
some other unforeseeable error(s). Also, take note of the scaling factor because PROSTAR
only applies the factor for STAR-CD and not the geometry. If the factor is not 1, use the
scalePoints utility in OpenFOAM.
5.5.2.5 Writing out the mesh data
Once the mesh is completed, place all the integral matches of the model into the couple
type 1. All other types will be used to indicate arbitrary matches.
CPSET NEWS TYPE INTEGRAL
CPMOD CPSET 1
The components of the computational grid must then be written to their own ﬁles. This
is done using PROSTAR for boundaries by issuing the command
BWRITE
by default, this writes to a .23 ﬁle (versions prior to 3.0) or a .bnd ﬁle (versions 3.0 and
higher). For cells, the command
CWRITE
outputs the cells to a .14 or .cel ﬁle and for vertices, the command
VWRITE
outputs to ﬁle a .15 or .vrt ﬁle. The current default setting writes the ﬁles in ASCII
format. If couples are present, an additional couple ﬁle with the extension .cpl needs to
be written out by typing:
CPWRITE
After outputting to the three ﬁles, exit PROSTAR or close the ﬁles. Look through
the panels and take note of all STAR-CD sub-models, material and ﬂuid properties used
– the material properties and mathematical model will need to be set up by creating and
editing OpenFOAM dictionary ﬁles.
The procedure of converting the PROSTAR ﬁles is ﬁrst to create a new OpenFOAM
case by creating the necessary directories. The PROSTAR ﬁles must be stored within the
same directory and the user must change the ﬁle extensions: from .23, .14 and .15 (below
STAR-CD version 3.0), or .pcs, .cls and .vtx (STAR-CD version 3.0 and above); to .bnd,
.cel and .vrt respectively.
Open∇FOAM-1.6
U-154 Mesh generation and conversion
5.5.2.6 Problems with the .vrt ﬁle
The .vrt ﬁle is written in columns of data of speciﬁed width, rather than free format. A
typical line of data might be as follows, giving a vertex number followed by the coordi-
nates:
19422 -0.105988957 -0.413711881E-02 0.000000000E+00
If the ordinates are written in scientiﬁc notation and are negative, there may be no space
between values, e.g.:
19423 -0.953953117E-01-0.338810333E-02 0.000000000E+00
The starToFoam converter reads the data using spaces to delimit the ordinate values and
will therefore object when reading the previous example. Therefore, OpenFOAM includes
a simple script, foamCorrectVrt to insert a space between values where necessary, i.e. it
would convert the previous example to:
19423 -0.953953117E-01 -0.338810333E-02 0.000000000E+00
The foamCorrectVrt script should therefore be executed if necessary before running the
starToFoam converter, by typing:
foamCorrectVrt <file>.vrt
5.5.2.7 Converting the mesh to OpenFOAM format
The translator utility starToFoam can now be run to create the boundaries, cells and
points ﬁles necessary for a OpenFOAM run:
starToFoam <meshFilePrefix>
where <meshFilePreﬁx> is the name of the the preﬁx of the mesh ﬁles, including the
full or relative path. After the utility has ﬁnished running, OpenFOAM boundary types
should be speciﬁed by editing the boundary ﬁle by hand.
5.5.3 gambitToFoam
GAMBIT writes mesh data to a single ﬁle with a .neu extension. The procedure of con-
verting a GAMBIT.neu ﬁle is ﬁrst to create a new OpenFOAM case, then at a command
prompt, the user should execute:
gambitToFoam <meshFile>
where <meshFile> is the name of the .neu ﬁle, including the full or relative path.
The GAMBIT ﬁle format does not provide information about type of the boundary
patch, e.g. wall, symmetry plane, cyclic. Therefore all the patches have been created as
type patch. Please reset after mesh conversion as necessary.
Open∇FOAM-1.6
5.6 Mapping ﬁelds between diﬀerent geometries U-155
5.5.4 ideasToFoam
OpenFOAM can convert a mesh generated by I-DEAS but written out in ANSYS format
as a .ans ﬁle. The procedure of converting the .ans ﬁle is ﬁrst to create a new OpenFOAM
case, then at a command prompt, the user should execute:
ideasToFoam <meshFile>
where <meshFile> is the name of the .ans ﬁle, including the full or relative path.
5.5.5 cfx4ToFoam
CFX writes mesh data to a single ﬁle with a .geo extension. The mesh format in CFX is
block-structured, i.e. the mesh is speciﬁed as a set of blocks with glueing information and
the vertex locations. OpenFOAM will convert the mesh and capture the CFX boundary
condition as best as possible. The 3 dimensional ‘patch’ deﬁnition in CFX, containing
information about the porous, solid regions etc. is ignored with all regions being converted
into a single OpenFOAM mesh. CFX supports the concept of a ‘default’ patch, where
each external face without a deﬁned boundary condition is treated as a wall. These faces
are collected by the converter and put into a defaultFaces patch in the OpenFOAM
mesh and given the type wall; of course, the patch type can be subsequently changed.
Like, OpenFOAM 2 dimensional geometries in CFX are created as 3 dimensional
meshes of 1 cell thickness [**]. If a user wishes to run a 2 dimensional case on a mesh
created by CFX, the boundary condition on the front and back planes should be set to
empty; the user should ensure that the boundary conditions on all other faces in the
plane of the calculation are set correctly. Currently there is no facility for creating an
axi-symmetric geometry from a 2 dimensional CFX mesh.
The procedure of converting a CFX.geo ﬁle is ﬁrst to create a new OpenFOAM case,
then at a command prompt, the user should execute:
cfx4ToFoam <meshFile>
where <meshFile> is the name of the .geo ﬁle, including the full or relative path.
5.6 Mapping ﬁelds between diﬀerent geometries
The mapFields utility maps one or more ﬁelds relating to a given geometry onto the
corresponding ﬁelds for another geometry. It is completely generalised in so much as
there does not need to be any similarity between the geometries to which the ﬁelds relate.
However, for cases where the geometries are consistent, mapFields can be executed with
a special option that simpliﬁes the mapping process.
For our discussion of mapFields we need to deﬁne a few terms. First, we say that
the data is mapped from the source to the target. The ﬁelds are deemed consistent if
the geometry and boundary types, or conditions, of both source and target ﬁelds are
identical. The ﬁeld data that mapFields maps are those ﬁelds within the time directory
speciﬁed by startFrom/startTime in the controlDict of the target case. The data is read
from the equivalent time directory of the source case and mapped onto the equivalent
time directory of the target case.
Open∇FOAM-1.6
U-156 Mesh generation and conversion
5.6.1 Mapping consistent ﬁelds
A mapping of consistent ﬁelds is simply performed by executing mapFields on the (target)
case using the -consistent command line option as follows:
mapFields <source dir> -consistent
5.6.2 Mapping inconsistent ﬁelds
When the ﬁelds are not consistent, as shown in Figure 5.17, mapFields requires a map-
FieldsDict dictionary in the system directory of the target case. The following rules apply
to the mapping:
• the ﬁeld data is mapped from source to target wherever possible, i.e. in our example
all the ﬁeld data within the target geometry is mapped from the source, except those
in the shaded region which remain unaltered;
• the patch ﬁeld data is left unaltered unless speciﬁed otherwise in the mapFieldsDict
dictionary.
The mapFieldsDict dictionary contain two lists that specify mapping of patch data. The
ﬁrst list is patchMap that speciﬁes mapping of data between pairs of source and target
patches that are geometrically coincident, as shown in Figure 5.17. The list contains
each pair of names of source and target patch. The second list is cuttingPatches that
contains names of target patches whose values are to be mapped from the source internal
ﬁeld through which the target patch cuts. In the situation where the target patch only
cuts through part of the source internal ﬁeld, e.g. bottom left target patch in our example,
those values within the internal ﬁeld are mapped and those outside remain unchanged.
An example mapFieldsDict dictionary is shown below:
17
18 patchMap ( lid movingWall );
19
20 cuttingPatches ( fixedWalls );
21
22
23 // ************************************************************************* //
mapFields <source dir>
5.6.3 Mapping parallel cases
If either or both of the source and target cases are decomposed for running in parallel,
additional options must be supplied when executing mapFields:
-parallelSource if the source case is decomposed for parallel running;
-parallelTarget if the target case is decomposed for parallel running.
Open∇FOAM-1.6
5.6 Mapping ﬁelds between diﬀerent geometries U-157
Internal target patches:
can be mapped using cuttingPatches
Target ﬁeld geometry
Source ﬁeld geometry
can be mapped using patchMap
Coincident patches:
Figure 5.17: Mapping inconsistent ﬁelds
Open∇FOAM-1.6
U-158 Mesh generation and conversion
Open∇FOAM-1.6
Chapter 6
Post-processing
This chapter describes options for post-processing with OpenFOAM. OpenFOAM is sup-
plied with a post-processing utility paraFoam that uses ParaView, an open source visuali-
sation application described in section 6.1.
Other methods of post-processing using third party products are oﬀered, including
EnSight, Fieldview and the post-processing supplied with Fluent.
6.1 paraFoam
The main post-processing tool provided with OpenFOAM is the a reader module to run
with ParaView, an open-source, visualization application. The module is compiled into
2 libraries, PV3FoamReader and vtkPV3Foam using version 3.6.1 of ParaView supplied
with the OpenFOAM release (PVFoamReader and vtkFoam in ParaView version 2.x). It
is recommended that this version of ParaView is used, although it is possible that the
latest binary release of the software will run adequately. Further details about ParaView
can be found at http://www.paraview.org and further documentation is available at
http://www.kitware.com/products/paraviewguide.html.
ParaView uses the Visualisation Toolkit (VTK) as its data processing and rendering
engine and can therefore read any data in VTK format. OpenFOAM includes the foam-
ToVTK utility to convert data from its native format to VTK format, which means that
any VTK-based graphics tools can be used to post-process OpenFOAM cases. This pro-
vides an alternative means for using ParaView with OpenFOAM. For users who wish
to experiment with advanced, parallel visualisation, there is also the free VisIt software,
available at http://www.llnl.gov/visit.
In summary, we recommend the reader module for ParaView as the primary post-
processing tool for OpenFOAM. Alternatively OpenFOAM data can be converted into
VTK format to be read by ParaView or any other VTK -based graphics tools.
6.1.1 Overview of paraFoam
paraFoam is strictly a script that launches ParaView using the reader module supplied
with OpenFOAM. It is executed like any of the OpenFOAM utilities either by the single
command from within the case directory or with the -case option with the case path as
an argument, e.g.:
paraFoam -case <caseDir>
ParaView is launched and opens the window shown in Figure 6.1. The case is controlled
from the left panel, which contains the following:
U-160 Post-processing
Figure 6.1: The paraFoam window
Pipeline Browser lists the modules opened in ParaView, where the selected modules are
highlighted in blue and the graphics for the given module can be enabled/disabled
by clicking the eye button alongside;
Properties panel contains the input selections for the case, such as times, regions and
ﬁelds;
Display panel controls the visual representation of the selected module, e.g. colours;
Information panel gives case statistics such as mesh geometry and size.
ParaView operates a tree-based structure in which data can be ﬁltered from the top-
level case module to create sets of sub-modules. For example, a contour plot of, say,
pressure could be a sub-module of the case module which contains all the pressure data.
The strength of ParaView is that the user can create a number of sub-modules and display
whichever ones they feel to create the desired image or animation. For example, they
may add some solid geometry, mesh and velocity vectors, to a contour plot of pressure,
switching any of the items on and oﬀ as necessary.
The general operation of the system is based on the user making a selection and then
clicking the green Apply button in the Properties panel. The additional buttons are: the
Reset button which used to reset the GUI if necessary; and, the Delete button that will
delete the active module.
6.1.2 The Properties panel
The Properties panel for the case module contains the settings for time step, regions and
ﬁelds. The controls are described in Figure 6.2. It is particularly worth noting that
Open∇FOAM-1.6
6.1 paraFoam U-161
The user can select internalMesh
region and/or individual patches
read into the case module
The user can select the ﬁelds
Figure 6.2: The Properties panel for the case module
in the current reader module, data in all time directories are loaded into ParaView (in
the reader module for ParaView 2.x, a set of check boxes controlled the time that were
displayed). In the current reader module, the buttons in the Current Time Controls
and VCR Controls toolbars select the time data to be displayed, as shown is section 6.1.4.
As with any operation in paraFoam, the user must click Apply after making any changes
to any selections. The Apply button is highlighted in green to alert the user if changes have
been made but not accepted. This method of operation has the advantage of allowing the
user to make a number of selections before accepting them, which is particularly useful
in large cases where data processing is best kept to a minimum.
There are occasions when the case data changes on ﬁle and ParaView needs to load the
changes, e.g. when ﬁeld data is written into new time directories. To load the changes,
the user should check the Update GUI button at the top of the Properties panel and then
apply the changes.
6.1.3 The Display panel
The Display panel contains the settings for visualising the data for a given case module.
The following points are particularly important:
• the data range may not be automatically updated to the max/min limits of a ﬁeld,
so the user should take care to select Rescale to Data Range at appropriate intervals,
in particular after loading the initial case module;
• clicking the Edit Color Map button, brings up a window in which there are two
panels:
Open∇FOAM-1.6
U-162 Post-processing
Outline, surface, wireframe or points
Data interpolation method
Change image opacity
e.g. to make transluscent
View case data
Colour geometry/entity by. . .
Set colour map range/appearance
Geometry manipulation tools
Figure 6.3: The Display panel
1. The Color Scale panel in which the colours within the scale can be chosen. The
standard blue to red colour scale for CFD can be selected by clicking Choose
Preset and selecting Blue to Red Rainbox HSV.
2. The Color Legend panel has a toggle switch for a colour bar legend and contains
settings for the layout of the legend, e.g. font.
• the underlying mesh can be represented by selecting Wireframe in the Represent-
ation menu of the Style panel;
• the geometry, e.g. a mesh (if Wireframe is selected), can be visualised as a single
colour by selecting Solid Color from the Color By menu and specifying the colour
in the Set Solid Color window;
Open∇FOAM-1.6
6.1 paraFoam U-163
• the image can be made translucent by editing the value in the Opacity text box (1
= solid, 0 = invisible) in the Style panel.
6.1.4 The button toolbars
ParaView duplicates functionality from pull-down menus at the top of the main window
and the major panels, within the toolbars below the main pull-down menus. The displayed
toolbars can be selected from Toolbars in the main View menu. The default layout with
all toolbars is shown in Figure 6.4 with each toolbar labelled. The function of many of
the buttons is clear from their icon and, with tooltips enabled in the Help menu, the user
is given a concise description of the function of any button.
Selection Controls VCR Controls
Common Filters Camera Controls
Centre Axes Controls
Undo/Redo ControlsMain controls Current Time Controls
Active Variable Controls | Representation
Figure 6.4: Toolbars in ParaView
6.1.5 Manipulating the view
This section describes operations for setting and manipulating the view of objects in
paraFoam.
6.1.5.1 View settings
The View Settings are selected from the Edit menu, which opens a Render View Options
window with a table of 3 items: General, Lights and Annotation. The General panel includes
the following items which are often worth setting at startup:
• the background colour, where white is often a preferred choice for printed material;
• Use parallel projection which is the usual choice for CFD, especially for 2D cases;
The Lights panel contains detailed lighting controls within the Light Kit panel. A
separate Headlight panel controls the direct lighting of the image. Checking the Headlight
button with white light colour of strength 1 seems to help produce images with strong
bright colours, e.g. with an isosurface.
The Annotation panel includes options for including annotations in the image. The
Orientation Axes feature controls an axes icon in the image window, e.g. to set the colour
of the axes labels x, y and z.
6.1.5.2 General settings
The general Settings are selected from the Edit menu, which opens a general Options
window with General and Render View menu items.
The General panel controls some default behaviour of ParaView. In particular, there
is an Auto Accept button that enables ParaView to accept changes automatically without
Open∇FOAM-1.6
U-164 Post-processing
clicking the green Apply button in the Properties window. For larger cases, this option is
generally not recommended: the user does not generally want the image to be re-rendered
between each of a number of changes he/she selects, but be able to apply a number of
changes to be re-rendered in their entirety once.
The Render View panel contains 3 sub-items: General, Camera and Server. The General
panel includes the level of detail (LOD) which controls the rendering of the image while it
is being manipulated, e.g. translated, resized, rotated; lowering the levels set by the sliders,
allows cases with large numbers of cells to be re-rendered quickly during manipulation.
The Camera panel includes control settings for 3D and 2D movements. This presents
the user with a map of rotation, translate and zoom controls using the mouse in combi-
nation with Shift- and Control-keys. The map can be edited to suit by the user.
6.1.6 Contour plots
A contour plot is created by selecting Contour from the Filter menu at the top menu
bar. The ﬁlter acts on a given module so that, if the module is the 3D case module itself,
the contours will be a set of 2D surfaces that represent a constant value, i.e. isosurfaces.
The Properties panel for contours contains an Isosurfaces list that the user can edit, most
conveniently by the New Range window. The chosen scalar ﬁeld is selected from a pull
down menu.
6.1.6.1 Introducing a cutting plane
Very often a user will wish to create a contour plot across a plane rather than producing
isosurfaces. To do so, the user must ﬁrst use the Slice ﬁlter to create the cutting plane,
on which the contours can be plotted. The Slice ﬁlter allows the user to specify a cutting
Plane, Box or Sphere in the Slice Type menu by a center and normal/radius respectively.
The user can manipulate the cutting plane like any other using the mouse.
The user can then run the Contour ﬁlter on the cut plane to generate contour lines.
6.1.7 Vector plots
Vector plots are created using the Glyph ﬁlter. The ﬁlter reads the ﬁeld selected in
Vectors and oﬀers a range of Glyph Types for which the Arrow provides a clear vector
plot images. Each glyph has a selection of graphical controls in a panel which the user
can manipulate to best eﬀect.
The remainder of the Properties panel contains mainly the Scale Mode menu for the
glyphs. The most common options are Scale Mode are: Vector, where the glyph length
is proportional to the vector magnitude; and, Off where each glyph is the same length.
The Set Scale Factor parameter controls the base length of the glyphs.
6.1.7.1 Plotting at cell centres
Vectors are by default plotted on cell vertices but, very often, we wish to plot data at cell
centres. This is done by ﬁrst applying the Cell Centers ﬁlter to the case module, and
then applying the Glyph ﬁlter to the resulting cell centre data.
6.1.8 Streamlines
Streamlines are created by ﬁrst creating tracer lines using the Stream Tracer ﬁlter. The
tracer Seed panel speciﬁes a distribution of tracer points over a Line Source or Point
Open∇FOAM-1.6
6.1 paraFoam U-165
Cloud. The user can view the tracer source, e.g. the line, but it is displayed in white, so
they may need to change the background colour in order to see it.
The distance the tracer travels and the length of steps the tracer takes are speciﬁed in
the text boxes in the main Stream Tracer panel. The process of achieving desired tracer
lines is largely one of trial and error in which the tracer lines obviously appear smoother
as the step length is reduced but with the penalty of a longer calculation time.
Once the tracer lines have been created, the Tubes ﬁlter can be applied to the Tracer
module to produce high quality images. The tubes follow each tracer line and are not
strictly cylindrical but have a ﬁxed number of sides and given radius. When the number
of sides is set above, say, 10, the tubes do however appear cylindrical, but again this adds
a computational cost.
6.1.9 Image output
The simplest way to output an image to ﬁle from ParaView is to select Save Screenshot
from the File menu. On selection, a window appears in which the user can select the
resolution for the image to save. There is a button that, when clicked, locks the aspect
ratio, so if the user changes the resolution in one direction, the resolution is adjusted in
the other direction automatically. After selecting the pixel resolution, the image can be
saved. To achieve high quality output, the user might try setting the pixel resolution to
1000 or more in the x-direction so that when the image is scaled to a typical size of a
ﬁgure in an A4 or US letter document, perhaps in a PDF document, the resolution is
sharp.
6.1.10 Animation output
To create an animation, the user should ﬁrst select Save Animation from the File menu.
A dialogue window appears in which the user can specify a number of things including
the image resolution. The user should specify the resolution as required. The other
noteworthy setting is number of frames per timestep. While this would intuitively be
set to 1, it can be set to a larger number in order to introduce more frames into the
animation artiﬁcially. This technique can be particularly useful to produce a slower
animation because some movie players have limited speed control, particularly over mpeg
movies.
On clicking the Save Animation button, another window appears in which the user spec-
iﬁes a ﬁle name root and ﬁle format for a set of images. On clicking OK, the set of ﬁles will
be saved according to the naming convention “<fileRoot> <imageNo>.<fileExt>”,
e.g. the third image of a series with the ﬁle root “animation”, saved in jpg format would
be named “animation 0002.jpg” (<imageNo> starts at 0000).
Once the set of images are saved the user can convert them into a movie using their
software of choice. The convert utility in the ImageMagick package can do this from the
command line, e.g. by
convert animation*jpg movie.mpg
When creating an mpg movie it can be worth increasing the default quality setting, e.g.
with -quality 90%, to reduce the graininess that can occur with the default setting.
Open∇FOAM-1.6
U-166 Post-processing
6.2 Post-processing with Fluent
It is possible to use Fluent as a post-processor for the cases run in OpenFOAM. Two con-
verters are supplied for the purpose: foamMeshToFluent which converts the OpenFOAM
mesh into Fluent format and writes it out as a .msh ﬁle; and, foamDataToFluent con-
verts the OpenFOAM results data into a .dat ﬁle readable by Fluent. foamMeshToFluent
is executed in the usual manner. The resulting mesh is written out in a ﬂuentInterface
subdirectory of the case directory, i.e.<caseName>/ﬂuentInterface/<caseName>.msh
foamDataToFluent converts the OpenFOAM data results into the Fluent format. The
conversion is controlled by two ﬁles. First, the controlDict dictionary speciﬁes startTime,
giving the set of results to be converted. If you want to convert the latest result,
startFrom can be set to latestTime. The second ﬁle which speciﬁes the translation
is the foamDataToFluentDict dictionary, located in the constant directory. An example
foamDataToFluentDict dictionary is given below:
1 /*--------------------------------*- C++ -*----------------------------------*\
2 | ========= | |
3 | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox |
4 | \\ / O peration | Version: 1.6 |
5 | \\ / A nd | Web: www.OpenFOAM.org |
6 | \\/ M anipulation | |
7 \*---------------------------------------------------------------------------*/
8 FoamFile
9 {
10 version 2.0;
11 format ascii;
12 class dictionary;
13 location "system";
14 object foamDataToFluentDict;
15 }
16 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
17
18 p 1;
19
20 U 2;
21
22 T 3;
23
24 h 4;
25
26 k 5;
27
28 epsilon 6;
29
30 gamma 150;
31
32
33 // ************************************************************************* //
The dictionary contains entries of the form
<fieldName> <fluentUnitNumber>
The <fluentUnitNumber> is a label used by the Fluent post-processor that only recog-
nises a ﬁxed set of ﬁelds. The basic set of <fluentUnitNumber> numbers are quoted in
Table 6.1. The dictionary must contain all the entries the user requires to post-process,
e.g. in our example we have entries for pressure p and velocity U. The list of default entries
described in Table 6.1. The user can run foamDataToFluent like any utility.
To view the results using Fluent, go to the ﬂuentInterface subdirectory of the case
directory and start a 3 dimensional version of Fluent with
fluent 3d
The mesh and data ﬁles can be loaded in and the results visualised. The mesh is read
by selecting Read Case from the File menu. Support items should be selected to read
Open∇FOAM-1.6
6.3 Post-processing with Fieldview U-167
Fluent name Unit number Common OpenFOAM name
PRESSURE 1 p
MOMENTUM 2 U
TEMPERATURE 3 T
ENTHALPY 4 h
TKE 5 k
TED 6 epsilon
SPECIES 7 —
G 8 —
XF RF DATA VOF 150 gamma
TOTAL PRESSURE 192 —
TOTAL TEMPERATURE 193 —
Table 6.1: Fluent unit numbers for post-processing.
certain data types, e.g. to read turbulence data for k and epsilon, the user would select
k-epsilon from the Define->Models->Viscous menu. The data can then be read by
selecting Read Data from the File menu.
A note of caution: users MUST NOT try to use an original Fluent mesh ﬁle that has
been converted to OpenFOAM format in conjunction with the OpenFOAM solution that
has been converted to Fluent format since the alignment of zone numbering cannot be
guaranteed.
6.3 Post-processing with Fieldview
OpenFOAM oﬀers the capability for post-processing OpenFOAM cases with Fieldview.
The method involves running a post-processing utility foamToFieldview to convert case
data from OpenFOAM to Fieldview.uns ﬁle format. For a given case, foamToFieldview is
executed like any normal application. foamToFieldview creates a directory named Fieldview
in the case directory, deleting any existing Fieldview directory in the process. By default
the converter reads the data in all time directories and writes into a set of ﬁles of the
form <case> nn.uns, where nn is an incremental counter starting from 1 for the ﬁrst time
directory, 2 for the second and so on. The user may specify the conversion of a single time
directory with the option -time <time>, where <time> is a time in general, scientiﬁc
or ﬁxed format.
Fieldview provides certain functions that require information about boundary condi-
tions, e.g. drawing streamlines that uses information about wall boundaries. The con-
verter tries, wherever possible, to include this information in the converted ﬁles by default.
The user can disable the inclusion of this information by using the -noWall option in the
execution command.
The data ﬁles for Fieldview have the .uns extension as mentioned already. If the original
OpenFOAM case includes a dot ‘.’, Fieldview may have problems interpreting a set of data
ﬁles as a single case with multiple time steps.
6.4 Post-processing with EnSight
OpenFOAM oﬀers the capability for post-processing OpenFOAM cases with EnSight,
with a choice of 2 options:
Open∇FOAM-1.6
U-168 Post-processing
• converting the OpenFOAM data to EnSight format with the foamToEnsight utility;
• reading the OpenFOAM data directly into EnSight using the ensight74FoamExec
module.
6.4.1 Converting data to EnSight format
The foamToEnsight utility converts data from OpenFOAM to EnSight ﬁle format. For a
given case, foamToEnsight is executed like any normal application. foamToEnsight creates
a directory named Ensight in the case directory, deleting any existing Ensight directory in
the process. The converter reads the data in all time directories and writes into a case
ﬁle and a set of data ﬁles. The case ﬁle is named EnSight Case and contains details of
the data ﬁle names. Each data ﬁle has a name of the form EnSight nn.ext, where nn is an
incremental counter starting from 1 for the ﬁrst time directory, 2 for the second and so
on and ext is a ﬁle extension of the name of the ﬁeld that the data refers to, as described
in the case ﬁle, e.g.T for temperature, mesh for the mesh. Once converted, the data can
be read into EnSight by the normal means:
1. from the EnSight GUI, the user should select Data (Reader) from the File menu;
2. the appropriate EnSight Case ﬁle should be highlighted in the Files box;
3. the Format selector should be set to Case, the EnSight default setting;
4. the user should click (Set) Case and Okay.
6.4.2 The ensight74FoamExec reader module
EnSight provides the capability of using a user-deﬁned module to read data from a format
other than the standard EnSight format. OpenFOAM includes its own reader module
ensight74FoamExec that is compiled into a library named libuserd-foam. It is this library
that EnSight needs to use which means that it must be able to locate it on the ﬁling
system as described in the following section.
6.4.2.1 Conﬁguration of EnSight for the reader module
In order to run the EnSight reader, it is necessary to set some environment variables cor-
rectly. The settings are made in the bashrc (or cshrc) ﬁle in the $WM PROJECT DIR/etc/-
apps/ensightFoam directory. The environment variables associated with EnSight are pre-
ﬁxed by $CEI or $ENSIGHT7 and listed in Table 6.2. With a standard user setup, only
$CEI HOME may need to be set manually, to the path of the EnSight installation.
6.4.2.2 Using the reader module
The principal diﬃculty in using the EnSight reader lies in the fact that EnSight expects
that a case to be deﬁned by the contents of a particular ﬁle, rather than a directory as it
is in OpenFOAM. Therefore in following the instructions for the using the reader below,
the user should pay particular attention to the details of case selection, since EnSight does
not permit selection of a directory name.
1. from the EnSight GUI, the user should select Data (Reader) from the File menu;
2. The user should now be able to select the OpenFOAM from the Format menu; if not,
there is a problem with the conﬁguration described above.
Open∇FOAM-1.6
6.5 Sampling data U-169
Environment variable Description and options
$CEI HOME Path where EnSight is installed, eg /usr/local/ensight, added
to the system path by default
$CEI ARCH Machine architecture, from a choice of names cor-
responding to the machine directory names in
$CEI HOME/ensight74/machines; default settings include
linux 2.4 and sgi 6.5 n32
$ENSIGHT7 READER Path that EnSight searches for the user deﬁned libuserd-foam
reader library, set by default to $FOAM LIBBIN
$ENSIGHT7 INPUT Set by default to dummy
Table 6.2: Environment variable settings for EnSight.
3. The user should ﬁnd their case directory from the File Selection window, highlight
one of top 2 entries in the Directories box ending in /. or /.. and click (Set)
Geometry.
4. The path ﬁeld should now contain an entry for the case. The (Set) Geometry text
box should contain a ‘/’.
5. The user may now click Okay and EnSight will begin reading the data.
6. When the data is read, a new Data Part Loader window will appear, asking which
part(s) are to be read. The user should select Load all.
7. When the mesh is displayed in the EnSight window the user should close the Data
Part Loader window, since some features of EnSight will not work with this window
open.
6.5 Sampling data
OpenFOAM provides the sample utility to sample ﬁeld data, either through a 1D line
for plotting on graphs or a 2D plane for displaying as isosurface images. The sampling
locations are speciﬁed for a case through a sampleDict dictionary in the case system
directory. The data can be written in a range of formats including well-known graphing
packages such as Grace/xmgr, gnuplot and jPlot.
The sampleDict dictionary can be generated by copying an example sampleDict from
the sample source code directory at $FOAM UTILITIES/postProcessing/sampling/sample.
The plateHole tutorial case in the $FOAM TUTORIALS/solidDisplacementFoam directory
also contains an example for 1D line sampling:
17
18 interpolationScheme cellPoint;
19
20 setFormat raw;
21
22 sets
23 (
24 leftPatch
25 {
26 type uniform;
27 axis y;
28 start ( 0 0.5 0.25 );
29 end ( 0 2 0.25 );
30 nPoints 100;
31 }
32 );
33
Open∇FOAM-1.6
U-170 Post-processing
34 surfaces ();
35
36 fields ( sigmaxx );
37
38
39 // ************************************************************************* //
Keyword Options Description
interpolation-
Scheme
cell
cellPoint
cellPointFace
Cell-centre value assumed constant over cell
Linear weighted interpolation using cell values
Mixed linear weighted / cell-face interpolation
setFormat raw
gnuplot
xmgr
jplot
Raw ASCII data in columns
Data in gnuplot format
Data in Grace/xmgr format
Data in jPlot format
surfaceFormat null
foamFile
dx
vtk
raw
stl
Suppresses output
points, faces, values ﬁle
DX scalar or vector format
VTK ASCII format
xyz values for use with e.g.gnuplotsplot
ASCII STL; just surface, no values
fields List of ﬁelds to be sampled, e.g. for velocity U:
U Writes all components of U
U.component(0) Writes component 0, i.e. Ux
U.component(1) Writes component 1, i.e. Uy
mag(U) Writes magnitude, i.e. |U|
sets List of 1D sets subdictionaries — see Table 6.4
surfaces List of 2D surfaces subdictionaries — see Table 6.5 and Table 6.6
Table 6.3: keyword entries for sampleDict.
The dictionary contains the following entries:
interpolationScheme the scheme of data interpolation;
sets the locations within the domain that the ﬁelds are line-sampled (1D).
surfaces the locations within the domain that the ﬁelds are surface-sampled (2D).
setFormat the format of line data output;
surfaceFormat the format of surface data output;
fields the ﬁelds to be sampled;
The interpolationScheme includes cellPoint and cellPointFace options in which
each polyhedral cell is decomposed into tetrahedra and the sample values are interpolated
from values at the tetrahedra vertices. With cellPoint, the tetrahedra vertices include
the polyhedron cell centre and 3 face vertices. The vertex coincident with the cell centre
inherits the cell centre ﬁeld value and the other vertices take values interpolated from cell
centres. With cellPointFace, one of the tetrahedra vertices is also coincident with a
face centre, which inherits ﬁeld values by conventional interpolation schemes using values
at the centres of cells that the face intersects.
Open∇FOAM-1.6
6.5 Sampling data U-171
The setFormat entry for line sampling includes a raw data format and formats for
gnuplot, Grace/xmgr and jPlot graph drawing packages. The data are written into a sets
directory within the case directory. The directory is split into a set of time directories and
the data ﬁles are contained therein. Each data ﬁle is given a name containing the ﬁeld
name, the sample set name, and an extension relating to the output format, including
.xy for raw data, .agr for Grace/xmgr and .dat for jPlot. The gnuplot format has the data
in raw form with an additional commands ﬁle, with .gplt extension, for generating the
graph. Note that any existing sets directory is deleted when sample is run.
The surfaceFormat entry for surface sampling includes a raw data format and formats
for gnuplot, Grace/xmgr and jPlot graph drawing packages. The data are written into a
surfaces directory within the case directory. The directory is split into time directories
and ﬁles are written much as with line sampling.
The fields list contains the ﬁelds that the user wishes to sample. The sample utility
can parse the following restricted set of functions to enable the user to manipulate vector
and tensor ﬁelds, e.g. for U:
U.component(n) writes the nth component of the vector/tensor, n = 0, 1 . . .;
mag(U) writes the magnitude of the vector/tensor.
The sets list contains sub-dictionaries of locations where the data is to be sampled.
The sub-dictionary is named according to the name of the set and contains a set of entries,
also listed in Table 6.4, that describes the locations where the data is to be sampled. For
example, a uniform sampling provides a uniform distribution of nPoints sample locations
along a line speciﬁed by a start and end point. All sample sets are also given: a type;
and, means of specifying the length ordinate on a graph by the axis keyword.
Required entries
Sampling type Sample locations
name
axis
start
end
nPoints
pointsuniform Uniformly distributed points on a line • • • • •
face Intersection of speciﬁed line and cell faces • • • •
midPoint Midpoint between line-face intersections • • • •
midPointAndFace Combination of midPoint and face • • • •
curve Speciﬁed points, tracked along a curve • • •
cloud Speciﬁed points • • •
Entries Description Options
type Sampling type see list above
axis Output of sample location x x ordinate
y y ordinate
z z ordinate
xyz xyz coordinates
distance distance from point 0
start Start point of sample line e.g.(0.0 0.0 0.0)
end End point of sample line e.g.(0.0 2.0 0.0)
nPoints Number of sampling points e.g.200
points List of sampling points
Table 6.4: Entries within sets sub-dictionaries.
Open∇FOAM-1.6
U-172 Post-processing
Keyword Description Options
basePoint Point on plane e.g.(0 0 0)
normalVector Normal vector to plane e.g.(1 0 0)
interpolate Interpolate data? true/false
triangulate Triangulate surface? (optional) true/false
Table 6.5: Entries for a plane in surfaces sub-dictionaries.
Keyword Description Options
patchName Name of patch e.g.movingWall
interpolate Interpolate data? true/false
triangulate Triangulate surface? (optional) true/false
Table 6.6: Entries for a patch in surfaces sub-dictionaries.
The surfaces list contains sub-dictionaries of locations where the data is to be sam-
pled. The sub-dictionary is named according to the name of the surface and contains
a set of entries beginning with the type: either a plane, deﬁned by point and normal
direction, with additional sub-dictionary entries a speciﬁed in Table 6.5; or, a patch, coin-
ciding with an existing boundary patch, with additional sub-dictionary entries a speciﬁed
in Table 6.6.
6.6 Monitoring and managing jobs
This section is concerned primarily with successful running of OpenFOAM jobs and ex-
tends on the basic execution of solvers described in section 3.3. When a solver is executed,
it reports the status of equation solution to standard output, i.e. the screen, if the level
debug switch is set to 1 or 2 (default) in DebugSwitches in the $WM PROJECT DIR/etc/-
controlDict ﬁle. An example from the beginning of the solution of the cavity tutorial is
shown below where it can be seen that, for each equation that is solved, a report line is
written with the solver name, the variable that is solved, its initial and ﬁnal residuals and
number of iterations.
Starting time loop
Time = 0.005
Max Courant Number = 0
BICCG: Solving for Ux, Initial residual = 1, Final residual = 2.96338e-06, No Iterations 8
ICCG: Solving for p, Initial residual = 1, Final residual = 4.9336e-07, No Iterations 35
time step continuity errors : sum local = 3.29376e-09, global = -6.41065e-20, cumulative = -6.41065e-20
ICCG: Solving for p, Initial residual = 0.47484, Final residual = 5.41068e-07, No Iterations 34
time step continuity errors : sum local = 6.60947e-09, global = -6.22619e-19, cumulative = -6.86725e-19
ExecutionTime = 0.14 s
Time = 0.01
Max Courant Number = 0.585722
BICCG: Solving for Ux, Initial residual = 0.148584, Final residual = 7.15711e-06, No Iterations 6
BICCG: Solving for Uy, Initial residual = 0.256618, Final residual = 8.94127e-06, No Iterations 6
ICCG: Solving for p, Initial residual = 0.37146, Final residual = 6.67464e-07, No Iterations 33
time step continuity errors : sum local = 6.34431e-09, global = 1.20603e-19, cumulative = -5.66122e-19
ICCG: Solving for p, Initial residual = 0.271556, Final residual = 3.69316e-07, No Iterations 33
time step continuity errors : sum local = 3.96176e-09, global = 6.9814e-20, cumulative = -4.96308e-19
ExecutionTime = 0.16 s
Open∇FOAM-1.6
6.6 Monitoring and managing jobs U-173
Time = 0.015
Max Courant Number = 0.758267
BICCG: Solving for Ux, Initial residual = 0.0448679, Final residual = 2.42301e-06, No Iterations 6
BICCG: Solving for Uy, Initial residual = 0.0782042, Final residual = 1.47009e-06, No Iterations 7
ICCG: Solving for p, Initial residual = 0.107474, Final residual = 4.8362e-07, No Iterations 32
time step continuity errors : sum local = 3.99028e-09, global = -5.69762e-19, cumulative = -1.06607e-18
ICCG: Solving for p, Initial residual = 0.0806771, Final residual = 9.47171e-07, No Iterations 31
time step continuity errors : sum local = 7.92176e-09, global = 1.07533e-19, cumulative = -9.58537e-19
ExecutionTime = 0.19 s
6.6.1 The foamJob script for running jobs
The user may be happy to monitor the residuals, iterations, Courant number etc. as
report data passes across the screen. Alternatively, the user can redirect the report to a
log ﬁle which will improve the speed of the computation. The foamJob script provides
useful options for this purpose with the following executing the speciﬁed <solver> as a
background process and redirecting the output to a ﬁle named log:
foamJob <solver>
For further options the user should execute foamJob -h. The user may monitor the log
ﬁle whenever they wish, using the UNIXtail command, typically with the -f ‘follow’ option
which appends the new data as the log ﬁle grows:
tail -f log
6.6.2 The foamLog script for monitoring jobs
There are limitations to monitoring a job by reading the log ﬁle, in particular it is diﬃcult
to extract trends over a long period of time. The foamLog script is therefore provided to
extract data of residuals, iterations, Courant number etc. from a log ﬁle and present it in
a set of ﬁles that can be plotted graphically. The script is executed by:
foamLog <logFile>
The ﬁles are stored in a subdirectory of the case directory named logs. Each ﬁle has
the name <var> <subIter> where <var> is the name of the variable speciﬁed in the log
ﬁle and <subIter> is the iteration number within the time step. Those variables that
are solved for, the initial residual takes the variable name <var> and ﬁnal residual takes
<var>FinalRes. By default, the ﬁles are presented in two-column format of time and the
extracted values.
For example, in the cavity tutorial we may wish to observe the initial residual of the
Ux equation to see whether the solution is converging to a steady-state. In that case, we
would plot the data from the logs/Ux 0 ﬁle as shown in Figure 6.5. It can be seen here
that the residual falls monotonically until it reaches the convergence tolerance of 10−5
.
foamLog generates ﬁles for everything it feasibly can from the log ﬁle. In the cavity
tutorial example, this includes:
• the Courant number, Courant 0;
• Ux equation initial and ﬁnal residuals, Ux 0 and UxFinalRes 0, and iterations,
UxIters 0 (and equivalent Uy data);
Open∇FOAM-1.6
U-174 Post-processing
Time [s]
Ux0
0.180.160.140.120.100.080.060.040.020.00
1e+00
1e-01
1e-02
1e-03
1e-04
1e-05
Figure 6.5: Initial residual of Ux in the cavity tutorial
• cumulative, global and local continuity errors after each of the 2 p equations,
contCumulative 0, contGlobal 0, contLocal 0 and contCumulative 1, contGlobal 1,
contLocal 1;
• residuals and iterations from the the 2 p equations p 0, pFinalRes 0, pIters 0 and
p 1, pFinalRes 1, pIters 1;
• and execution time, executionTime.
Open∇FOAM-1.6
Chapter 7
Models and physical properties
OpenFOAM includes a large range of solvers each designed for a speciﬁc class of problem.
The equations and algorithms diﬀer from one solver to another so that the selection of
a solver involves the user making some initial choices on the modelling for their partic-
ular case. The choice of solver typically involves scanning through their descriptions in
Table 3.5 to ﬁnd the one suitable for the case. It ultimately determines many of the pa-
rameters and physical properties required to deﬁne the case but leaves the user with some
modelling options that can be speciﬁed at runtime through the entries in dictionary ﬁles
in the constant directory of a case. This chapter deals with many of the more common
models and associated properties that may be speciﬁed at runtime.
7.1 Thermophysical models
Thermophysical models are concerned with the energy, heat and physical properties.
The thermophysicalProperties dictionary is read by any solver that uses the thermophys-
ical model library. A thermophysical model is constructed in OpenFOAM as a pressure-
temperature p − T system from which other properties are computed. There is one com-
pulsory dictionary entry called thermoType which speciﬁes the complete thermophysical
model that is used in the simulation. The thermophysical modelling starts with a layer
that deﬁnes the basic equation of state and then adds more layers of modelling that de-
rive properties from the previous layer(s). The naming of the thermoType reﬂects these
multiple layers of modelling as listed in Table 7.1.
Equation of State — equationOfState
icoPolynomial Incompressible polynomial equation of state, e.g. for liquids
perfectGas Perfect gas equation of state
Basic thermophysical properties — thermo
eConstThermo Constant speciﬁc heat cp model with evaluation of internal
energy e and entropy s
hConstThermo Constant speciﬁc heat cp model with evaluation of enthalpy
h and entropy s
hPolynomialThermo cp evaluated by a function with coeﬃcients from polynomi-
als, from which h, s are evaluated
janafThermo cp evaluated by a function with coeﬃcients from JANAF
thermodynamic tables, from which h, s are evaluated
Derived thermophysical properties — specieThermo
Continued on next page
U-176 Models and physical properties
Continued from previous page
specieThermo Thermophysical properties of species, derived from cp, h
and/or s
Transport properties — transport
constTransport Constant transport properties
polynomialTransport Polynomial based temperature-dependent transport prop-
erties
sutherlandTransport Sutherland’s formula for temperature-dependent transport
properties
Mixture properties — mixture
pureMixture General thermophysical model calculation for passive gas
mixtures
homogeneousMixture Combustion mixture based on normalised fuel mass frac-
tion b
inhomogeneousMixture Combustion mixture based on b and total fuel mass fraction
ft
veryInhomogeneousMixture Combustion mixture based on b, ft and unburnt fuel mass
fraction fu
dieselMixture Combustion mixture based on ft and fu
basicMultiComponent-
Mixture
Basic mixture based on multiple components
multiComponentMixture Derived mixture based on multiple components
reactingMixture Combustion mixture using thermodynamics and reaction
schemes
egrMixture Exhaust gas recirculation mixture
Thermophysical model — thermoModel
hPsiThermo General thermophysical model calculation based on en-
thalpy h and compressibility ψ
ePsiThermo General thermophysical model calculation based on inter-
nal energy e and compressibility ψ
hRhoThermo General thermophysical model calculation based on en-
thalpy h
hPsiMixtureThermo Calculates enthalpy for combustion mixture based on ψ
hRhoMixtureThermo Calculates enthalpy for combustion mixture based on ρ
hhuMixtureThermo Calculates enthalpy for unburnt gas and combustion mix-
ture
Table 7.1: Layers of thermophysical modelling.
The thermoType entry typically takes the form:
thermoModel<mixture<transport<specieThermo<thermo<equationOfState>>>>>
so that the following is an example entry for thermoType:
hThermo<pureMixture<constTransport<specieThermo<hConstThermo<perfectGas>>>>>
Open∇FOAM-1.6
7.1 Thermophysical models U-177
7.1.1 Thermophysical property data
The basic thermophysical properties are speciﬁed for each species from input data. The
data is speciﬁed using a compound entry with the following format for a specie accessed
through the keyword mixture:
mixture <specieCoeffs> <thermoCoeffs> <transportCoeffs>
The specie coeﬃcients <specieCoeffs> contains the entries listed in Table 7.2 in the
order that they are speciﬁed in input.
Description Entry
String name e.g.mixture
Number of moles of this specie nmoles
Molecular weight W (kg/kmol)
Table 7.2: Specie coeﬃcients.
The thermodynamic coeﬃcients <thermoCoeffs> are ostensibly concerned with eval-
uating the speciﬁc heat cp from which other properties are derived. The current thermo
models are described as follows:
hConstThermo assumes a constant cp and a heat of fusion Hf which is simply speciﬁed
by a two values cp Hf following the <specieCoeffs>.
eConstThermo assumes a constant cv and a heat of fusion Hf which is simply speciﬁed
by a two values cv Hf following the <specieCoeffs>.
janafThermo calculates cp as a function of temperature T from a set of coeﬃcients taken
from JANAF tables of thermodynamics. The ordered list of coeﬃcients is given in
Table 7.3. The function is valid between a lower and upper limit in temperature Tl
and Th respectively. Two sets of coeﬃcients are speciﬁed, the ﬁrst set for tempera-
tures above a common temperature Tc (and below Th, the second for temperatures
below Tc (and above Tl). The function relating cp to temperature is:
cp = R((((a4T + a3)T + a2)T + a1)T + a0) (7.1)
In addition, there are constants of integration, a5 and a6, both at high and low
temperature, used to evaluating h and s respectively.
hPolynomialThermo calculates Cp as a function of temperature by a polynomial of any or-
der. The following case provides an example of its use: $FOAM TUTORIALS/lagrangian/porous-
ExplicitSourceReactingParcelFoam/ﬁlter
The transport coeﬃcients <transportCoeffs> are used to to evaluate dynamic vis-
cosity µ, thermal conductivity κ and laminar thermal conductivity (for enthalpy equation)
α. The current transport models are described as follows:
constTransport assumes a constant µ and Prandtl number Pr = cpµ/κ which is simply
speciﬁed by a two values µ Pr following the <thermoCoeffs>.
sutherlandTransport calculates µ as a function of temperature T from a Sutherland coeﬃ-
cient As and Sutherland temperature Ts, speciﬁed by values following the <thermoCoeffs>;
µ is calculated according to:
µ =
As
√
T
1 + Ts/T
(7.2)
Open∇FOAM-1.6
U-178 Models and physical properties
Description Entry
Lower temperature limit Tl (K)
Upper temperature limit Th (K)
Common temperature Tc (K)
High temperature coeﬃcients a0 . . . a4
High temperature enthalpy oﬀset a5
High temperature entropy oﬀset a6
Low temperature coeﬃcients a0 . . . a4
Low temperature enthalpy oﬀset a5
Low temperature entropy oﬀset a6
Table 7.3: JANAF thermodynamics coeﬃcients.
polynomialTransport calculates µ and κ as a function of temperature T from a polynomial
of any order.
The following is an example entry for a specie named fuel modelled using sutherland-
Transport and janafThermo, with comments to explain the entries:
fuel // keyword
fuel 1 44.0962 // specie
200 5000 1000 // -- janafThermo --
7.53414 0.0188722 -6.27185e-06 9.14756e-10 -4.78381e-14
-16467.5 -17.8923
0.933554 0.0264246 6.10597e-06 -2.19775e-08 9.51493e-12
-13958.5 19.2017 // -----------------
1.67212e-06 170.672; // sutherlandTransport
The following is an example entry for a specie named air modelled using constTransport
and hConstThermo, with comments to explain the entries:
mixture // keyword
air 1 28.9 // specie
1000 2.544e+06 // hConstThermo
1.8e-05 0.7; // constTransport
7.2 Turbulence models
The turbulenceProperties dictionary is read by any solver that includes turbulence mod-
elling. Within that ﬁle is the simulationType keyword that controls the type of turbu-
lence modelling to be used, either:
laminar uses no turbulence models;
RASmodel uses Reynolds-averaged stress (RAS) modelling;
LESmodel uses large-eddy simulation (LES) modelling.
If RASmodel is selected, the choice of RAS modelling is speciﬁed in a RASProperties ﬁle,
also in the constant directory. The RAS turbulence model is selected by the RASModel en-
try from a long list of available models that are listed in Table 3.9. Similarly, if LESmodel
Open∇FOAM-1.6
7.2 Turbulence models U-179
is selected, the choice of LES modelling is speciﬁed in a LESProperties dictionary and the
LES turbulence model is selected by the LESModel entry.
The entries required in the RASProperties are listed in Table 7.4 and those for LESProp-
erties dictionaries are listed in Table 7.5.
RASModel Name of RAS turbulence model
turbulence Switch to turn turbulence modelling on/oﬀ
<RASModel>Coeffs Optional dictionary of coeﬃcients for the respective RASModel
Table 7.4: Keyword entries in the RASProperties dictionary.
LESmodel Name of LES model
delta Name of delta δ model
<LESmodel>Coeffs Dictionary of coeﬃcients for the respective LESmodel
<delta>Coeffs Dictionary of coeﬃcients for each delta model
Table 7.5: Keyword entries in the LESProperties dictionary.
The incompressible and compressible RAS turbulence models, isochoric and aniso-
choric LES models and delta models are all named and described in Table 3.9. Examples
of their use can be found in the $FOAM TUTORIALS.
7.2.1 Model coeﬃcients
The coeﬃcients for the RAS turbulence models are given default values in their respective
source code. If the user wishes to override these default values, then they can do so by
adding a sub-dictionary entry to the RASproperties ﬁle, whose keyword name is that of
the model with Coeffs appended, e.g. kEpsilonCoeffs for the kEpsilon model. If the
printCoeffs switch is on in the RASproperties ﬁle, an example of the relevant ...Coeffs
dictionary is printed to standard output when the model is created at the beginning of
a run. The user can simply copy this into the RASproperties ﬁle and edit the entries as
required.
7.2.2 Wall functions
From version 1.6 onwards, a range of wall function models is available in OpenFOAM
that are applied as boundary conditions on individual patches. This enables diﬀerent wall
function models to be applied to diﬀerent wall regions. The choice of wall function model
is speciﬁed through: νt in the 0/nut ﬁle for incompressible RAS; µt in the 0/mut ﬁle for
compressible RAS; νsgs in the 0/nuSgs ﬁle for incompressible LES; µsgs in the 0/muSgs
ﬁle for incompressible LES. For example, a 0/nut ﬁle:
17
18 dimensions [0 2 -1 0 0 0 0];
19
20 internalField uniform 0;
21
22 boundaryField
23 {
24 movingWall
25 {
26 type nutWallFunction;
27 value uniform 0;
28 }
29 fixedWalls
Open∇FOAM-1.6
U-180 Models and physical properties
30 {
31 type nutWallFunction;
32 value uniform 0;
33 }
34 frontAndBack
35 {
36 type empty;
37 }
38 }
39
40
41 // ************************************************************************* //
There are a number of wall function models available in the release, e.g. nutWallFunction,
nutRoughWallFunction, nutSpalartAllmarasStandardRoughWallFunction, nutSpal-
artAllmarasStandardWallFunction and nutSpalartAllmarasWallFunction. The user
can consult the relevant directories for a full list of wall function models:
find $FOAM SRC/turbulenceModels -name wallFunctions
Within each wall function boundary condition the user can over-ride default settings for
E and κ through optional E and kappa keyword entries.
Having selected the particular wall functions on various patches in the nut/mut ﬁle,
the user should select epsilonWallFunction on corresponding patches in the epsilon ﬁeld
and kqRwallFunction on corresponding patches in the turbulent ﬁelds k, q and R.
Open∇FOAM-1.6
Index U-181
Index
Symbols Numbers A B C D E F G H I J K L M N O P Q R S T U V W X Z
Symbols
*
tensor member function, P-25
+
tensor member function, P-25
-
tensor member function, P-25
/
tensor member function, P-25
/*...*/
C++ syntax, U-78
//
C++ syntax, U-78
OpenFOAM ﬁle syntax, U-102
# include
C++ syntax, U-72, U-78
&
tensor member function, P-25
&&
tensor member function, P-25
^
tensor member function, P-25
<LESmodel>Coeffs keyword, U-179
<RASModel>Coeffs keyword, U-179
<delta>Coeffs keyword, U-179
cellSet utility, U-90
faceSet utility, U-90
pointSet utility, U-90
0.000000e+00 directory, U-102
1-dimensional mesh, U-126
1D mesh, U-126
2-dimensional mesh, U-126
2D mesh, U-126
Numbers
0 directory, U-102
A
access functions, P-23
addLayersControls keyword, U-142
adiabaticFlameT utility, U-93
adjustableRunTime
keyword entry, U-60, U-109
adjustTimeStep keyword, U-60
agglomerator keyword, U-119
algorithms tools, U-94
alphaContactAngle
boundary condition, U-58
analytical solution, P-45
anisotropicFilter model, U-98
Annotation window panel, U-26, U-163
ansysToFoam utility, U-89
APIfunctions model, U-97
applications, U-69
Apply button, U-160, U-164
applyBoundaryLayer utility, U-89
applyWallFunctionBoundaryConditions utility,
U-89
arbitrarily unstructured, P-31
arc
keyword entry, U-136
arc keyword, U-135
ascii
keyword entry, U-109
attachMesh utility, U-90
Auto Accept button, U-163
autoMesh
library, U-95
autoPatch utility, U-90
autoReﬁneMesh utility, U-91
axes
right-handed, U-134
right-handed rectangular Cartesian, P-15,
U-20
axi-symmetric cases, U-131, U-139
axi-symmetric mesh, U-126
B
background
process, U-26, U-81
backward
keyword entry, U-116
Backward diﬀerencing, P-39
barotropicCompressibilityModels
library, U-97
Open∇FOAM-1.6
U-182 Index
basicMultiComponentMixture model, U-96,
U-176
basicThermophysicalModels
library, U-96
binary
keyword entry, U-109
BirdCarreau model, U-99
blended diﬀerencing, P-38
block
expansion ratio, U-136
block keyword, U-135
blockMesh solver, P-47
blockMesh utility, U-38, U-89, U-132
blockMesh executable
vertex numbering, U-136
blockMeshDict
dictionary, U-20, U-22, U-37, U-49, U-132,
U-140
blocks keyword, U-22, U-32, U-136
boundaries, U-128
boundary, U-128
boundary
dictionary, U-125, U-132
boundary condition
alphaContactAngle, U-58
calculated, U-132
cyclic, U-131
directionMixed, U-132
empty, P-63, P-69, U-20, U-126, U-131
ﬁxedGradient, U-132
ﬁxedValue, U-132
ﬂuxCorrectedVelocity, U-133
inlet, P-69
inletOutlet, U-133
mixed, U-132
movingWallVelocity, U-133
outlet, P-69
outletInlet, U-133
partialSlip, U-133
patch, U-131
pressureDirectedInletVelocity, U-133
pressureInletVelocity, U-133
pressureOutlet, P-63
pressureTransmissive, U-133
processor, U-131
setup, U-22
slip, U-133
supersonicFreeStream, U-133
surfaceNormalFixedValue, U-133
symmetryPlane, P-63, U-131
totalPressure, U-133
turbulentInlet, U-133
wall, U-41
wall, P-63, P-69, U-58, U-131
wallBuoyantPressure, U-133
wedge, U-126, U-131, U-139
zeroGradient, U-132
boundary conditions, P-43
Dirichlet, P-43
inlet, P-44
Neumann, P-43
no-slip impermeable wall, P-44
outlet, P-44
physical, P-44
symmetry plane, P-44
boundaryField keyword, U-22, U-106
boundaryFoam solver, U-85
bounded
keyword entry, U-114, U-115
boxToCell keyword, U-59
boxTurb utility, U-89
breaking of a dam, U-56
bubbleFoam solver, U-86
buoyantBoussinesqPisoFoam solver, U-87
buoyantBoussinesqSimpleFoam solver, U-87
buoyantPisoFoam solver, U-87
buoyantSimpleFoam solver, U-87
buoyantSimpleRadiationFoam solver, U-87
button
Apply, U-160, U-164
Auto Accept, U-163
Choose Preset, U-162
Delete, U-160
Edit Color Map, U-161
Enable Line Series, U-36
Orientation Axes, U-26, U-163
Rescale to Data Range, U-28
Reset, U-160
Set Solid Color, U-162
Update GUI, U-28, U-161
Use Parallel Projection, U-25
Use parallel projection, U-163
C
C++ syntax
/*...*/, U-78
//, U-78
# include, U-72, U-78
cacheAgglomeration keyword, U-120
calculated
boundary condition, U-132
cAlpha keyword, U-62
cases, U-101
castellatedMesh keyword, U-142
castellatedMeshControls
dictionary, U-143, U-145
castellatedMeshControls keyword, U-142
cavitatingFoam solver, U-86
Open∇FOAM-1.6
Index U-183
cavity ﬂow, U-19
CEI ARCH
environment variable, U-169
CEI HOME
environment variable, U-169
cell
expansion ratio, U-136
cell class, P-31
cell
keyword entry, U-170
cellPoint
keyword entry, U-170
cellPointFace
keyword entry, U-170
cells
dictionary, U-132
central diﬀerencing, P-38
cfdTools tools, U-95
cfx4ToFoam utility, U-89, U-149
changeDictionary utility, U-89
channelFoam solver, U-85
Chart Options window, U-36
checkMesh utility, U-90, U-151
chemistryModel
library, U-97
chemistryModel model, U-97
chemistrySolver model, U-97
chemkinToFoam utility, U-93
Choose Preset button, U-162
chtMultiRegionFoam solver, U-87
Chung
library, U-97
class
cell, P-31
dimensionSet, P-25, P-32, P-33
face, P-31
ﬁniteVolumeCalculus, P-33
ﬁniteVolumeMethod, P-33
fvMesh, P-31
fvSchemes, P-36
fvc, P-36
fvm, P-36
pointField, P-31
polyBoundaryMesh, P-31
polyMesh, P-31, U-123, U-125
polyPatchList, P-31
polyPatch, P-31
scalarField, P-29
scalar, P-23
slice, P-31
symmTensorField, P-29
symmTensorThirdField, P-29
tensorField, P-29
tensorThirdField, P-29
tensor, P-23
vectorField, P-29
vector, P-23, U-105
word, P-25, P-31
class keyword, U-103
clockTime
keyword entry, U-109
cloud keyword, U-171
cmptAv
tensor member function, P-25
Co utility, U-91
coalChemistryFoam solver, U-88
coalCombustion
library, U-95
cofactors
tensor member function, P-25
coldEngineFoam solver, U-87
collapseEdges utility, U-91
Color By menu, U-162
Color Legend window, U-30
Color Legend window panel, U-162
Color Scale window panel, U-162
combinePatchFaces utility, U-91
comments, U-78
compressed
keyword entry, U-109
compressibleInterDyMFoam solver, U-86
compressibleInterFoam solver, U-86
compressibleLESModels
library, U-99
compressibleRASModels
library, U-98
constant directory, U-102, U-175
constLaminarFlameSpeed model, U-97
constTransport model, U-97, U-176
containers tools, U-94
continuum
mechanics, P-15
control
of time, U-108
controlDict
dictionary, P-65, U-23, U-32, U-42, U-51,
U-60, U-102, U-155
controlDict ﬁle, P-49
convection, see divergence, P-38
convergence, U-40
conversion
library, U-96
convertToMeters keyword, U-134, U-135
coordinate
system, P-15
coordinate system, U-20
corrected
keyword entry, U-114, U-115
Open∇FOAM-1.6
U-184 Index
Courant number, P-42, U-24
cpuTime
keyword entry, U-109
Crank Nicholson
temporal discretisation, P-42
CrankNicholson
keyword entry, U-116
createBaﬄes utility, U-90
createPatch utility, U-90
createTurbulenceFields utility, U-92
cross product, see tensor, vector cross product
CrossPowerLaw
keyword entry, U-59
CrossPowerLaw model, U-99
cubeRootVolDelta model, U-98
cubicCorrected
keyword entry, U-116
cubicCorrection
keyword entry, U-113
curl, P-37
curl
fvc member function, P-37
Current Time Controls menu, U-28, U-161
curve keyword, U-171
cyclic
boundary condition, U-131
cyclic
keyword entry, U-130
cylinder
ﬂow around a, P-45
D
d2dt2
fvc member function, P-37
fvm member function, P-37
dam
breaking of a, U-56
db tools, U-94
ddt
fvc member function, P-37
fvm member function, P-37
DeardorﬀDiﬀStress model, U-99
debug keyword, U-142
decomposePar utility, U-81, U-82, U-93
decomposeParDict
dictionary, U-81
decomposition
of ﬁeld, U-81
of mesh, U-81
decompositionMethods
library, U-96
decompression of a tank, P-62
defaultFieldValues keyword, U-59
deformedGeom utility, U-90
Delete button, U-160
delta keyword, U-83, U-179
deltaT keyword, U-108
dependencies, U-72
dependency lists, U-72
det
tensor member function, P-25
determinant, see tensor, determinant
dev
tensor member function, P-25
diag
tensor member function, P-25
diagonal
keyword entry, U-119
DIC
keyword entry, U-119
DICGaussSeidel
keyword entry, U-119
dictionary
LESProperties, U-179
PISO, U-25
blockMeshDict, U-20, U-22, U-37, U-49,
U-132, U-140
boundary, U-125, U-132
castellatedMeshControls, U-143, U-145
cells, U-132
controlDict, P-65, U-23, U-32, U-42, U-51,
U-60, U-102, U-155
decomposeParDict, U-81
faces, U-125, U-132
fvSchemes, U-61, U-102, U-110, U-111
fvSolution, U-102, U-117
mechanicalProperties, U-51
neighbour, U-125
owner, U-125
points, U-125, U-132
thermalProperties, U-51
thermophysicalProperties, U-175
transportProperties, U-23, U-39, U-42
turbulenceProperties, U-42, U-60, U-178
dieselEngineFoam solver, U-87
dieselFoam solver, U-87
dieselMixture model, U-96, U-176
dieselSpray
library, U-95
diﬀerencing
Backward, P-39
blended, P-38
central, P-38
Euler implicit, P-39
Gamma, P-38
MINMOD, P-38
SUPERBEE, P-38
upwind, P-38
Open∇FOAM-1.6
Index U-185
van Leer, P-38
DILU
keyword entry, U-119
dimension
checking in OpenFOAM, P-25, U-105
dimensional units, U-105
dimensioned<Type> template class, P-25
dimensionedTypes tools, U-94
dimensions keyword, U-22, U-106
dimensionSet class, P-25, P-32, P-33
dimensionSet tools, U-94
direct numerical simulation, U-61
directionMixed
boundary condition, U-132
directory
0.000000e+00, U-102
0, U-102
Make, U-73
constant, U-102, U-175
ﬂuentInterface, U-166
polyMesh, U-102, U-125
processorN, U-82
run, U-101
system, P-49, U-102
tutorials, P-45, U-19
discretisation
equation, P-33
Display window panel, U-25, U-28,
U-160, U-161
distance
keyword entry, U-145, U-171
distributed keyword, U-83, U-84
div
fvc member function, P-37
fvm member function, P-37
divergence, P-37, P-39
divSchemes keyword, U-111
dnsFoam solver, U-87
doLayers keyword, U-142
double inner product, see tensor,double inner
product
dsmc
library, U-95
dsmcFieldsCalc utility, U-93
dsmcFoam solver, U-88
dsmcInitialise utility, U-89
dx
keyword entry, U-170
dynamicFvMesh
library, U-95
dynamicMesh
library, U-95
dynMixedSmagorinsky model, U-99
dynOneEqEddy model, U-99
dynSmagorinsky model, U-99
E
eConstThermo model, U-97, U-175
edgeGrading keyword, U-137
edgeMesh
library, U-95
edges keyword, U-135
Edit menu, U-163
Edit Color Map button, U-161
egrMixture model, U-96, U-176
electrostaticFoam solver, U-88
empty
boundary condition, P-63, P-69, U-20,
U-126, U-131
empty
keyword entry, U-130
Enable Line Series button, U-36
endTime keyword, U-24, U-108
engine
library, U-96
engineCompRatio utility, U-93
engineFoam solver, U-87
engineSwirl utility, U-89
ensight74FoamExec utility, U-168
ENSIGHT7 INPUT
environment variable, U-169
ENSIGHT7 READER
environment variable, U-169
ensightFoamReader utility, U-91
enstrophy utility, U-91
environment variable
CEI ARCH, U-169
CEI HOME, U-169
ENSIGHT7 INPUT, U-169
ENSIGHT7 READER, U-169
FOAM RUN, U-101
WM ARCH, U-76
WM COMPILER BIN, U-76
WM COMPILER DIR, U-76
WM COMPILER LIB, U-76
WM COMPILER, U-76
WM COMPILE OPTION, U-76
WM DIR, U-76
WM JAVAC OPTION, U-76
WM LINK LANGUAGE, U-76
WM MPLIB, U-76
WM OPTIONS, U-76
WM PROJECT DIR, U-76
WM PROJECT INST DIR, U-76
WM PROJECT LANGUAGE, U-76
WM PROJECT USER DIR, U-76
WM PROJECT VERSION, U-76
WM PROJECT, U-76
Open∇FOAM-1.6
U-186 Index
WM SHELL, U-76
wmake, U-75
ePsiThermo model, U-96, U-176
equilibriumCO utility, U-93
equilibriumFlameT utility, U-93
errorEstimation
library, U-95
errorReduction keyword, U-149
estimateScalarError utility, U-93
Euler
keyword entry, U-116
Euler implicit
diﬀerencing, P-39
temporal discretisation, P-42
examples
decompression of a tank, P-62
ﬂow around a cylinder, P-45
ﬂow over backward step, P-53
Hartmann problem, P-67
supersonic ﬂow over forward step, P-58
execFlowFunctionObjects utility, U-93
expandDictionary utility, U-94
expansionRatio keyword, U-148
explicit
temporal discretisation, P-42
exponential model, U-97
extrude2DMesh utility, U-89
extrudeMesh utility, U-89
F
face class, P-31
face keyword, U-171
faceAreaPair
keyword entry, U-119
faces
dictionary, U-125, U-132
FDIC
keyword entry, U-119
featureAngle keyword, U-148
features keyword, U-143
ﬁeld
U, U-24
p, U-24
decomposition, U-81
FieldField<Type> template class, P-32
ﬁeldFunctionObjects
library, U-95
ﬁelds, P-29
mapping, U-155
ﬁelds tools, U-94, U-95
fields keyword, U-170
Field<Type> template class, P-29
fieldValues keyword, U-59
ﬁeldview9Reader utility, U-91
ﬁle
Make/ﬁles, U-74
controlDict, P-49
ﬁles, U-73
g, U-59
options, U-73
snappyHexMeshDict, U-141
transportProperties, U-59
ﬁle format, U-102
ﬁles ﬁle, U-73
finalLayerRatio keyword, U-148
ﬁnancialFoam solver, U-88
ﬁnite volume
discretisation, P-27
mesh, P-31
ﬁniteVolume
library, U-95
ﬁniteVolume tools, U-95
ﬁniteVolumeCalculus class, P-33
ﬁniteVolumeMethod class, P-33
firstTime keyword, U-108
fixed
keyword entry, U-109
ﬁxedGradient
boundary condition, U-132
ﬁxedValue
boundary condition, U-132
ﬂattenMesh utility, U-90
ﬂow
free surface, U-56
laminar, U-19
steady, turbulent, P-53
supersonic, P-58
turbulent, U-19
ﬂow around a cylinder, P-45
ﬂow over backward step, P-53
ﬂowType utility, U-91
ﬂuent3DMeshToFoam utility, U-89
ﬂuentInterface directory, U-166
ﬂuentMeshToFoam utility, U-89, U-149
ﬂuxCorrectedVelocity
boundary condition, U-133
fluxRequired keyword, U-111
OpenFOAM
cases, U-101
FOAM RUN
environment variable, U-101
foamCalc utility, U-34
foamCalcFunctions
library, U-95
foamCorrectVrt script/alias, U-154
foamDataToFluent utility, U-91, U-166
foamDebugSwitches utility, U-94
FoamFile keyword, U-103
Open∇FOAM-1.6
Index U-187
foamFile
keyword entry, U-170
foamFormatConvert utility, U-94
foamInfoExec utility, U-94
foamJob script/alias, U-173
foamLog script/alias, U-173
foamMeshToFluent utility, U-89, U-166
foamToEnsight utility, U-91
foamToEnsightParts utility, U-91
foamToFieldview9 utility, U-91
foamToGMV utility, U-91
foamToStarMesh utility, U-89
foamToVTK utility, U-91
foamUpgradeFvSolution utility, U-89
forces
library, U-95
foreground
process, U-26
format keyword, U-103
fourth
keyword entry, U-114, U-115
functions keyword, U-110
fvc class, P-36
fvc member function
curl, P-37
d2dt2, P-37
ddt, P-37
div, P-37
gGrad, P-37
grad, P-37
laplacian, P-37
lsGrad, P-37
snGrad, P-37
snGradCorrection, P-37
sqrGradGrad, P-37
fvDOM
library, U-96
fvm class, P-36
fvm member function
d2dt2, P-37
ddt, P-37
div, P-37
laplacian, P-37
Su, P-37
SuSp, P-37
fvMatrices tools, U-95
fvMatrix template class, P-33
fvMesh class, P-31
fvMesh tools, U-95
fvMotionSolver
library, U-95
fvSchemes
dictionary, U-61, U-102, U-110, U-111
fvSchemes class, P-36
fvSchemes
menu entry, U-52
fvSolution
dictionary, U-102, U-117
G
g ﬁle, U-59
gambitToFoam utility, U-89, U-149
GAMG
keyword entry, U-53, U-118, U-119
Gamma
keyword entry, U-113
Gamma diﬀerencing, P-38
Gauss
keyword entry, U-114
Gauss’s theorem, P-36
GaussSeidel
keyword entry, U-119
General window panel, U-163
general model, U-97
general
keyword entry, U-109
geometric-algebraic multi-grid, U-119
GeometricBoundaryField template class, P-32
geometricField<Type> template class, P-32
geometry keyword, U-142
gGrad
fvc member function, P-37
global tools, U-94
gmshToFoam utility, U-89
gnuplot
keyword entry, U-109, U-170
grad
fvc member function, P-37
(Grad Grad) squared, P-37
gradient, P-37, P-40
Gauss scheme, P-40
Gauss’s theorem, U-52
least square ﬁt, U-52
least squares method, P-40, U-52
surface normal, P-40
gradSchemes keyword, U-111
graph tools, U-94
graphFormat keyword, U-109
GuldersEGRLaminarFlameSpeed model, U-97
GuldersLaminarFlameSpeed model, U-97
H
hConstThermo model, U-97, U-175
Help menu, U-163
HerschelBulkley model, U-99
hhuMixtureThermo model, U-96, U-176
hierarchical
keyword entry, U-82, U-83
Open∇FOAM-1.6
U-188 Index
homogeneousMixture model, U-96, U-176
hPolynomialThermo model, U-97, U-175
hPsiMixtureThermo model, U-96, U-176
hPsiThermo model, U-96, U-176
hRhoMixtureThermo model, U-96, U-176
hRhoThermo model, U-96, U-176
I
I
tensor member function, P-25
icoErrorEstimate utility, U-93
icoFoam solver, U-19, U-23, U-24, U-26, U-85
icoMomentError utility, U-94
icoPolynomial model, U-97, U-175
ideasToFoam utility, U-149
ideasUnvToFoam utility, U-89
identities, see tensor, identities
identity, see tensor, identity
incompressibleLESModels
library, U-99
incompressibleRASModels
library, U-98
incompressibleTransportModels
library, P-55, U-99
incompressibleTurbulenceModels
library, P-55
index
notation, P-16, P-17
Information window panel, U-160
inhomogeneousMixture model, U-96, U-176
inlet
boundary condition, P-69
inletOutlet
boundary condition, U-133
inner product, see tensor, inner product
inside
keyword entry, U-145
insideCells utility, U-90
interDyMFoam solver, U-86
interfaceProperties model, U-99
interFoam solver, U-87
internalField keyword, U-22, U-106
interPhaseChangeFoam solver, U-87
interpolation tools, U-95
interpolationScheme keyword, U-170
interpolations tools, U-94
interpolationSchemes keyword, U-111
inv
tensor member function, P-25
J
janafThermo model, U-97, U-175
jplot
keyword entry, U-109, U-170
K
kEpsilon model, U-98
keyword
FoamFile, U-103
LESmodel, U-179
RASModel, U-179
addLayersControls, U-142
adjustTimeStep, U-60
agglomerator, U-119
arc, U-135
blocks, U-22, U-32, U-136
block, U-135
boundaryField, U-22, U-106
boxToCell, U-59
cAlpha, U-62
cacheAgglomeration, U-120
castellatedMeshControls, U-142
castellatedMesh, U-142
class, U-103
cloud, U-171
convertToMeters, U-134, U-135
curve, U-171
debug, U-142
defaultFieldValues, U-59
deltaT, U-108
delta, U-83, U-179
dimensions, U-22, U-106
distributed, U-83, U-84
divSchemes, U-111
doLayers, U-142
edgeGrading, U-137
edges, U-135
endTime, U-24, U-108
errorReduction, U-149
expansionRatio, U-148
face, U-171
featureAngle, U-148
features, U-143
fieldValues, U-59
fields, U-170
finalLayerRatio, U-148
firstTime, U-108
fluxRequired, U-111
format, U-103
functions, U-110
geometry, U-142
gradSchemes, U-111
graphFormat, U-109
internalField, U-22, U-106
interpolationSchemes, U-111
interpolationScheme, U-170
laplacianSchemes, U-111
latestTime, U-39
layers, U-148
Open∇FOAM-1.6
Index U-189
leastSquares, U-52
levels, U-146
libs, U-80, U-110
locationInMesh, U-143, U-145
location, U-103
manualCoeffs, U-83
maxBoundarySkewness, U-149
maxConcave, U-149
maxCo, U-60
maxDeltaT, U-60
maxFaceThicknessRatio, U-148
maxGlobalCells, U-143
maxInternalSkewness, U-149
maxLocalCells, U-143
maxNonOrtho, U-149
maxThicknessToMedialRatio, U-148
mergeLevels, U-120
mergePatchPairs, U-135
mergeTolerance, U-142
meshQualityControls, U-142
method, U-83
metisCoeffs, U-83
midPointAndFace, U-171
midPoint, U-171
minArea, U-149
minDeterminant, U-149
minFaceWeight, U-149
minFlatness, U-149
minMedianAxisAngle, U-148
minRefinementCells, U-143
minThickness, U-148
minTriangleTwist, U-149
minTwist, U-149
minVolRatio, U-149
minVol, U-149
mode, U-145
nAlphaSubCycles, U-62
nBufferCellsNoExtrude, U-148
nCellsBetweenLevels, U-143
nFaces, U-126
nFinestSweeps, U-120
nGrow, U-148
nLayerIter, U-148
nPostSweeps, U-120
nPreSweeps, U-120
nRelaxIter, U-146, U-148
nRelaxedIter, U-148
nSmoothNormals, U-148
nSmoothPatch, U-146
nSmoothScale, U-149
nSmoothSurfaceNormals, U-148
nSmoothThickness, U-148
nSolveIter, U-146
numberOfSubdomains, U-83
n, U-83
object, U-103
order, U-83
pRefCell, U-25, U-121
pRefValue, U-25, U-121
patchMap, U-156
patches, U-135, U-137
pdRefCell, U-121
pdRefValue, U-121
preconditioner, U-118, U-119
pressure, U-50
printCoeffs, U-42
processorWeights, U-82
processorWeights, U-83
purgeWrite, U-109
refGradient, U-132
refinementRegions, U-143, U-146
refinementSurfaces, U-143
refinementRegions, U-145
regions, U-59
relTol, U-53, U-118
relativeSizes, U-148
relaxed, U-149
resolveFeatureAngle, U-143, U-144
roots, U-83, U-84
runTimeModifiable, U-109
scotchCoeffs, U-83
setFormat, U-170
sets, U-170
simpleGrading, U-136
simulationType, U-42, U-60, U-178
smoother, U-120
snGradSchemes, U-111
snapControls, U-142
snap, U-142
solvers, U-117
solver, U-53, U-118
spline, U-135
startFace, U-126
startFrom, U-23, U-108
startTime, U-23, U-108
stopAt, U-108
strategy, U-82, U-83
surfaceFormat, U-170
surfaces, U-170
thermoType, U-175
timeFormat, U-109
timePrecision, U-109
timeScheme, U-111
tolerance, U-53, U-118, U-146
topoSetSource, U-59
traction, U-50
turbulence, U-179
type, U-128, U-129
Open∇FOAM-1.6
U-190 Index
uniform, U-171
valueFraction, U-132
value, U-23, U-132
version, U-103
vertices, U-22, U-135
writeCompression, U-109
writeControl, U-24, U-60, U-108
writeFormat, U-55, U-109
writeInterval, U-24, U-33, U-109
writePrecision, U-109
<LESmodel>Coeffs, U-179
<RASModel>Coeffs, U-179
<delta>Coeffs, U-179
keyword entry
CrankNicholson, U-116
CrossPowerLaw, U-59
DICGaussSeidel, U-119
DIC, U-119
DILU, U-119
Euler, U-116
FDIC, U-119
GAMG, U-53, U-118, U-119
Gamma, U-113
GaussSeidel, U-119
Gauss, U-114
LESmodel, U-42, U-178
MGridGen, U-119
MUSCL, U-113
Newtonian, U-59
PBiCG, U-118
PCG, U-118
QUICK, U-113, U-116
RASmodel, U-42, U-178
SFCD, U-113, U-116
UMIST, U-112
adjustableRunTime, U-60, U-109
arc, U-136
ascii, U-109
backward, U-116
binary, U-109
bounded, U-114, U-115
cellPointFace, U-170
cellPoint, U-170
cell, U-170
clockTime, U-109
compressed, U-109
corrected, U-114, U-115
cpuTime, U-109
cubicCorrected, U-116
cubicCorrection, U-113
cyclic, U-130
diagonal, U-119
distance, U-145, U-171
dx, U-170
empty, U-130
faceAreaPair, U-119
fixed, U-109
foamFile, U-170
fourth, U-114, U-115
general, U-109
gnuplot, U-109, U-170
hierarchical, U-82, U-83
inside, U-145
jplot, U-109, U-170
laminar, U-42, U-178
latestTime, U-108
leastSquares, U-114
limitedCubic, U-113
limitedLinear, U-113
limited, U-114, U-115
linearUpwind, U-113, U-116
linear, U-113, U-116
line, U-136
manual, U-82, U-83
metis, U-82, U-83
midPoint, U-113
nextWrite, U-108
noWriteNow, U-108
none, U-112, U-119
null, U-170
outside, U-145
patch, U-130, U-172
polyLine, U-136
polySpline, U-136
processor, U-130
raw, U-109, U-170
runTime, U-33, U-108
scientific, U-109
scotch, U-82, U-83
simpleSpline, U-136
simple, U-82, U-83
skewLinear, U-113, U-116
smoothSolver, U-118
startTime, U-23, U-108
steadyState, U-116
stl, U-170
symmetryPlane, U-130
timeStep, U-24, U-33, U-108
uncompressed, U-109
uncorrected, U-114, U-115
upwind, U-113, U-116
vanLeer, U-113
vtk, U-170
wall, U-130
wedge, U-130
writeControl, U-108
writeNow, U-108
xmgr, U-109, U-170
Open∇FOAM-1.6
Index U-191
xyz, U-171
x, U-171
y, U-171
z, U-171
kivaToFoam utility, U-89
kOmega model, U-98
kOmegaSST model, U-98, U-99
Kronecker delta, P-20
L
lagrangian
library, U-95
lagrangianIntermediate
library, U-95
Lambda2 utility, U-91
LamBremhorstKE model, U-98
laminar model, U-98
laminar
keyword entry, U-42, U-178
laminarFlameSpeedModels
library, U-97
laplaceFilter model, U-98
Laplacian, P-38
laplacian, P-37
laplacian
fvc member function, P-37
fvm member function, P-37
laplacianFoam solver, U-85
laplacianSchemes keyword, U-111
latestTime
keyword entry, U-108
latestTime keyword, U-39
LaunderGibsonRSTM model, U-98
LaunderSharmaKE model, U-98
layers keyword, U-148
leastSquares
keyword entry, U-114
leastSquares keyword, U-52
LESdeltas
library, U-98
LESﬁlters
library, U-98
LESmodel
keyword entry, U-42, U-178
LESmodel keyword, U-179
LESProperties
dictionary, U-179
levels keyword, U-146
libraries, U-69
library
Chung, U-97
LESdeltas, U-98
LESﬁlters, U-98
MGridGenGAMGAgglomeration, U-96
ODE, U-95
OSspeciﬁc, U-96
OpenFOAM, U-94
P1, U-96
PV3FoamReader, U-159
PVFoamReader, U-159
Wallis, U-97
autoMesh, U-95
barotropicCompressibilityModels, U-97
basicThermophysicalModels, U-96
chemistryModel, U-97
coalCombustion, U-95
compressibleLESModels, U-99
compressibleRASModels, U-98
conversion, U-96
decompositionMethods, U-96
dieselSpray, U-95
dsmc, U-95
dynamicFvMesh, U-95
dynamicMesh, U-95
edgeMesh, U-95
engine, U-96
errorEstimation, U-95
ﬁeldFunctionObjects, U-95
ﬁniteVolume, U-95
foamCalcFunctions, U-95
forces, U-95
fvDOM, U-96
fvMotionSolver, U-95
incompressibleLESModels, U-99
incompressibleRASModels, U-98
incompressibleTransportModels, P-55, U-99
incompressibleTurbulenceModels, P-55
lagrangianIntermediate, U-95
lagrangian, U-95
laminarFlameSpeedModels, U-97
linear, U-97
liquidMixture, U-98
liquids, U-98
meshTools, U-95
molecularMeasurements, U-95
molecule, U-95
pdf, U-97
postCalc, U-95
potential, U-95
primitive, P-23
radiation, U-96
randomProcesses, U-96
reactionThermophysicalModels, U-96
sampling, U-95
solidMixture, U-98
solidParticle, U-96
solids, U-98
specie, U-97
Open∇FOAM-1.6
U-192 Index
surfMesh, U-95
systemCall, U-95
thermophysicalFunctions, U-97
thermophysical, U-175
topoChangerFvMesh, U-95
triSurface, U-95
utilityFunctionObjects, U-95
vtkFoam, U-159
vtkPV3Foam, U-159
libs keyword, U-80, U-110
lid-driven cavity ﬂow, U-19
LienCubicKE model, U-98
LienCubicKELowRe model, U-98
LienLeschzinerLowRe model, U-98
Lights window panel, U-163
limited
keyword entry, U-114, U-115
limitedCubic
keyword entry, U-113
limitedLinear
keyword entry, U-113
line
keyword entry, U-136
Line Style menu, U-36
linear
library, U-97
linear
keyword entry, U-113, U-116
linearUpwind
keyword entry, U-113, U-116
liquid
electrically-conducting, P-67
liquidMixture
library, U-98
liquids
library, U-98
lists, P-29
List<Type> template class, P-29
location keyword, U-103
locationInMesh keyword, U-143, U-145
locDynOneEqEddy model, U-99
lowReOneEqEddy model, U-99
LRDDiﬀStress model, U-99
LRR model, U-98
lsGrad
fvc member function, P-37
M
Mach utility, U-92
mag
tensor member function, P-25
magnetohydrodynamics, P-67
magSqr
tensor member function, P-25
Make directory, U-73
make script/alias, U-71
Make/ﬁles ﬁle, U-74
manual
keyword entry, U-82, U-83
manualCoeffs keyword, U-83
mapFields utility, U-32, U-39, U-43, U-55, U-89,
U-155
mapping
ﬁelds, U-155
Marker Style menu, U-36
matrices tools, U-94
max
tensor member function, P-25
maxBoundarySkewness keyword, U-149
maxCo keyword, U-60
maxConcave keyword, U-149
maxDeltaT keyword, U-60
maxFaceThicknessRatio keyword, U-148
maxGlobalCells keyword, U-143
maxInternalSkewness keyword, U-149
maxLocalCells keyword, U-143
maxNonOrtho keyword, U-149
maxThicknessToMedialRatio keyword, U-148
mdEquilibrationFoam solver, U-88
mdFoam solver, U-88
mdInitialise utility, U-89
mechanicalProperties
dictionary, U-51
memory tools, U-94
menu
Color By, U-162
Current Time Controls, U-28, U-161
Edit, U-163
Help, U-163
Line Style, U-36
Marker Style, U-36
Plot Type, U-35
VCR Controls, U-28, U-161
View, U-163
menu entry
Plot Over Line, U-35
Save Animation, U-165
Save Screenshot, U-165
Settings, U-163
Show Color Legend, U-28
Solid Color, U-162
Toolbars, U-163
View Settings..., U-25
View Settings, U-26, U-163
Wireframe, U-162
fvSchemes, U-52
mergeLevels keyword, U-120
mergeMeshes utility, U-90
Open∇FOAM-1.6
Index U-193
mergeOrSplitBaﬄes utility, U-90
mergePatchPairs keyword, U-135
mergeTolerance keyword, U-142
mesh
1-dimensional, U-126
1D, U-126
2-dimensional, U-126
2D, U-126
axi-symmetric, U-126
basic, P-31
block structured, U-132
decomposition, U-81
description, U-123
ﬁnite volume, P-31
generation, U-132, U-140
grading, U-132, U-136
grading, example of, P-53
non-orthogonal, P-45
reﬁnement, P-62
resolution, U-30
speciﬁcation, U-123
split-hex, U-140
Stereolithography (STL), U-140
surface, U-140
validity constraints, U-123
meshes tools, U-94
meshQualityControls keyword, U-142
meshTools
library, U-95
message passing interface
openMPI, U-83
method keyword, U-83
metis
keyword entry, U-82, U-83
metisCoeffs keyword, U-83
MGridGen
keyword entry, U-119
MGridGenGAMGAgglomeration
library, U-96
mhdFoam solver, P-69, U-88
midPoint
keyword entry, U-113
midPoint keyword, U-171
midPointAndFace keyword, U-171
min
tensor member function, P-25
minArea keyword, U-149
minDeterminant keyword, U-149
minFaceWeight keyword, U-149
minFlatness keyword, U-149
minMedianAxisAngle keyword, U-148
MINMOD diﬀerencing, P-38
minRefinementCells keyword, U-143
minThickness keyword, U-148
minTriangleTwist keyword, U-149
minTwist keyword, U-149
minVol keyword, U-149
minVolRatio keyword, U-149
mirrorMesh utility, U-90
mixed
boundary condition, U-132
mixedSmagorinsky model, U-99
mixtureAdiabaticFlameT utility, U-93
mode keyword, U-145
model
APIfunctions, U-97
BirdCarreau, U-99
CrossPowerLaw, U-99
DeardorﬀDiﬀStress, U-99
GuldersEGRLaminarFlameSpeed, U-97
GuldersLaminarFlameSpeed, U-97
HerschelBulkley, U-99
LRDDiﬀStress, U-99
LRR, U-98
LamBremhorstKE, U-98
LaunderGibsonRSTM, U-98
LaunderSharmaKE, U-98
LienCubicKELowRe, U-98
LienCubicKE, U-98
LienLeschzinerLowRe, U-98
NSRDSfunctions, U-97
Newtonian, U-99
NonlinearKEShih, U-98
PrandtlDelta, U-98
RNGkEpsilon, U-98
RosinRammler, U-97
Smagorinsky2, U-99
Smagorinsky, U-99
SpalartAllmarasDDES, U-99
SpalartAllmarasIDDES, U-99
SpalartAllmaras, U-98, U-99
anisotropicFilter, U-98
basicMultiComponentMixture, U-96, U-176
chemistryModel, U-97
chemistrySolver, U-97
constLaminarFlameSpeed, U-97
constTransport, U-97, U-176
cubeRootVolDelta, U-98
dieselMixture, U-96, U-176
dynMixedSmagorinsky, U-99
dynOneEqEddy, U-99
dynSmagorinsky, U-99
eConstThermo, U-97, U-175
ePsiThermo, U-96, U-176
egrMixture, U-96, U-176
exponential, U-97
general, U-97
hConstThermo, U-97, U-175
Open∇FOAM-1.6
U-194 Index
hPolynomialThermo, U-97, U-175
hPsiMixtureThermo, U-96, U-176
hPsiThermo, U-96, U-176
hRhoMixtureThermo, U-96, U-176
hRhoThermo, U-96, U-176
hhuMixtureThermo, U-96, U-176
homogeneousMixture, U-96, U-176
icoPolynomial, U-97, U-175
inhomogeneousMixture, U-96, U-176
interfaceProperties, U-99
janafThermo, U-97, U-175
kEpsilon, U-98
kOmegaSST, U-98, U-99
kOmega, U-98
laminar, U-98
laplaceFilter, U-98
locDynOneEqEddy, U-99
lowReOneEqEddy, U-99
mixedSmagorinsky, U-99
multiComponentMixture, U-96, U-176
normal, U-97
oneEqEddy, U-99
perfectGas, U-97, U-175
polynomialTransport, U-97, U-176
powerLaw, U-99
pureMixture, U-96, U-176
qZeta, U-98
reactingMixture, U-96, U-176
realizableKE, U-98
scaleSimilarity, U-99
simpleFilter, U-98
smoothDelta, U-98
specieThermo, U-97, U-176
spectEddyVisc, U-99
sutherlandTransport, U-97, U-176
uniform, U-97
veryInhomogeneousMixture, U-96, U-176
modifyMesh utility, U-91
molecularMeasurements
library, U-95
molecule
library, U-95
momentScalarError utility, U-94
moveDynamicMesh utility, U-90
moveEngineMesh utility, U-90
moveMesh utility, U-90
movingWallVelocity
boundary condition, U-133
MPI
openMPI, U-83
mshToFoam utility, U-89
multiComponentMixture model, U-96, U-176
multigrid
geometric-algebraic, U-119
multiphaseInterFoam solver, U-87
MUSCL
keyword entry, U-113
N
n keyword, U-83
nabla
operator, P-27
nAlphaSubCycles keyword, U-62
nBufferCellsNoExtrude keyword, U-148
nCellsBetweenLevels keyword, U-143
neighbour
dictionary, U-125
netgenNeutralToFoam utility, U-89
Newtonian
keyword entry, U-59
Newtonian model, U-99
nextWrite
keyword entry, U-108
nFaces keyword, U-126
nFinestSweeps keyword, U-120
nGrow keyword, U-148
nLayerIter keyword, U-148
non-orthogonal mesh, P-45
none
keyword entry, U-112, U-119
NonlinearKEShih model, U-98
nonNewtonianIcoFoam solver, U-86
normal model, U-97
noWriteNow
keyword entry, U-108
nPostSweeps keyword, U-120
nPreSweeps keyword, U-120
nRelaxedIter keyword, U-148
nRelaxIter keyword, U-146, U-148
nSmoothNormals keyword, U-148
nSmoothPatch keyword, U-146
nSmoothScale keyword, U-149
nSmoothSurfaceNormals keyword, U-148
nSmoothThickness keyword, U-148
nSolveIter keyword, U-146
NSRDSfunctions model, U-97
null
keyword entry, U-170
numberOfSubdomains keyword, U-83
O
object keyword, U-103
objToVTK utility, U-90
ODE
library, U-95
oneEqEddy model, U-99
Opacity text box, U-163
OpenFOAM
Open∇FOAM-1.6
Index U-195
applications, U-69
ﬁle format, U-102
libraries, U-69
OpenFOAM
library, U-94
OpenFOAM ﬁle syntax
//, U-102
openMPI
message passing interface, U-83
MPI, U-83
operator
scalar, P-28
vector, P-27
Options window, U-163
options ﬁle, U-73
order keyword, U-83
Orientation Axes button, U-26, U-163
OSspeciﬁc
library, U-96
outer product, see tensor, outer product
outlet
boundary condition, P-69
outletInlet
boundary condition, U-133
outside
keyword entry, U-145
owner
dictionary, U-125
P
p ﬁeld, U-24
P1
library, U-96
paraFoam, U-25, U-159
parallel
running, U-81
partialSlip
boundary condition, U-133
particleTracks utility, U-92
patch
boundary condition, U-131
patch
keyword entry, U-130, U-172
patchAverage utility, U-92
patches keyword, U-135, U-137
patchIntegrate utility, U-92
patchMap keyword, U-156
patchSummary utility, U-94
PBiCG
keyword entry, U-118
PCG
keyword entry, U-118
pdf
library, U-97
pdfPlot utility, U-93
pdRefCell keyword, U-121
pdRefValue keyword, U-121
PDRFoam solver, U-87
Pe utility, U-92
perfectGas model, U-97, U-175
permutation symbol, P-19
pimpleDyMFoam solver, U-86
pimpleFoam solver, U-86
Pipeline Browser window, U-25, U-160
PISO
dictionary, U-25
pisoFoam solver, U-19, U-86
Plot Over Line
menu entry, U-35
Plot Type menu, U-35
plot3dToFoam utility, U-89
pointField class, P-31
pointField<Type> template class, P-33
points
dictionary, U-125, U-132
polyBoundaryMesh class, P-31
polyDualMesh utility, U-90
polyLine
keyword entry, U-136
polyMesh directory, U-102, U-125
polyMesh class, P-31, U-123, U-125
polynomialTransport model, U-97, U-176
polyPatch class, P-31
polyPatchList class, P-31
polySpline
keyword entry, U-136
porousExplicitSourceReactingParcelFoam solver,
U-88
post-processing, U-159
post-processing
paraFoam, U-159
postCalc
library, U-95
postChannel utility, U-93
potential
library, U-95
potentialFoam solver, P-46, U-85
pow
tensor member function, P-25
powerLaw model, U-99
pPrime2 utility, U-92
PrandtlDelta model, U-98
preconditioner keyword, U-118, U-119
pRefCell keyword, U-25, U-121
pRefValue keyword, U-25, U-121
pressure keyword, U-50
pressure waves
in liquids, P-62
Open∇FOAM-1.6
U-196 Index
pressureDirectedInletVelocity
boundary condition, U-133
pressureInletVelocity
boundary condition, U-133
pressureOutlet
boundary condition, P-63
pressureTransmissive
boundary condition, U-133
primitive
library, P-23
primitives tools, U-94
printCoeffs keyword, U-42
processorWeights keyword, U-82
probeLocations utility, U-92
process
background, U-26, U-81
foreground, U-26
processor
boundary condition, U-131
processor
keyword entry, U-130
processorN directory, U-82
processorWeights keyword, U-83
Properties window panel, U-28, U-160
ptot utility, U-93
pureMixture model, U-96, U-176
purgeWrite keyword, U-109
PV3FoamReader
library, U-159
PV3FoamReader utility, U-91
PVFoamReader
library, U-159
PVFoamReader utility, U-91
Q
Q utility, U-92
QUICK
keyword entry, U-113, U-116
qZeta model, U-98
R
R utility, U-92
radiation
library, U-96
randomProcesses
library, U-96
RASModel keyword, U-179
RASmodel
keyword entry, U-42, U-178
raw
keyword entry, U-109, U-170
reactingFoam solver, U-87
reactingMixture model, U-96, U-176
reactingParcelFoam solver, U-88
reactionThermophysicalModels
library, U-96
realizableKE model, U-98
reconstructPar utility, U-85, U-93
reconstructParMesh utility, U-93
redistributeMeshPar utility, U-93
refGradient keyword, U-132
reﬁneHexMesh utility, U-91
refinementRegions keyword, U-145
reﬁnementLevel utility, U-91
refinementRegions keyword, U-143, U-146
refinementSurfaces keyword, U-143
reﬁneMesh utility, U-90
reﬁneWallLayer utility, U-91
Region Status window panel, U-25
regions keyword, U-59
relative tolerance, U-118
relativeSizes keyword, U-148
relaxed keyword, U-149
relTol keyword, U-53, U-118
removeFaces utility, U-91
Render View window, U-164
Render View window panel, U-163
Render View Options window, U-163
renumberMesh utility, U-90
Rescale to Data Range button, U-28
Reset button, U-160
resolveFeatureAngle keyword, U-143, U-144
restart, U-39
Reynolds number, U-19, U-23
rhoCentralFoam solver, U-86
rhoPisoFoam solver, U-86
rhoPimpleFoam solver, U-86
rhoPorousSimpleFoam solver, U-86
rhopSonicFoam solver, U-86
rhoReactingFoam solver, U-87
rhoSimpleFoam solver, U-86
rhoSonicFoam solver, U-86
rmdepall script/alias, U-76
RNGkEpsilon model, U-98
roots keyword, U-83, U-84
RosinRammler model, U-97
rotateMesh utility, U-90
run
parallel, U-81
run directory, U-101
runTime
keyword entry, U-33, U-108
runTimeModifiable keyword, U-109
S
sammToFoam utility, U-90
sample utility, U-93, U-169
sampling
Open∇FOAM-1.6
Index U-197
library, U-95
Save Animation
menu entry, U-165
Save Screenshot
menu entry, U-165
scalar, P-16
operator, P-28
scalar class, P-23
scalarField class, P-29
scalarTransportFoam solver, U-85
scale
tensor member function, P-25
scalePoints utility, U-153
scaleSimilarity model, U-99
scientific
keyword entry, U-109
scotch
keyword entry, U-82, U-83
scotchCoeffs keyword, U-83
script/alias
foamCorrectVrt, U-154
foamJob, U-173
foamLog, U-173
make, U-71
rmdepall, U-76
wclean, U-75
wmake, U-71
second time derivative, P-37
Seed window, U-164
selectCells utility, U-91
Set Solid Color button, U-162
setFields utility, U-58, U-59, U-89
setFormat keyword, U-170
sets keyword, U-170
setSet utility, U-90
setsToZones utility, U-90
Settings
menu entry, U-163
settlingFoam solver, U-87
SFCD
keyword entry, U-113, U-116
shallowWaterFoam solver, U-86
shape, U-136
Show Color Legend
menu entry, U-28
SI units, U-105
simple
keyword entry, U-82, U-83
simpleFilter model, U-98
simpleFoam solver, P-54, U-86
simpleGrading keyword, U-136
simpleSpline
keyword entry, U-136
simulationType keyword, U-42, U-60, U-178
skew
tensor member function, P-25
skewLinear
keyword entry, U-113, U-116
slice class, P-31
slip
boundary condition, U-133
Smagorinsky model, U-99
Smagorinsky2 model, U-99
smapToFoam utility, U-91
smoothDelta model, U-98
smoother keyword, U-120
smoothSolver
keyword entry, U-118
snap keyword, U-142
snapControls keyword, U-142
snappyHexMesh utility
background mesh, U-142
cell removal, U-144
cell splitting, U-143
mesh layers, U-146
meshing process, U-141
snapping to surfaces, U-146
snappyHexMesh utility, U-89, U-140
snappyHexMeshDict ﬁle, U-141
snGrad
fvc member function, P-37
snGradCorrection
fvc member function, P-37
snGradSchemes keyword, U-111
Solid Color
menu entry, U-162
solidDisplacementFoam solver, U-88
solidDisplacementFoam solver, U-51
solidEquilibriumDisplacementFoam solver, U-88
solidMixture
library, U-98
solidParticle
library, U-96
solids
library, U-98
solver
PDRFoam, U-87
XiFoam, U-87
blockMesh, P-47
boundaryFoam, U-85
bubbleFoam, U-86
buoyantBoussinesqPisoFoam, U-87
buoyantBoussinesqSimpleFoam, U-87
buoyantPisoFoam, U-87
buoyantSimpleFoam, U-87
buoyantSimpleRadiationFoam, U-87
cavitatingFoam, U-86
channelFoam, U-85
Open∇FOAM-1.6
U-198 Index
chtMultiRegionFoam, U-87
coalChemistryFoam, U-88
coldEngineFoam, U-87
compressibleInterDyMFoam, U-86
compressibleInterFoam, U-86
dieselEngineFoam, U-87
dieselFoam, U-87
dnsFoam, U-87
dsmcFoam, U-88
electrostaticFoam, U-88
engineFoam, U-87
ﬁnancialFoam, U-88
icoFoam, U-19, U-23, U-24, U-26, U-85
interDyMFoam, U-86
interFoam, U-87
interPhaseChangeFoam, U-87
laplacianFoam, U-85
mdEquilibrationFoam, U-88
mdFoam, U-88
mhdFoam, P-69, U-88
multiphaseInterFoam, U-87
nonNewtonianIcoFoam, U-86
pimpleDyMFoam, U-86
pimpleFoam, U-86
pisoFoam, U-19, U-86
porousExplicitSourceReactingParcelFoam,
U-88
potentialFoam, P-46, U-85
reactingFoam, U-87
reactingParcelFoam, U-88
rhoCentralFoam, U-86
rhoPisoFoam, U-86
rhoPimpleFoam, U-86
rhoPorousSimpleFoam, U-86
rhoReactingFoam, U-87
rhoSimpleFoam, U-86
rhoSonicFoam, U-86
rhopSonicFoam, U-86
scalarTransportFoam, U-85
settlingFoam, U-87
shallowWaterFoam, U-86
simpleFoam, P-54, U-86
solidDisplacementFoam, U-88
solidDisplacementFoam, U-51
solidEquilibriumDisplacementFoam, U-88
sonicDyMFoam, U-86
sonicFoam, P-60, U-86
sonicLiquidFoam, P-63, U-86
twoLiquidMixingFoam, U-87
twoPhaseEulerFoam, U-87
uncoupledKinematicParcelFoam, U-88
solver keyword, U-53, U-118
solver relative tolerance, U-118
solver tolerance, U-118
solvers keyword, U-117
sonicDyMFoam solver, U-86
sonicFoam solver, P-60, U-86
sonicLiquidFoam solver, P-63, U-86
source, P-37
SpalartAllmaras model, U-98, U-99
SpalartAllmarasDDES model, U-99
SpalartAllmarasIDDES model, U-99
specie
library, U-97
specieThermo model, U-97, U-176
spectEddyVisc model, U-99
spline keyword, U-135
splitCells utility, U-91
splitMesh utility, U-90
splitMeshRegions utility, U-90
sqr
tensor member function, P-25
sqrGradGrad
fvc member function, P-37
star4ToFoam utility, U-90
startFace keyword, U-126
startFrom keyword, U-23, U-108
starToFoam utility, U-90, U-149
startTime
keyword entry, U-23, U-108
startTime keyword, U-23, U-108
steady ﬂow
turbulent, P-53
steadyState
keyword entry, U-116
Stereolithography (STL), U-140
stitchMesh utility, U-90
stl
keyword entry, U-170
stopAt keyword, U-108
strategy keyword, U-82, U-83
streamFunction utility, U-92
stress analysis of plate with hole, U-46
stressComponents utility, U-92
Style window panel, U-25, U-162
Su
fvm member function, P-37
subsetMesh utility, U-91
summation convention, P-17
SUPERBEE diﬀerencing, P-38
supersonic ﬂow, P-58
supersonic ﬂow over forward step, P-58
supersonicFreeStream
boundary condition, U-133
surface mesh, U-140
surfaceField<Type> template class, P-33
surfaceFormat keyword, U-170
surfaceMesh tools, U-95
Open∇FOAM-1.6
Index U-199
surfaceNormalFixedValue
boundary condition, U-133
surfaces keyword, U-170
surfMesh
library, U-95
SuSp
fvm member function, P-37
sutherlandTransport model, U-97, U-176
symm
tensor member function, P-25
symmetryPlane
boundary condition, P-63, U-131
symmetryPlane
keyword entry, U-130
symmTensorField class, P-29
symmTensorThirdField class, P-29
system directory, P-49, U-102
systemCall
library, U-95
T
T()
tensor member function, P-25
template class
GeometricBoundaryField, P-32
fvMatrix, P-33
dimensioned<Type>, P-25
FieldField<Type>, P-32
Field<Type>, P-29
geometricField<Type>, P-32
List<Type>, P-29
pointField<Type>, P-33
surfaceField<Type>, P-33
volField<Type>, P-33
temporal discretisation, P-42
Crank Nicholson, P-42
Euler implicit, P-42
explicit, P-42
in OpenFOAM, P-43
tensor, P-15
addition, P-17
algebraic operations, P-17
algebraic operations in OpenFOAM, P-23
antisymmetric, see tensor, skew
calculus, P-27
classes in OpenFOAM, P-23
cofactors, P-22
component average, P-20
component maximum, P-20
component minimum, P-20
determinant, P-22
deviatoric, P-21
diagonal, P-21
dimension, P-16
double inner product, P-19
geometric transformation, P-20
Hodge dual, P-22
hydrostatic, P-21
identities, P-21
identity, P-20
inner product, P-18
inverse, P-22
magnitude, P-20
magnitude squared, P-20
mathematics, P-15
notation, P-17
nth power, P-20
outer product, P-19
rank, P-16
rank 3, P-16
scalar division, P-18
scalar multiplication, P-17
scale function, P-20
second rank, P-16
skew, P-21
square of, P-20
subtraction, P-17
symmetric, P-21
symmetric rank 2, P-16
symmetric rank 3, P-16
trace, P-21
transformation, P-20
transpose, P-16, P-21
triple inner product, P-19
vector cross product, P-19
tensor class, P-23
tensor member function
*, P-25
+, P-25
-, P-25
/, P-25
&, P-25
&&, P-25
^, P-25
cmptAv, P-25
cofactors, P-25
det, P-25
dev, P-25
diag, P-25
I, P-25
inv, P-25
mag, P-25
magSqr, P-25
max, P-25
min, P-25
pow, P-25
scale, P-25
skew, P-25
Open∇FOAM-1.6
U-200 Index
sqr, P-25
symm, P-25
T(), P-25
tr, P-25
transform, P-25
tensorField class, P-29
tensorThirdField class, P-29
tetgenToFoam utility, U-90
text box
Opacity, U-163
thermalProperties
dictionary, U-51
thermophysical
library, U-175
thermophysicalFunctions
library, U-97
thermophysicalProperties
dictionary, U-175
thermoType keyword, U-175
time
control, U-108
time derivative, P-37
ﬁrst, P-39
second, P-37, P-39
time step, U-24
timeFormat keyword, U-109
timePrecision keyword, U-109
timeScheme keyword, U-111
timeStep
keyword entry, U-24, U-33, U-108
tolerance
solver, U-118
solver relative, U-118
tolerance keyword, U-53, U-118, U-146
Toolbars
menu entry, U-163
tools
algorithms, U-94
cfdTools, U-95
containers, U-94
db, U-94
dimensionSet, U-94
dimensionedTypes, U-94
ﬁelds, U-94, U-95
ﬁniteVolume, U-95
fvMatrices, U-95
fvMesh, U-95
global, U-94
graph, U-94
interpolations, U-94
interpolation, U-95
matrices, U-94
memory, U-94
meshes, U-94
primitives, U-94
surfaceMesh, U-95
, U-95
topoChangerFvMesh
library, U-95
topoSetSource keyword, U-59
totalPressure
boundary condition, U-133
tr
tensor member function, P-25
trace, see tensor, trace
traction keyword, U-50
transform
tensor member function, P-25
transformPoints utility, U-91
transportProperties
dictionary, U-23, U-39, U-42
transportProperties ﬁle, U-59
triple inner product, P-19
triSurface
library, U-95
turbulence
dissipation, U-40
kinetic energy, U-40
length scale, U-41
turbulence keyword, U-179
turbulence model
RAS, U-40
turbulenceProperties
dictionary, U-42, U-60, U-178
turbulent ﬂow
steady, P-53
turbulentInlet
boundary condition, U-133
tutorials
breaking of a dam, U-56
lid-driven cavity ﬂow, U-19
stress analysis of plate with hole, U-46
tutorials directory, P-45, U-19
twoLiquidMixingFoam solver, U-87
twoPhaseEulerFoam solver, U-87
type keyword, U-128, U-129
U
U ﬁeld, U-24
Ucomponents utility, P-70
UMIST
keyword entry, U-112
uncompressed
keyword entry, U-109
uncorrected
keyword entry, U-114, U-115
uncoupledKinematicParcelFoam solver, U-88
uniform model, U-97
Open∇FOAM-1.6
Index U-201
uniform keyword, U-171
units
base, U-105
of measurement, P-25, U-105
S.I. base, P-25
SI, U-105
Syst`eme International, U-105
United States Customary System, U-105
USCS, U-105
Update GUI button, U-28, U-161
uprime utility, U-92
upwind
keyword entry, U-113, U-116
upwind diﬀerencing, P-38, U-61
USCS units, U-105
Use Parallel Projection button, U-25
Use parallel projection button, U-163
utility
Co, U-91
Lambda2, U-91
Mach, U-92
PV3FoamReader, U-91
PVFoamReader, U-91
Pe, U-92
Q, U-92
R, U-92
Ucomponents, P-70
adiabaticFlameT, U-93
ansysToFoam, U-89
applyBoundaryLayer, U-89
applyWallFunctionBoundaryConditions,
U-89
attachMesh, U-90
autoPatch, U-90
autoReﬁneMesh, U-91
blockMesh, U-38, U-89, U-132
boxTurb, U-89
cfx4ToFoam, U-89, U-149
changeDictionary, U-89
checkMesh, U-90, U-151
chemkinToFoam, U-93
collapseEdges, U-91
combinePatchFaces, U-91
createBaﬄes, U-90
createPatch, U-90
createTurbulenceFields, U-92
decomposePar, U-81, U-82, U-93
deformedGeom, U-90
dsmcFieldsCalc, U-93
dsmcInitialise, U-89
engineCompRatio, U-93
engineSwirl, U-89
ensight74FoamExec, U-168
ensightFoamReader, U-91
enstrophy, U-91
equilibriumCO, U-93
equilibriumFlameT, U-93
estimateScalarError, U-93
execFlowFunctionObjects, U-93
expandDictionary, U-94
extrude2DMesh, U-89
extrudeMesh, U-89
ﬁeldview9Reader, U-91
ﬂattenMesh, U-90
ﬂowType, U-91
ﬂuent3DMeshToFoam, U-89
ﬂuentMeshToFoam, U-89, U-149
foamCalc, U-34
foamDataToFluent, U-91, U-166
foamDebugSwitches, U-94
foamFormatConvert, U-94
foamInfoExec, U-94
foamMeshToFluent, U-89, U-166
foamToEnsightParts, U-91
foamToEnsight, U-91
foamToFieldview9, U-91
foamToGMV, U-91
foamToStarMesh, U-89
foamToVTK, U-91
foamUpgradeFvSolution, U-89
gambitToFoam, U-89, U-149
gmshToFoam, U-89
icoErrorEstimate, U-93
icoMomentError, U-94
ideasToFoam, U-149
ideasUnvToFoam, U-89
insideCells, U-90
kivaToFoam, U-89
mapFields, U-32, U-39, U-43, U-55, U-89,
U-155
mdInitialise, U-89
mergeMeshes, U-90
mergeOrSplitBaﬄes, U-90
mirrorMesh, U-90
mixtureAdiabaticFlameT, U-93
modifyMesh, U-91
momentScalarError, U-94
moveDynamicMesh, U-90
moveEngineMesh, U-90
moveMesh, U-90
mshToFoam, U-89
netgenNeutralToFoam, U-89
objToVTK, U-90
pPrime2, U-92
particleTracks, U-92
patchAverage, U-92
patchIntegrate, U-92
patchSummary, U-94
Open∇FOAM-1.6
U-202 Index
pdfPlot, U-93
plot3dToFoam, U-89
polyDualMesh, U-90
postChannel, U-93
probeLocations, U-92
ptot, U-93
reconstructParMesh, U-93
reconstructPar, U-85, U-93
redistributeMeshPar, U-93
reﬁneHexMesh, U-91
reﬁneMesh, U-90
reﬁneWallLayer, U-91
reﬁnementLevel, U-91
removeFaces, U-91
renumberMesh, U-90
rotateMesh, U-90
sammToFoam, U-90
sample, U-93, U-169
scalePoints, U-153
selectCells, U-91
setFields, U-58, U-59, U-89
setSet, U-90
setsToZones, U-90
smapToFoam, U-91
snappyHexMesh, U-89, U-140
splitCells, U-91
splitMeshRegions, U-90
splitMesh, U-90
star4ToFoam, U-90
starToFoam, U-90, U-149
stitchMesh, U-90
streamFunction, U-92
stressComponents, U-92
subsetMesh, U-91
tetgenToFoam, U-90
transformPoints, U-91
uprime, U-92
vorticity, U-92
wallGradU, U-92
wallHeatFlux, U-92
wallShearStress, U-92
wdot, U-93
writeCellCentres, U-93
writeMeshObj, U-90
yPlusLES, U-92
yPlusRAS, U-92
zipUpMesh, U-91
cellSet, U-90
faceSet, U-90
pointSet, U-90
utilityFunctionObjects
library, U-95
V
value keyword, U-23, U-132
valueFraction keyword, U-132
van Leer diﬀerencing, P-38
vanLeer
keyword entry, U-113
VCR Controls menu, U-28, U-161
vector, P-16
operator, P-27
unit, P-20
vector class, P-23, U-105
vector product, see tensor, vector cross product
vectorField class, P-29
version keyword, U-103
vertices keyword, U-22, U-135
veryInhomogeneousMixture model, U-96, U-176
View menu, U-163
View Settings
menu entry, U-26, U-163
View Settings...
menu entry, U-25
viscosity
kinematic, U-23, U-42
volField<Type> template class, P-33
vorticity utility, U-92
vtk
keyword entry, U-170
vtkFoam
library, U-159
vtkPV3Foam
library, U-159
W
wall
boundary condition, P-63, P-69, U-58,
U-131
wall
keyword entry, U-130
wallBuoyantPressure
boundary condition, U-133
wallGradU utility, U-92
wallHeatFlux utility, U-92
Wallis
library, U-97
wallShearStress utility, U-92
wclean script/alias, U-75
wdot utility, U-93
wedge
boundary condition, U-126, U-131, U-139
wedge
keyword entry, U-130
window
Chart Options, U-36
Color Legend, U-30
Open∇FOAM-1.6
Index U-203
Options, U-163
Pipeline Browser, U-25, U-160
Render View Options, U-163
Render View, U-164
Seed, U-164
window panel
Annotation, U-26, U-163
Color Legend, U-162
Color Scale, U-162
Display, U-25, U-28, U-160, U-161
General, U-163
Information, U-160
Lights, U-163
Properties, U-28, U-160
Region Status, U-25
Render View, U-163
Style, U-25, U-162
Wireframe
menu entry, U-162
WM ARCH
environment variable, U-76
WM COMPILE OPTION
environment variable, U-76
WM COMPILER
environment variable, U-76
WM COMPILER BIN
environment variable, U-76
WM COMPILER DIR
environment variable, U-76
WM COMPILER LIB
environment variable, U-76
WM DIR
environment variable, U-76
WM JAVAC OPTION
environment variable, U-76
WM LINK LANGUAGE
environment variable, U-76
WM MPLIB
environment variable, U-76
WM OPTIONS
environment variable, U-76
WM PROJECT
environment variable, U-76
WM PROJECT DIR
environment variable, U-76
WM PROJECT INST DIR
environment variable, U-76
WM PROJECT LANGUAGE
environment variable, U-76
WM PROJECT USER DIR
environment variable, U-76
WM PROJECT VERSION
environment variable, U-76
WM SHELL
environment variable, U-76
wmake
platforms, U-73
wmake script/alias, U-71
word class, P-25, P-31
writeCellCentres utility, U-93
writeCompression keyword, U-109
writeControl
keyword entry, U-108
writeControl keyword, U-24, U-60, U-108
writeFormat keyword, U-55, U-109
writeInterval keyword, U-24, U-33, U-109
writeMeshObj utility, U-90
writeNow
keyword entry, U-108
writePrecision keyword, U-109
X
x
keyword entry, U-171
XiFoam solver, U-87
xmgr
keyword entry, U-109, U-170
xyz
keyword entry, U-171
Y
y
keyword entry, U-171
yPlusLES utility, U-92
yPlusRAS utility, U-92
Z
z
keyword entry, U-171
zeroGradient
boundary condition, U-132
zipUpMesh utility, U-91
Open∇FOAM-1.6
