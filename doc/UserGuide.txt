Open∇FOAM
The Open Source CFD Toolbox
User Guide
Version 1.5
9th July 2008
U-2
Copyright c 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 OpenCFD Limited.
Permission is granted to copy, distribute and/or modify this document under the terms
of the GNU Free Documentation License, Version 1.2 published by the Free Software
Foundation; with no Invariant Sections, no Back-Cover Texts and one Front-Cover Text:
“Available free from openfoam.org.” A copy of the license is included in the section
entitled “GNU Free Documentation License”.
This document is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.
Typeset in LATEX.
Open∇FOAM-1.5
U-3
GNU Free Documentation License
Version 1.2, November 2002
Copyright c 2000,2001,2002 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
Everyone is permitted to copy and distribute verbatim copies of this license document, but
changing it is not allowed.
Preamble
The purpose of this License is to make a manual, textbook, or other functional and useful
document “free” in the sense of freedom: to assure everyone the eﬀective freedom to copy and
redistribute it, with or without modifying it, either commercially or noncommercially. Secon-
darily, this License preserves for the author and publisher a way to get credit for their work,
while not being considered responsible for modiﬁcations made by others.
This License is a kind of “copyleft”, which means that derivative works of the document
must themselves be free in the same sense. It complements the GNU General Public License,
which is a copyleft license designed for free software.
We have designed this License in order to use it for manuals for free software, because free
software needs free documentation: a free program should come with manuals providing the
same freedoms that the software does. But this License is not limited to software manuals; it
can be used for any textual work, regardless of subject matter or whether it is published as a
printed book. We recommend this License principally for works whose purpose is instruction or
reference.
1. APPLICABILITY AND DEFINITIONS
This License applies to any manual or other work, in any medium, that contains a notice placed
by the copyright holder saying it can be distributed under the terms of this License. Such a
notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under
the conditions stated herein. The “Document”, below, refers to any such manual or work.
Any member of the public is a licensee, and is addressed as “you”. You accept the license if
you copy, modify or distribute the work in a way requiring permission under copyright law.
A “Modiﬁed Version” of the Document means any work containing the Document or
a portion of it, either copied verbatim, or with modiﬁcations and/or translated into another
language.
A “Secondary Section” is a named appendix or a front-matter section of the Document
that deals exclusively with the relationship of the publishers or authors of the Document to
the Document’s overall subject (or to related matters) and contains nothing that could fall
directly within that overall subject. (Thus, if the Document is in part a textbook of mathe-
matics, a Secondary Section may not explain any mathematics.) The relationship could be a
matter of historical connection with the subject or with related matters, or of legal, commercial,
philosophical, ethical or political position regarding them.
The “Invariant Sections” are certain Secondary Sections whose titles are designated, as
being those of Invariant Sections, in the notice that says that the Document is released under
this License. If a section does not ﬁt the above deﬁnition of Secondary then it is not allowed to be
designated as Invariant. The Document may contain zero Invariant Sections. If the Document
does not identify any Invariant Sections then there are none.
The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts
or Back-Cover Texts, in the notice that says that the Document is released under this License.
A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.
A “Transparent” copy of the Document means a machine-readable copy, represented in
a format whose speciﬁcation is available to the general public, that is suitable for revising the
Open∇FOAM-1.5
U-4
document straightforwardly with generic text editors or (for images composed of pixels) generic
paint programs or (for drawings) some widely available drawing editor, and that is suitable for
input to text formatters or for automatic translation to a variety of formats suitable for input to
text formatters. A copy made in an otherwise Transparent ﬁle format whose markup, or absence
of markup, has been arranged to thwart or discourage subsequent modiﬁcation by readers is not
Transparent. An image format is not Transparent if used for any substantial amount of text. A
copy that is not “Transparent” is called “Opaque”.
Examples of suitable formats for Transparent copies include plain ASCII without markup,
Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD,
and standard-conforming simple HTML, PostScript or PDF designed for human modiﬁcation.
Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include
proprietary formats that can be read and edited only by proprietary word processors, SGML or
XML for which the DTD and/or processing tools are not generally available, and the machine-
generated HTML, PostScript or PDF produced by some word processors for output purposes
only.
The “Title Page” means, for a printed book, the title page itself, plus such following pages
as are needed to hold, legibly, the material this License requires to appear in the title page. For
works in formats which do not have any title page as such, “Title Page” means the text near
the most prominent appearance of the work’s title, preceding the beginning of the body of the
text.
A section “Entitled XYZ” means a named subunit of the Document whose title either is
precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another
language. (Here XYZ stands for a speciﬁc section name mentioned below, such as “Acknowl-
edgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Ti-
tle” of such a section when you modify the Document means that it remains a section “Entitled
XYZ” according to this deﬁnition.
The Document may include Warranty Disclaimers next to the notice which states that this
License applies to the Document. These Warranty Disclaimers are considered to be included by
reference in this License, but only as regards disclaiming warranties: any other implication that
these Warranty Disclaimers may have is void and has no eﬀect on the meaning of this License.
2. VERBATIM COPYING
You may copy and distribute the Document in any medium, either commercially or noncom-
mercially, provided that this License, the copyright notices, and the license notice saying this
License applies to the Document are reproduced in all copies, and that you add no other con-
ditions whatsoever to those of this License. You may not use technical measures to obstruct or
control the reading or further copying of the copies you make or distribute. However, you may
accept compensation in exchange for copies. If you distribute a large enough number of copies
you must also follow the conditions in section 3.
You may also lend copies, under the same conditions stated above, and you may publicly
display copies.
3. COPYING IN QUANTITY
If you publish printed copies (or copies in media that commonly have printed covers) of the
Document, numbering more than 100, and the Document’s license notice requires Cover Texts,
you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts:
Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers
must also clearly and legibly identify you as the publisher of these copies. The front cover must
present the full title with all words of the title equally prominent and visible. You may add
other material on the covers in addition. Copying with changes limited to the covers, as long as
they preserve the title of the Document and satisfy these conditions, can be treated as verbatim
copying in other respects.
Open∇FOAM-1.5
U-5
If the required texts for either cover are too voluminous to ﬁt legibly, you should put the ﬁrst
ones listed (as many as ﬁt reasonably) on the actual cover, and continue the rest onto adjacent
pages.
If you publish or distribute Opaque copies of the Document numbering more than 100, you
must either include a machine-readable Transparent copy along with each Opaque copy, or state
in or with each Opaque copy a computer-network location from which the general network-using
public has access to download using public-standard network protocols a complete Transparent
copy of the Document, free of added material. If you use the latter option, you must take
reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated location until at least one
year after the last time you distribute an Opaque copy (directly or through your agents or
retailers) of that edition to the public.
It is requested, but not required, that you contact the authors of the Document well before
redistributing any large number of copies, to give them a chance to provide you with an updated
version of the Document.
4. MODIFICATIONS
You may copy and distribute a Modiﬁed Version of the Document under the conditions of
sections 2 and 3 above, provided that you release the Modiﬁed Version under precisely this
License, with the Modiﬁed Version ﬁlling the role of the Document, thus licensing distribution
and modiﬁcation of the Modiﬁed Version to whoever possesses a copy of it. In addition, you
must do these things in the Modiﬁed Version:
A. Use in the Title Page (and on the covers, if any) a title distinct from that of the Document,
and from those of previous versions (which should, if there were any, be listed in the
History section of the Document). You may use the same title as a previous version if the
original publisher of that version gives permission.
B. List on the Title Page, as authors, one or more persons or entities responsible for au-
thorship of the modiﬁcations in the Modiﬁed Version, together with at least ﬁve of the
principal authors of the Document (all of its principal authors, if it has fewer than ﬁve),
unless they release you from this requirement.
C. State on the Title page the name of the publisher of the Modiﬁed Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modiﬁcations adjacent to the other copyright
notices.
F. Include, immediately after the copyright notices, a license notice giving the public per-
mission to use the Modiﬁed Version under the terms of this License, in the form shown
in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections and required Cover Texts
given in the Document’s license notice.
H. Include an unaltered copy of this License.
I. Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating
at least the title, year, new authors, and publisher of the Modiﬁed Version as given on the
Title Page. If there is no section Entitled “History” in the Document, create one stating
the title, year, authors, and publisher of the Document as given on its Title Page, then
add an item describing the Modiﬁed Version as stated in the previous sentence.
Open∇FOAM-1.5
U-6
J. Preserve the network location, if any, given in the Document for public access to a Trans-
parent copy of the Document, and likewise the network locations given in the Document
for previous versions it was based on. These may be placed in the “History” section. You
may omit a network location for a work that was published at least four years before the
Document itself, or if the original publisher of the version it refers to gives permission.
K. For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the
section, and preserve in the section all the substance and tone of each of the contributor
acknowledgements and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document, unaltered in their text and in their
titles. Section numbers or the equivalent are not considered part of the section titles.
M. Delete any section Entitled “Endorsements”. Such a section may not be included in the
Modiﬁed Version.
N. Do not retitle any existing section to be Entitled “Endorsements” or to conﬂict in title
with any Invariant Section.
O. Preserve any Warranty Disclaimers.
If the Modiﬁed Version includes new front-matter sections or appendices that qualify as
Secondary Sections and contain no material copied from the Document, you may at your option
designate some or all of these sections as invariant. To do this, add their titles to the list of
Invariant Sections in the Modiﬁed Version’s license notice. These titles must be distinct from
any other section titles.
You may add a section Entitled “Endorsements”, provided it contains nothing but endorse-
ments of your Modiﬁed Version by various parties–for example, statements of peer review or
that the text has been approved by an organization as the authoritative deﬁnition of a standard.
You may add a passage of up to ﬁve words as a Front-Cover Text, and a passage of up to
25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modiﬁed Version.
Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through
arrangements made by) any one entity. If the Document already includes a cover text for the
same cover, previously added by you or by arrangement made by the same entity you are acting
on behalf of, you may not add another; but you may replace the old one, on explicit permission
from the previous publisher that added the old one.
The author(s) and publisher(s) of the Document do not by this License give permission to
use their names for publicity for or to assert or imply endorsement of any Modiﬁed Version.
5. COMBINING DOCUMENTS
You may combine the Document with other documents released under this License, under
the terms deﬁned in section 4 above for modiﬁed versions, provided that you include in the
combination all of the Invariant Sections of all of the original documents, unmodiﬁed, and list
them all as Invariant Sections of your combined work in its license notice, and that you preserve
all their Warranty Disclaimers.
The combined work need only contain one copy of this License, and multiple identical In-
variant Sections may be replaced with a single copy. If there are multiple Invariant Sections
with the same name but diﬀerent contents, make the title of each such section unique by adding
at the end of it, in parentheses, the name of the original author or publisher of that section if
known, or else a unique number. Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
In the combination, you must combine any sections Entitled “History” in the various origi-
nal documents, forming one section Entitled “History”; likewise combine any sections Entitled
“Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections
Entitled “Endorsements”.
Open∇FOAM-1.5
U-7
6. COLLECTIONS OF DOCUMENTS
You may make a collection consisting of the Document and other documents released under
this License, and replace the individual copies of this License in the various documents with a
single copy that is included in the collection, provided that you follow the rules of this License
for verbatim copying of each of the documents in all other respects.
You may extract a single document from such a collection, and distribute it individually
under this License, provided you insert a copy of this License into the extracted document, and
follow this License in all other respects regarding verbatim copying of that document.
7. AGGREGATION WITH INDEPENDENT WORKS
A compilation of the Document or its derivatives with other separate and independent docu-
ments or works, in or on a volume of a storage or distribution medium, is called an “aggregate”
if the copyright resulting from the compilation is not used to limit the legal rights of the com-
pilation’s users beyond what the individual works permit. When the Document is included in
an aggregate, this License does not apply to the other works in the aggregate which are not
themselves derivative works of the Document.
If the Cover Text requirement of section 3 is applicable to these copies of the Document,
then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts
may be placed on covers that bracket the Document within the aggregate, or the electronic
equivalent of covers if the Document is in electronic form. Otherwise they must appear on
printed covers that bracket the whole aggregate.
8. TRANSLATION
Translation is considered a kind of modiﬁcation, so you may distribute translations of the
Document under the terms of section 4. Replacing Invariant Sections with translations requires
special permission from their copyright holders, but you may include translations of some or
all Invariant Sections in addition to the original versions of these Invariant Sections. You
may include a translation of this License, and all the license notices in the Document, and any
Warranty Disclaimers, provided that you also include the original English version of this License
and the original versions of those notices and disclaimers. In case of a disagreement between
the translation and the original version of this License or a notice or disclaimer, the original
version will prevail.
If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”,
the requirement (section 4) to Preserve its Title (section 1) will typically require changing the
actual title.
9. TERMINATION
You may not copy, modify, sublicense, or distribute the Document except as expressly provided
for under this License. Any other attempt to copy, modify, sublicense or distribute the Document
is void, and will automatically terminate your rights under this License. However, parties who
have received copies, or rights, from you under this License will not have their licenses terminated
so long as such parties remain in full compliance.
10. FUTURE REVISIONS OF THIS LICENSE
The Free Software Foundation may publish new, revised versions of the GNU Free Documenta-
tion License from time to time. Such new versions will be similar in spirit to the present version,
but may diﬀer in detail to address new problems or concerns. See http://www.gnu.org/copyleft/.
Each version of the License is given a distinguishing version number. If the Document
speciﬁes that a particular numbered version of this License “or any later version” applies to it,
you have the option of following the terms and conditions either of that speciﬁed version or of
Open∇FOAM-1.5
U-8
any later version that has been published (not as a draft) by the Free Software Foundation. If
the Document does not specify a version number of this License, you may choose any version
ever published (not as a draft) by the Free Software Foundation.
Open∇FOAM-1.5
U-9
Trademarks
ANSYS is a registered trademark of ANSYS Inc.
CFX is a registered trademark of AEA Technology Engineering Software Ltd.
CHEMKIN is a registered trademark of Sandia National Laboratories
CORBA is a registered trademark of Object Management Group Inc.
openDX is a registered trademark of International Business Machines Corporation
EnSight is a registered trademark of Computational Engineering International Ltd.
AVS/Express is a registered trademark of Advanced Visual Systems Inc.
Fluent is a registered trademark of Fluent Inc.
GAMBIT is a registered trademark of Fluent Inc.
Fieldview is a registered trademark of Intelligent Light
Icem-CFD is a registered trademark of ICEM Technologies GmbH
I-DEAS is a registered trademark of Structural Dynamics Research Corporation
JAVA is a registered trademark of Sun Microsystems Inc.
Linux is a registered trademark of Linus Torvalds
MICO is a registered trademark of MICO Inc.
ParaView is a registered trademark of Kitware
STAR-CD is a registered trademark of Computational Dynamics Ltd.
UNIX is a registered trademark of The Open Group
Open∇FOAM-1.5
U-10
Open∇FOAM-1.5
Contents
Copyright Notice U-2
GNU Free Documentation Licence U-3
1. APPLICABILITY AND DEFINITIONS . . . . . . . . . . . . . . . . . U-3
2. VERBATIM COPYING . . . . . . . . . . . . . . . . . . . . . . . . . U-4
3. COPYING IN QUANTITY . . . . . . . . . . . . . . . . . . . . . . . . U-4
4. MODIFICATIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-5
5. COMBINING DOCUMENTS . . . . . . . . . . . . . . . . . . . . . . U-6
6. COLLECTIONS OF DOCUMENTS . . . . . . . . . . . . . . . . . . . U-7
7. AGGREGATION WITH INDEPENDENT WORKS . . . . . . . . . . U-7
8. TRANSLATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-7
9. TERMINATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-7
10. FUTURE REVISIONS OF THIS LICENSE . . . . . . . . . . . . . . U-7
Trademarks U-9
Contents U-11
1 Introduction U-17
2 Tutorials U-19
2.1 Lid-driven cavity ﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . U-19
2.1.1 Pre-processing . . . . . . . . . . . . . . . . . . . . . . . . . . U-19
2.1.1.1 Mesh generation . . . . . . . . . . . . . . . . . . . U-20
2.1.1.2 Boundary and initial conditions . . . . . . . . . . . U-22
2.1.1.3 Physical properties . . . . . . . . . . . . . . . . . . U-23
2.1.1.4 Control . . . . . . . . . . . . . . . . . . . . . . . . U-23
2.1.1.5 Discretisation and linear-solver settings . . . . . . . U-25
2.1.2 Viewing the mesh . . . . . . . . . . . . . . . . . . . . . . . . U-25
2.1.3 Running an application . . . . . . . . . . . . . . . . . . . . . U-26
2.1.4 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-26
2.1.4.1 Contour plots . . . . . . . . . . . . . . . . . . . . . U-28
2.1.4.2 Vector plots . . . . . . . . . . . . . . . . . . . . . . U-28
2.1.4.3 Streamline plots . . . . . . . . . . . . . . . . . . . U-30
2.1.5 Increasing the mesh resolution . . . . . . . . . . . . . . . . . U-30
2.1.5.1 Creating a new case using an existing case . . . . . U-30
2.1.5.2 Creating the ﬁner mesh . . . . . . . . . . . . . . . U-32
2.1.5.3 Mapping the coarse mesh results onto the ﬁne mesh U-32
2.1.5.4 Control adjustments . . . . . . . . . . . . . . . . . U-33
2.1.5.5 Running the code as a background process . . . . . U-33
2.1.5.6 Vector plot with the reﬁned mesh . . . . . . . . . . U-33
U-12 Contents
2.1.5.7 Plotting graphs . . . . . . . . . . . . . . . . . . . . U-33
2.1.6 Introducing mesh grading . . . . . . . . . . . . . . . . . . . U-36
2.1.6.1 Creating the graded mesh . . . . . . . . . . . . . . U-36
2.1.6.2 Changing time and time step . . . . . . . . . . . . U-38
2.1.6.3 Mapping ﬁelds . . . . . . . . . . . . . . . . . . . . U-38
2.1.7 Increasing the Reynolds number . . . . . . . . . . . . . . . . U-39
2.1.7.1 Pre-processing . . . . . . . . . . . . . . . . . . . . U-39
2.1.7.2 Running the code . . . . . . . . . . . . . . . . . . . U-39
2.1.8 High Reynolds number ﬂow . . . . . . . . . . . . . . . . . . U-40
2.1.8.1 Pre-processing . . . . . . . . . . . . . . . . . . . . U-40
2.1.8.2 Running the code . . . . . . . . . . . . . . . . . . . U-41
2.1.9 Changing the case geometry . . . . . . . . . . . . . . . . . . U-42
2.1.10 Post-processing the modiﬁed geometry . . . . . . . . . . . . U-45
2.2 Stress analysis of a plate with a hole . . . . . . . . . . . . . . . . . U-45
2.2.1 Mesh generation . . . . . . . . . . . . . . . . . . . . . . . . U-46
2.2.1.1 Boundary and initial conditions . . . . . . . . . . . U-49
2.2.1.2 Mechanical properties . . . . . . . . . . . . . . . . U-49
2.2.1.3 Thermal properties . . . . . . . . . . . . . . . . . . U-50
2.2.1.4 Control . . . . . . . . . . . . . . . . . . . . . . . . U-50
2.2.1.5 Discretisation schemes and linear-solver control . . U-51
2.2.2 Running the code . . . . . . . . . . . . . . . . . . . . . . . . U-52
2.2.3 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-53
2.2.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-54
2.2.4.1 Increasing mesh resolution . . . . . . . . . . . . . . U-54
2.2.4.2 Introducing mesh grading . . . . . . . . . . . . . . U-54
2.2.4.3 Changing the plate size . . . . . . . . . . . . . . . U-55
2.3 Breaking of a dam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-55
2.3.1 Mesh generation . . . . . . . . . . . . . . . . . . . . . . . . U-56
2.3.2 Boundary conditions . . . . . . . . . . . . . . . . . . . . . . U-57
2.3.3 Setting initial ﬁeld . . . . . . . . . . . . . . . . . . . . . . . U-57
2.3.4 Fluid properties . . . . . . . . . . . . . . . . . . . . . . . . . U-58
2.3.5 Time step control . . . . . . . . . . . . . . . . . . . . . . . . U-58
2.3.6 Discretisation schemes . . . . . . . . . . . . . . . . . . . . . U-60
2.3.7 Linear-solver control . . . . . . . . . . . . . . . . . . . . . . U-61
2.3.8 Running the code . . . . . . . . . . . . . . . . . . . . . . . . U-61
2.3.9 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-61
2.3.10 Running in parallel . . . . . . . . . . . . . . . . . . . . . . . U-61
2.3.11 Post-processing a case run in parallel . . . . . . . . . . . . . U-64
3 Applications and libraries U-67
3.1 The programming language of OpenFOAM . . . . . . . . . . . . . . U-67
3.1.1 Language in general . . . . . . . . . . . . . . . . . . . . . . U-67
3.1.2 Object-orientation and C++ . . . . . . . . . . . . . . . . . . U-68
3.1.3 Equation representation . . . . . . . . . . . . . . . . . . . . U-68
3.1.4 Solver codes . . . . . . . . . . . . . . . . . . . . . . . . . . . U-69
3.2 Compiling applications and libraries . . . . . . . . . . . . . . . . . . U-69
3.2.1 Header .H ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . U-69
3.2.2 Compiling with wmake . . . . . . . . . . . . . . . . . . . . . U-71
3.2.2.1 Including headers . . . . . . . . . . . . . . . . . . . U-71
3.2.2.2 Linking to libraries . . . . . . . . . . . . . . . . . . U-72
3.2.2.3 Source ﬁles to be compiled . . . . . . . . . . . . . . U-72
Open∇FOAM-1.5
Contents U-13
3.2.2.4 Running wmake . . . . . . . . . . . . . . . . . . . . U-73
3.2.2.5 wmake environment variables . . . . . . . . . . . . U-73
3.2.3 Removing dependency lists: wclean and rmdepall . . . . . . . U-73
3.2.4 Compilation example: the turbFoam application . . . . . . . U-74
3.2.5 Debug messaging and optimisation switches . . . . . . . . . U-77
3.2.6 Linking new user-deﬁned libraries to existing applications . . U-78
3.3 Running applications . . . . . . . . . . . . . . . . . . . . . . . . . . U-79
3.4 Running applications in parallel . . . . . . . . . . . . . . . . . . . . U-79
3.4.1 Decomposition of mesh and initial ﬁeld data . . . . . . . . . U-79
3.4.2 Running a decomposed case . . . . . . . . . . . . . . . . . . U-81
3.4.3 Distributing data across several disks . . . . . . . . . . . . . U-82
3.4.4 Post-processing parallel processed cases . . . . . . . . . . . . U-82
3.4.4.1 Reconstructing mesh and data . . . . . . . . . . . U-83
3.4.4.2 Post-processing decomposed cases . . . . . . . . . . U-83
3.5 Standard solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-83
3.6 Standard utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-86
3.7 Standard libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-91
4 OpenFOAM cases U-97
4.1 File structure of OpenFOAM cases . . . . . . . . . . . . . . . . . . U-97
4.2 Basic input/output ﬁle format . . . . . . . . . . . . . . . . . . . . . U-98
4.2.1 General syntax rules . . . . . . . . . . . . . . . . . . . . . . U-98
4.2.2 Dictionaries . . . . . . . . . . . . . . . . . . . . . . . . . . . U-98
4.2.3 The data ﬁle header . . . . . . . . . . . . . . . . . . . . . . U-99
4.2.4 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-100
4.2.5 Scalars, vectors and tensors . . . . . . . . . . . . . . . . . . U-101
4.2.6 Dimensional units . . . . . . . . . . . . . . . . . . . . . . . . U-101
4.2.7 Dimensioned types . . . . . . . . . . . . . . . . . . . . . . . U-102
4.2.8 Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-102
4.2.9 Directives and macro substitutions . . . . . . . . . . . . . . U-103
4.3 Time and data input/output control . . . . . . . . . . . . . . . . . U-104
4.4 Numerical schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . U-106
4.4.1 Interpolation schemes . . . . . . . . . . . . . . . . . . . . . . U-108
4.4.1.1 Schemes for strictly bounded scalar ﬁelds . . . . . U-109
4.4.1.2 Schemes for vector ﬁelds . . . . . . . . . . . . . . . U-109
4.4.2 Surface normal gradient schemes . . . . . . . . . . . . . . . U-110
4.4.3 Gradient schemes . . . . . . . . . . . . . . . . . . . . . . . . U-110
4.4.4 Laplacian schemes . . . . . . . . . . . . . . . . . . . . . . . U-111
4.4.5 Divergence schemes . . . . . . . . . . . . . . . . . . . . . . . U-111
4.4.6 Time schemes . . . . . . . . . . . . . . . . . . . . . . . . . . U-112
4.4.7 Flux calculation . . . . . . . . . . . . . . . . . . . . . . . . . U-113
4.5 Solution and algorithm control . . . . . . . . . . . . . . . . . . . . . U-113
4.5.1 Linear solver control . . . . . . . . . . . . . . . . . . . . . . U-113
4.5.1.1 Solution tolerances . . . . . . . . . . . . . . . . . . U-114
4.5.1.2 Preconditioned conjugate gradient solvers . . . . . U-114
4.5.1.3 Smooth solvers . . . . . . . . . . . . . . . . . . . . U-115
4.5.1.4 Geometric-algebraic multi-grid solvers . . . . . . . U-115
4.5.2 Solution under-relaxation . . . . . . . . . . . . . . . . . . . U-116
4.5.3 PISO and SIMPLE algorithms . . . . . . . . . . . . . . . . . U-117
4.5.3.1 Pressure referencing . . . . . . . . . . . . . . . . . U-117
4.5.4 Other parameters . . . . . . . . . . . . . . . . . . . . . . . . U-117
Open∇FOAM-1.5
U-14 Contents
5 Mesh generation and conversion U-119
5.1 Mesh description . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-119
5.1.1 Mesh speciﬁcation and validity constraints . . . . . . . . . . U-119
5.1.1.1 Points . . . . . . . . . . . . . . . . . . . . . . . . . U-120
5.1.1.2 Faces . . . . . . . . . . . . . . . . . . . . . . . . . U-120
5.1.1.3 Cells . . . . . . . . . . . . . . . . . . . . . . . . . . U-120
5.1.1.4 Boundary . . . . . . . . . . . . . . . . . . . . . . . U-121
5.1.2 The polyMesh description . . . . . . . . . . . . . . . . . . . . U-121
5.1.3 The cellShape tools . . . . . . . . . . . . . . . . . . . . . . . U-122
5.1.4 1- and 2-dimensional and axi-symmetric problems . . . . . . U-122
5.2 Boundaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-124
5.2.1 Speciﬁcation of patch types in OpenFOAM . . . . . . . . . . U-124
5.2.2 Base types . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-126
5.2.3 Primitive types . . . . . . . . . . . . . . . . . . . . . . . . . U-127
5.2.4 Derived types . . . . . . . . . . . . . . . . . . . . . . . . . . U-127
5.3 Mesh generation with the blockMesh utility . . . . . . . . . . . . . . U-127
5.3.1 Writing a blockMeshDict ﬁle . . . . . . . . . . . . . . . . . . U-131
5.3.1.1 The vertices . . . . . . . . . . . . . . . . . . . . U-131
5.3.1.2 The edges . . . . . . . . . . . . . . . . . . . . . . U-131
5.3.1.3 The blocks . . . . . . . . . . . . . . . . . . . . . . U-132
5.3.1.4 The patches . . . . . . . . . . . . . . . . . . . . . U-133
5.3.2 Multiple blocks . . . . . . . . . . . . . . . . . . . . . . . . . U-134
5.3.3 Creating blocks with fewer than 8 vertices . . . . . . . . . . U-135
5.3.4 Running blockMesh . . . . . . . . . . . . . . . . . . . . . . . U-136
5.4 Mesh generation with the snappyHexMesh utility . . . . . . . . . . . U-136
5.4.1 The mesh generation process of snappyHexMesh . . . . . . . U-137
5.4.2 Creating the background hex mesh . . . . . . . . . . . . . . U-138
5.4.3 Cell splitting at feature edges and surfaces . . . . . . . . . . U-139
5.4.4 Cell removal . . . . . . . . . . . . . . . . . . . . . . . . . . . U-140
5.4.5 Cell splitting in speciﬁed regions . . . . . . . . . . . . . . . . U-141
5.4.6 Snapping to surfaces . . . . . . . . . . . . . . . . . . . . . . U-142
5.4.7 Mesh layers . . . . . . . . . . . . . . . . . . . . . . . . . . . U-142
5.4.8 Mesh quality controls . . . . . . . . . . . . . . . . . . . . . . U-144
5.5 Mesh conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-144
5.5.1 ﬂuentMeshToFoam . . . . . . . . . . . . . . . . . . . . . . . U-145
5.5.2 starToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-146
5.5.2.1 General advice on conversion . . . . . . . . . . . . U-146
5.5.2.2 Eliminating extraneous data . . . . . . . . . . . . . U-147
5.5.2.3 Removing default boundary conditions . . . . . . . U-147
5.5.2.4 Renumbering the model . . . . . . . . . . . . . . . U-148
5.5.2.5 Writing out the mesh data . . . . . . . . . . . . . . U-149
5.5.2.6 Problems with the .vrt ﬁle . . . . . . . . . . . . . . U-149
5.5.2.7 Converting the mesh to OpenFOAM format . . . . U-150
5.5.3 gambitToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . U-150
5.5.4 ideasToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-150
5.5.5 cfxToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-151
5.6 Mapping ﬁelds between diﬀerent geometries . . . . . . . . . . . . . U-151
5.6.1 Mapping consistent ﬁelds . . . . . . . . . . . . . . . . . . . . U-151
5.6.2 Mapping inconsistent ﬁelds . . . . . . . . . . . . . . . . . . . U-151
5.6.3 Mapping parallel cases . . . . . . . . . . . . . . . . . . . . . U-153
Open∇FOAM-1.5
Contents U-15
6 Post-processing U-155
6.1 paraFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-155
6.1.1 Overview of paraFoam . . . . . . . . . . . . . . . . . . . . . U-155
6.1.2 The Properties panel . . . . . . . . . . . . . . . . . . . . . . U-156
6.1.3 The Display panel . . . . . . . . . . . . . . . . . . . . . . . . U-157
6.1.4 The button toolbars . . . . . . . . . . . . . . . . . . . . . . U-159
6.1.5 Manipulating the view . . . . . . . . . . . . . . . . . . . . . U-159
6.1.5.1 View settings . . . . . . . . . . . . . . . . . . . . . U-159
6.1.5.2 General settings . . . . . . . . . . . . . . . . . . . U-159
6.1.6 Contour plots . . . . . . . . . . . . . . . . . . . . . . . . . . U-160
6.1.6.1 Introducing a cutting plane . . . . . . . . . . . . . U-160
6.1.7 Vector plots . . . . . . . . . . . . . . . . . . . . . . . . . . . U-160
6.1.7.1 Plotting at cell centres . . . . . . . . . . . . . . . . U-160
6.1.8 Streamlines . . . . . . . . . . . . . . . . . . . . . . . . . . . U-160
6.1.9 Image output . . . . . . . . . . . . . . . . . . . . . . . . . . U-161
6.1.10 Animation output . . . . . . . . . . . . . . . . . . . . . . . . U-161
6.2 Post-processing with Fluent . . . . . . . . . . . . . . . . . . . . . . U-162
6.3 Post-processing with Fieldview . . . . . . . . . . . . . . . . . . . . . U-163
6.4 Post-processing with EnSight . . . . . . . . . . . . . . . . . . . . . . U-163
6.4.1 Converting data to EnSight format . . . . . . . . . . . . . . U-164
6.4.2 The ensight74FoamExec reader module . . . . . . . . . . . . U-164
6.4.2.1 Conﬁguration of EnSight for the reader module . . U-164
6.4.2.2 Using the reader module . . . . . . . . . . . . . . . U-165
6.5 Sampling data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-165
6.6 Monitoring and managing jobs . . . . . . . . . . . . . . . . . . . . . U-168
6.6.1 The foamJob script for running jobs . . . . . . . . . . . . . . U-169
6.6.2 The foamLog script for monitoring jobs . . . . . . . . . . . . U-169
7 Models and physical properties U-171
7.1 Thermophysical models . . . . . . . . . . . . . . . . . . . . . . . . . U-171
7.1.1 Thermophysical property data . . . . . . . . . . . . . . . . . U-172
7.2 Turbulence models . . . . . . . . . . . . . . . . . . . . . . . . . . . U-174
A FoamX case manager (obsolete in v1.5) U-177
A.1 The name server and host browser . . . . . . . . . . . . . . . . . . . U-178
A.1.1 Notes for running the name server . . . . . . . . . . . . . . . U-179
A.2 The JAVA GUI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-179
A.3 The case browser . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-180
A.3.1 Opening a root directory . . . . . . . . . . . . . . . . . . . . U-182
A.3.2 Creating a new case . . . . . . . . . . . . . . . . . . . . . . U-182
A.3.3 Opening an existing case . . . . . . . . . . . . . . . . . . . . U-183
A.3.4 Deleting an existing case . . . . . . . . . . . . . . . . . . . . U-183
A.3.5 Cloning an existing case . . . . . . . . . . . . . . . . . . . . U-184
A.3.6 Unlocking an existing case . . . . . . . . . . . . . . . . . . . U-184
A.3.7 The process editor . . . . . . . . . . . . . . . . . . . . . . . U-185
A.3.8 Running OpenFOAM utilities . . . . . . . . . . . . . . . . . U-185
A.4 The case server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-186
A.4.1 Importing an existing mesh . . . . . . . . . . . . . . . . . . U-186
A.4.2 Reading a mesh . . . . . . . . . . . . . . . . . . . . . . . . . U-187
A.4.3 Setting boundary patches . . . . . . . . . . . . . . . . . . . U-187
A.4.4 Setting the ﬁelds . . . . . . . . . . . . . . . . . . . . . . . . U-187
Open∇FOAM-1.5
U-16 Contents
A.4.5 Editing the dictionaries . . . . . . . . . . . . . . . . . . . . . U-188
A.4.6 Saving data . . . . . . . . . . . . . . . . . . . . . . . . . . . U-189
A.4.7 Running solvers . . . . . . . . . . . . . . . . . . . . . . . . . U-189
A.4.8 Running utilities . . . . . . . . . . . . . . . . . . . . . . . . U-190
A.4.9 Closing the case server . . . . . . . . . . . . . . . . . . . . . U-190
A.5 Conﬁguration to run FoamX . . . . . . . . . . . . . . . . . . . . . . U-190
A.5.1 JAVA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-191
A.5.2 Paths to case ﬁles . . . . . . . . . . . . . . . . . . . . . . . . U-192
B Miscellaneous reference information U-193
B.1 Running a decomposed case in parallel using MPICH . . . . . . . . U-193
B.1.1 Same executable pathname on all nodes . . . . . . . . . . . U-193
B.1.2 Diﬀerent executable pathname on diﬀerent nodes . . . . . . U-194
Index U-195
Open∇FOAM-1.5
Chapter 1
Introduction
This guide accompanies the release of version 1.5 of the Open Source Field Operation
and Manipulation (OpenFOAM) C++ libraries. It provides a description of the basic
operation of OpenFOAM, ﬁrst through a set of tutorial exercises in chapter 2 and later
by a more detailed description of the individual components that make up OpenFOAM.
OpenFOAM is ﬁrst and foremost a C++ library, used primarily to create executa-
bles, known as applications. The applications fall into two categories: solvers, that are
each designed to solve a speciﬁc problem in continuum mechanics; and utilities, that are
designed to perform tasks that involve data manipulation. The OpenFOAM distribution
contains numerous solvers and utilities covering a wide range of problems, as described
in chapter 3.
One of the strengths of OpenFOAM is that new solvers and utilities can be created
by its users with some pre-requisite knowledge of the underlying method, physics and
programming techniques involved.
OpenFOAM is supplied with pre- and post-processing environments. The interface
to the pre- and post-processing are themselves OpenFOAM utilities, thereby ensuring
consistent data handling across all environments. The overall structure of OpenFOAM is
shown in Figure 1.1. The pre-processing and running of OpenFOAM cases is described
Applications
User
Tools
MeshingUtilities Standard
Applications
Others
e.g.EnSight
Post-processingSolvingPre-processing
Open Source Field Operation and Manipulation (OpenFOAM) C++ Library
ParaView
Figure 1.1: Overview of OpenFOAM structure.
in chapter 4 In chapter 5, we cover both the generation of meshes using the mesh gen-
erator supplied with OpenFOAM and conversion of mesh data generated by third-party
products. Post-processing is described in chapter 6.
During the development of OpenFOAM, some features are inevitably discontinued but
it may be that some users attempt to maintain those features in their personal modiﬁed
versions of OpenFOAM. Documentation relating to such features is not maintained but
can be found in appendices to this guide. In particular documentation relating to FoamX,
discontinued in version 1.5, can be found in Appendix A.
U-18 Introduction
Open∇FOAM-1.5
Chapter 2
Tutorials
In this chapter we shall describe in detail the process of setup, simulation and post-
processing for some OpenFOAM test cases, with the principal aim of introducing a user to
the basic procedures of running OpenFOAM. The $FOAM TUTORIALS directory contains
many more cases that demonstrate the use of all the solvers and many utilities supplied
with OpenFOAM. Before attempting to run the tutorials, the user must ﬁrst make sure
that they have installed OpenFOAM correctly.
The tutorial cases describe the use of the blockMesh pre-processing tool, case setup
and running OpenFOAM solvers and post-processing using paraFoam. Those users with
access to third-party post-processing tools supported in OpenFOAM have an option:
either they can follow the tutorials using paraFoam; or refer to the description of the use
of the third-party product in chapter 6 when post-processing is required.
Copies of all tutorials are available from the tutorials directory of the OpenFOAM
installation. The tutorials are organised into a set of subdirectories by solver, e.g. all the
icoFoam cases are stored within a subdirectory icoFoam. It is strongly recommended that
the user copy the tutorials directory into their local run directory. If not, they can be
easily copied by typing:
mkdir -p $FOAM RUN
cp -r $FOAM TUTORIALS $FOAM RUN
2.1 Lid-driven cavity ﬂow
This tutorial will describe how to pre-process, run and post-process a case involving
isothermal, incompressible ﬂow in a two-dimensional square domain. The geometry is
shown in Figure 2.1 in which all the boundaries of the square are walls. The top wall
moves in the x-direction at a speed of 1 m/s while the other 3 are stationary. Initially,
the ﬂow will be assumed laminar and will be solved on a uniform mesh using the icoFoam
solver for laminar, isothermal, incompressible ﬂow. During the course of the tutorial, the
eﬀect of increased mesh resolution and mesh grading towards the walls will be investigated.
Finally, the ﬂow Reynolds number will be increased and the turbFoam solver will be used
for turbulent, isothermal, incompressible ﬂow.
2.1.1 Pre-processing
Cases are setup in OpenFOAM by editing case ﬁles. Users should select an editor of choice
with which to do this, such as emacs, vi, gedit, kate, nedit, etc. Editing ﬁles is possible
in OpenFOAM because the I/O uses a dictionary format with keywords that convey
U-20 Tutorials
x
Ux = 1 m/s
d = 0.1 m
y
Figure 2.1: Geometry of the lid driven cavity.
suﬃcient meaning to be understood by even the least experienced users. In previous
versions of OpenFOAM, there existed FoamX, a GUI case editor, but so great was the
preference for editing ﬁles from the OpenFOAM users, that this was discontinued in
version 1.5 due to lack of interest in its maintenance.
A case being simulated involves data for mesh, ﬁelds, properties, control parameters,
etc. As described in section 4.1, in OpenFOAM this data is stored in a set of ﬁles within a
case directory rather than in a single case ﬁle, as is common with in many CFD packages.
The case directory is given a suitably descriptive name, e.g. the ﬁrst example case for
this tutorial is simply named cavity. In preparation of editing case ﬁles and running the
ﬁrst cavity case, the user should change to the case directory
cd $FOAM RUN/tutorials/icoFoam/cavity
2.1.1.1 Mesh generation
OpenFOAM always operates in a 3 dimensional Cartesian coordinate system and all
geometries are generated in 3 dimensions. OpenFOAM solves the case in 3 dimensions
by default but can be instructed to solve in 2 dimensions by specifying a ‘special’ empty
boundary condition on boundaries normal to the (3rd) dimension for which no solution
is required.
The cavity domain consists of a square of side length d = 0.1 m in the x-y plane. A
uniform mesh of 20 by 20 cells will be used initially. The block structure is shown in
Figure 2.2. The mesh generator supplied with OpenFOAM, blockMesh, generates meshes
from a description speciﬁed in an input dictionary, blockMeshDict located in the con-
stant/polyMesh directory for a given case. The blockMeshDict entries for this case are as
follows:
1 /*--------------------------------*- C++ -*----------------------------------*\
2 | ========= | |
3 | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox |
4 | \\ / O peration | Version: 1.5 |
5 | \\ / A nd | Web: http://www.OpenFOAM.org |
6 | \\/ M anipulation | |
7 \*---------------------------------------------------------------------------*/
8 FoamFile
9 {
10 version 2.0;
11 format ascii;
12 class dictionary;
13 object blockMeshDict;
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-21
3 2
4 5
7 6
0
z
x 1
y
Figure 2.2: Block structure of the mesh for the cavity.
14 }
15 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
16
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (1 0 0)
23 (1 1 0)
24 (0 1 0)
25 (0 0 0.1)
26 (1 0 0.1)
27 (1 1 0.1)
28 (0 1 0.1)
29 );
30
31 blocks
32 (
33 hex (0 1 2 3 4 5 6 7) (20 20 1) simpleGrading (1 1 1)
34 );
35
36 edges
37 (
38 );
39
40 patches
41 (
42 wall movingWall
43 (
44 (3 7 6 2)
45 )
46 wall fixedWalls
47 (
48 (0 4 7 3)
49 (2 6 5 1)
50 (1 5 4 0)
51 )
52 empty frontAndBack
53 (
54 (0 3 2 1)
55 (4 5 6 7)
56 )
57 );
58
59 mergePatchPairs
60 (
61 );
62
63 // ************************************************************************* //
The ﬁle ﬁrst contains header information in the form of a banner (lines 1-7), then ﬁle
information contained in a FoamFile sub-dictionary, delimited by curly braces ({...}).
For the remainder of the manual:
Open∇FOAM-1.5
U-22 Tutorials
For the sake of clarity and to save space, ﬁle headers, including the banner and
FoamFile sub-dictionary, will be removed from verbatim quoting of case ﬁles
The ﬁle ﬁrst speciﬁes coordinates of the block vertices; it then deﬁnes the blocks
(here, only 1) from the vertex labels and the number of cells within it; and ﬁnally, it deﬁnes
the boundary patches. The user is encouraged to consult section 5.3 to understand the
meaning of the entries in the blockMeshDict ﬁle.
The mesh is generated by running blockMesh on this blockMeshDict ﬁle. From within
the case directory, this is done, simply by typing in the terminal:
blockMesh
The running status of blockMesh is reported in the terminal window. Any mistakes in
the blockMeshDict ﬁle are picked up by blockMesh and the resulting error message directs
the user to the line in the ﬁle where the problem occurred. There should be no error
messages at this stage.
2.1.1.2 Boundary and initial conditions
Once the mesh generation is complete, the user can look at this initial ﬁelds set up for
this case. The case is set up to start at time t = 0 s, so the initial ﬁeld data is stored in
a 0 sub-directory of the cavity directory. The 0 sub-directory contains 2 ﬁles, p and U,
one for each of the pressure (p) and velocity (U) ﬁelds whose initial values and boundary
conditions must be set. Let us examine ﬁle p:
17 dimensions [0 2 -2 0 0 0 0];
18
19 internalField uniform 0;
20
21 boundaryField
22 {
23 movingWall
24 {
25 type zeroGradient;
26 }
27
28 fixedWalls
29 {
30 type zeroGradient;
31 }
32
33 frontAndBack
34 {
35 type empty;
36 }
37 }
38
39 // ************************************************************************* //
There are 3 principal entries in ﬁeld data ﬁles:
dimensions speciﬁes the dimensions of the ﬁeld, here kinematic pressure, i.e. m2
s−2
(see
section 4.2.6 for more information);
internalField the internal ﬁeld data which can be uniform, described by a single value;
or nonuniform, where all the values of the ﬁeld must be speciﬁed (see section 4.2.8
for more information);
boundaryField the boundary ﬁeld data that includes boundary conditions and data for
all the boundary patches (see section 4.2.8 for more information).
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-23
For this case cavity, the boundary consists of walls only, split into 2 patches named:
(1) fixedWalls for the ﬁxed sides and base of the cavity; (2) movingWall for the moving
top of the cavity. As walls, both are given a zeroGradient for p, meaning “the normal
gradient of pressure is zero”. The frontAndBack patch represents the front and back
planes of the 2D case and therefore must be set as empty.
In this case, as in most we encounter, the initial ﬁelds are set to be uniform. Here the
pressure is kinematic, and as an incompressible case, its absolute value is not relevant, so
is set to uniform 0 for convenience.
The user can similarly examine the velocity ﬁeld in the 0/U ﬁle. The dimensions are
those expected for velocity, the internal ﬁeld is initialised as uniform zero, which in the
case of velocity must be expressed by 3 vector components, i.e.uniform (0 0 0) (see
section 4.2.5 for more information).
The boundary ﬁeld for velocity requires the same boundary condition for the frontAndBack
patch. The other patches are walls: a no-slip condition is assumed on the fixedWalls,
hence a ﬁxedValue condition with a value of uniform (0 0 0). The top surface moves
at a speed of 1 m/s in the x-direction so requires a ﬁxedValue condition also but with
uniform (1 0 0).
2.1.1.3 Physical properties
The physical properties for the case are stored in dictionaries whose names are given the
suﬃx . . . Properties, located in the Dictionaries directory tree. For an icoFoam case,
the only property that must be speciﬁed is the kinematic viscosity which is stored from
the transportProperties dictionary. The user can check that the kinematic viscosity is
set correctly by opening the transportProperties dictionary to view/edit its entries. The
keyword for kinematic viscosity is nu, the phonetic label for the Greek symbol ν by which
it is represented in equations. Initially this case will be run with a Reynolds number of
10, where the Reynolds number is deﬁned as:
Re =
d|U|
ν
(2.1)
where d and |U| are the characteristic length and velocity respectively and ν is the
kinematic viscosity. Here d = 0.1 m, |U| = 1 m s−1
, so that for Re = 10, ν = 0.01 m2
s−1
.
The correct ﬁle entry for kinematic viscosity is thus speciﬁed below:
17 nu nu [0 2 -1 0 0 0 0] 0.01;
18
19 // ************************************************************************* //
2.1.1.4 Control
Input data relating to the control of time and reading and writing of the solution data are
read in from the controlDict dictionary. The user should view this ﬁle; as a case control
ﬁle, it is located in the system directory.
The start/stop times and the time step for the run must be set. OpenFOAM oﬀers
great ﬂexibility with time control which is described in full in section 4.3. In this tutorial
we wish to start the run at time t = 0 which means that OpenFOAM needs to read ﬁeld
data from a directory named 0 — see section 4.1 for more information of the case ﬁle
structure. Therefore we set the startFrom keyword to startTime and then specify the
startTime keyword to be 0.
For the end time, we wish to reach the steady state solution where the ﬂow is circu-
lating around the cavity. As a general rule, the ﬂuid should pass through the domain 10
times to reach steady state in laminar ﬂow. In this case the ﬂow does not pass through
Open∇FOAM-1.5
U-24 Tutorials
this domain as there is no inlet or outlet, so instead the end time can be set to the time
taken for the lid to travel ten times across the cavity, i.e. 1 s; in fact, with hindsight, we
discover that 0.5 s is suﬃcient so we shall adopt this value. To specify this end time, we
must specify the stopAt keyword as endTime and then set the endTime keyword to 0.5.
Now we need to set the time step, represented by the keyword deltaT. To achieve
temporal accuracy and numerical stability when running icoFoam, a Courant number of
less than 1 is required. The Courant number is deﬁned for one cell as:
Co =
δt|U|
δx
(2.2)
where δt is the time step, |U| is the magnitude of the velocity through that cell and δx
is the cell size in the direction of the velocity. The ﬂow velocity varies across the domain
and we must ensure Co < 1 everywhere. We therefore choose δt based on the worst case:
the maximum Co corresponding to the combined eﬀect of a large ﬂow velocity and small
cell size. Here, the cell size is ﬁxed across the domain so the maximum Co will occur next
to the lid where the velocity approaches 1 m s−1
. The cell size is:
δx =
d
n
=
0.1
20
= 0.005 m (2.3)
Therefore to achieve a Courant number less than or equal to 1 throughout the domain
the time step deltaT must be set to less than or equal to:
δt =
Co δx
|U|
=
1 × 0.005
1
= 0.005 s (2.4)
As the simulation progresses we wish to write results at certain intervals of time that
we can later view with a post-processing package. The writeControl keyword presents
several options for setting the time at which the results are written; here we select the
timeStep option which speciﬁes that results are written every nth time step where the
value n is speciﬁed under the writeInterval keyword. Let us decide that we wish to
write our results at times 0.1, 0.2,. . . , 0.5 s. With a time step of 0.005 s, we therefore
need to output results at every 20th time time step and so we set writeInterval to 20.
OpenFOAM creates a new directory named after the current time, e.g. 0.1 s, on each
occasion that it writes a set of data, as discussed in full in section 4.1. In the icoFoam
solver, it writes out the results for each ﬁeld, U and p, into the time directories. For this
case, the entries in the controlDict are shown below:
17 application icoFoam;
18
19 startFrom startTime;
20
21 startTime 0;
22
23 stopAt endTime;
24
25 endTime 0.5;
26
27 deltaT 0.005;
28
29 writeControl timeStep;
30
31 writeInterval 20;
32
33 purgeWrite 0;
34
35 writeFormat ascii;
36
37 writePrecision 6;
38
39 writeCompression uncompressed;
40
41 timeFormat general;
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-25
42
43 timePrecision 6;
44
45 runTimeModifiable yes;
46
47 // ************************************************************************* //
2.1.1.5 Discretisation and linear-solver settings
The user speciﬁes the choice of ﬁnite volume discretisation schemes in the fvSchemes
dictionary in the system directory. The speciﬁcation of the linear equation solvers and
tolerances and other algorithm controls is made in the fvSolution dictionary, similarly in
the system directory. The user is free to view these dictionaries but we do not need to
discuss all their entries at this stage except for pRefCell and pRefValue in the PISO
sub-dictionary of the fvSolution dictionary. In a closed incompressible system such as the
cavity, pressure is relative: it is the pressure range that matters not the absolute values.
In cases such as this, the solver sets a reference level by pRefValue in cell pRefCell. In
this example both are set to 0. Changing either of these values will change the absolute
pressure ﬁeld, but not, of course, the relative pressure ﬁeld or velocity ﬁeld.
2.1.2 Viewing the mesh
Before the case is run it is a good idea to view the mesh to check for any errors. The mesh
is viewed in paraFoam, the post-processing tool supplied with OpenFOAM. The paraFoam
post-processing is started by typing in the terminal from within the case directory
paraFoam
Alternatively, it can be launched from another directory location with an optional
-case argument giving the case directory, e.g.
paraFoam -case $FOAM RUN/tutorials/icoFoam/cavity
This launches the ParaView window as shown in Figure 6.1. In the Pipeline Browser,
the user can see that ParaView has opened cavity.foam, the module for the cavity case.
Before clicking the Apply button, the user needs to select some geometry from the
Region Status and panel. Because the case is small, it is easiest to select all the data by
checking the box adjacent to the Region Status panel title, which automatically checks all
individual components within the respective panel.
The user should then click the Apply button to load the geometry into ParaView. The
user should then open the Display panel that controls the visual representation of the
selected module. Within the Display panel the user should do the following as shown in
Figure 2.3: (1) set Color by Solid Color; (2) click Set Solid Color and select an appro-
priate colour e.g. black (for a white background); (3) in the Style panel, select Wireframe
from the Representation menu. The background colour can be set by selecting View
Settings... from Edit in the top menu panel.
The user can try manipulating the view as described in section 6.1.5. In particular,
since this is a 2D case, it is recommended that Use Parallel Projection is selected in the
General panel of View Settings window selected from the Edit menu. This is described
in more detail in section 6.1.5.1. The Orientation Axes can be toggled on and oﬀ in the
Annotation window or moved by drag and drop with the mouse.
Open∇FOAM-1.5
U-26 Tutorials
Open Display panel
Select Color by Solid Color
Set Solid Color, e.g. black
Select Wireframe
Figure 2.3: Viewing the mesh in paraFoam.
2.1.3 Running an application
Like any UNIX/Linux executable, OpenFOAM applications can be run in two ways: as
a foreground process, i.e. one in which the shell waits until the command has ﬁnished
before giving a command prompt; as a background process, one which does not have to
be completed before the shell accepts additional commands.
On this occasion, we will run icoFoam in the foreground. The icoFoam solver is exe-
cuted either by entering the case directory and typing
icoFoam
at the command prompt, or with the optional -case argument giving the case directory,
e.g.
icoFoam -case $FOAM RUN/tutorials/icoFoam/cavity
The progress of the job is written to the terminal window. It tells the user the current
time, maximum Courant number, initial and ﬁnal residuals for all ﬁelds.
2.1.4 Post-processing
As soon as results are written to time directories, they can be viewed using paraFoam.
Return to the paraFoam window and select the Properties panel for the cavity.foam case
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-27
Open Display panel
Rescale to Data Range
Select Surface
Select Color by interpolated p
Figure 2.4: Displaying pressure contours for the cavity case.
Figure 2.5: Pressures in the cavity case.
Open∇FOAM-1.5
U-28 Tutorials
module. If the correct window panels for the case module do not seem to be present at
any time, please ensure that: cavity.foam is highlighted in blue; eye button alongside it
is switched on to show the graphics are enabled;
To prepare paraFoam to display the data of interest, we must ﬁrst load the data at
the required run time of 0.5 s. If the case was run while ParaView was open, the output
data in time directories will not be automatically loaded within ParaView. To load the
data the user should select Update GUI in the Properties window and then click the green
Apply button. The time data will be loaded into ParaView. In order to
2.1.4.1 Contour plots
To view pressure, the user should open the Display panel since it that controls the visual
representation of the selected module. To make a simple plot of pressure, the user should
select the following, as described in detail in Figure 2.4: in the Style panel, select Surface
from the Representation menu; in the Color panel, select Color by and Rescale to
Data Range. Now in order to view the solution at t = 0.5 s, the user can use the VCR
Controls or Current Time Controls to change the current time to 0.5. These are
located in the toolbars below the menus at the top of the ParaView window, as shown in
Figure 6.4. The pressure ﬁeld solution has, as expected, a region of low pressure at the
top left of the cavity and one of high pressure at the top right of the cavity as shown in
Figure 2.5.
With the point icon ( ) the pressure ﬁeld is interpolated across each cell to give a
continuous appearance. Instead if the user selects the cell icon, , from the Color by
menu, a single value for pressure will be attributed to each cell so that each cell will be
denoted by a single colour with no grading.
A colour bar can be included by either by clicking the Toggle Color Legend Visibility
button in the Active Variable Controls toolbar, or by selecting Show Color Legend
from the View menu. Clicking the Edit Color Map button, either in the Active Variable
Controls toolbar or in the Color panel of the Display window, the user can set a range
of attributes of the colour bar, such as text size, font selection and numbering format for
the scale. The colour bar can be located in the image window by drag and drop with the
mouse.
If the user rotates the image, they can see that they have now coloured the complete
geometry surface by the pressure. In order to produce a genuine contour plot the user
should ﬁrst create a cutting plane, or ‘slice’, through the geometry using the Slice ﬁlter
as described in section 6.1.6.1. The cutting plane should be centred at (0.05, 0.05, 0.005)
and its normal should be set to (0, 0, 1). Having generated the cutting plane, the contours
can be created using by the Contour ﬁlter described in section 6.1.6.
2.1.4.2 Vector plots
Before we start to plot the vectors of the ﬂow velocity, it may be useful to remove other
modules that have been created, e.g. using the Slice and Contour ﬁlters described above.
These can: either be deleted entirely, by highlighting the relevant module in the Pipeline
Browser and clicking Delete in their respective Properties panel; or, be disabled by toggling
the eye button for the relevant module in the Pipeline Browser.
We now wish to generate a vector glyph for velocity at the centre of each cell. We ﬁrst
need to ﬁlter the data to cell centres as described in section 6.1.7.1. With the cavity.foam
module highlighted in the Pipeline Browser, the user should select Cell Centers from the
Filter menu and then click Apply.
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-29
Open Parameters panel
Select Scale Mode off
Select Glyph Type Arrow
Specify Set Scale Factor 0.005
Figure 2.6: Properties panel for the Glyph ﬁlter.
Figure 2.7: Velocities in the cavity case.
Open∇FOAM-1.5
U-30 Tutorials
With these Centers highlighted in the Pipeline Browser, the user should then select
Glyph from the Filter menu. The Properties window panel should appear as shown in
Figure 2.6. In the resulting Properties panel, the velocity ﬁeld, U, is automatically selected
in the vectors menu, since it is the only vector ﬁeld present. By default the Scale Mode
for the glyphs will be Vector Magnitude of velocity but, since the we may wish to view
the velocities throughout the domain, the user should instead select off and Set Scale
Factor to 0.005. On clicking Apply, the glyphs appear but, probably as a single colour,
e.g. white. The user should colour the glyphs by velocity magnitude which, as usual, is
controlled by setting Color by U in the Display panel. The user should also select Show
Color Legend in Edit Color Map. The output is shown in Figure 2.7, in which uppercase
Times Roman fonts are selected for the Color Legend headings and the labels are speciﬁed
to 2 ﬁxed signiﬁcant ﬁgures by deselecting Automatic Label Format and entering %-#6.2f
in the Label Format text box. The background colour is set to white in the General panel
of View Settings as described in section 6.1.5.1.
2.1.4.3 Streamline plots
Again, before the user continues to post-process in ParaView, they should disable modules
such as those for the vector plot described above. We now wish to plot a streamlines of
velocity as described in section 6.1.8.
With the cavity.foam module highlighted in the Pipeline Browser, the user should
then select Stream Tracer from the Filter menu and then click Apply. The Properties
window panel should appear as shown in Figure 2.8. The Seed points should be speciﬁed
along a Line Source running vertically through the centre of the geometry, i.e. from
(0.05, 0, 0.005) to (0.05, 0.1, 0.005). For the image in this guide we used: a point Resolution
of 21; Max Propagation by Length 0.5; Initial Step Length by Cell Length 0.01; and,
Integration Direction BOTH. The Runge-Kutta 2 IntegratorType was used with default
parameters.
On clicking Apply the tracer is generated. The user should then select Tube from the
Filter menu to produce high quality streamline images. For the image in this report, we
used: Num. sides 6; Radius 0.0003; and, Radius factor 10. The streamtubes are coloured
by velocity magnitude. On clicking Apply the image in Figure 2.9 should be produced.
2.1.5 Increasing the mesh resolution
The mesh resolution will now be increased by a factor of two in each direction. The results
from the coarser mesh will be mapped onto the ﬁner mesh to use as initial conditions for
the problem. The solution from the ﬁner mesh will then be compared with those from
the coarser mesh.
2.1.5.1 Creating a new case using an existing case
We now wish to create a new case named cavityFine that is created from cavity. The user
should therefore clone the cavity case and edit the necessary ﬁles. First the user should
create a new case directory at the same directory level as the cavity case, e.g.
cd $FOAM RUN/tutorials/icoFoam
mkdir cavityFine
The user should then copy the base directories from the cavity case into cavityFine, and
then enter the cavityFine case.
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-31
Open Parameters panel
Set Integration Direction to BOTH
Set Max Propagation to Length 0.5
Set Initial Step Length to Cell Length 0.01
Specify Line Source and set points and resolution
Figure 2.8: Properties panel for the Stream Tracer ﬁlter.
Figure 2.9: Streamlines in the cavity case.
Open∇FOAM-1.5
U-32 Tutorials
cp -r cavity/constant cavityFine
cp -r cavity/system cavityFine
cd cavityFine
2.1.5.2 Creating the ﬁner mesh
We now wish to increase the number of cells in the mesh by using blockMesh. The user
should open the blockMeshDict ﬁle in an editor and edit the block speciﬁcation. The blocks
are speciﬁed in a list under the blocks keyword. The syntax of the block deﬁnitions is
described fully in section 5.3.1.3; at this stage it is suﬃcient to know that following hex
is ﬁrst the list of vertices in the block, then a list (or vector) of numbers of cells in each
direction. This was originally set to (20 20 1) for the cavity case. The user should now
change this to (41 41 1) and save the ﬁle. The new reﬁned mesh should then be created
by running blockMesh as before.
2.1.5.3 Mapping the coarse mesh results onto the ﬁne mesh
The mapFields utility maps one or more ﬁelds relating to a given geometry onto the cor-
responding ﬁelds for another geometry. In our example, the ﬁelds are deemed ‘consistent’
because the geometry and the boundary types, or conditions, of both source and tar-
get ﬁelds are identical. We use the -consistent command line option when executing
mapFields in this example.
The ﬁeld data that mapFields maps is read from the time directory speciﬁed by
startFrom/startTime in the controlDict of the target case, i.e. those into which the
results are being mapped. In this example, we wish to map the ﬁnal results of the coarser
mesh from case cavity onto the ﬁner mesh of case cavityFine. Therefore, since these re-
sults are stored in the 0.5 directory of cavity, the startTime should be set to 0.5 s in the
controlDict dictionary and startFrom should be set to startTime.
The case is ready to run mapFields. Typing mapFields -help quickly shows that map-
Fields requires the source case directory as an argument. We are using the -consistent
option, so the utility is executed from withing the cavityFine directory by
mapFields ../cavity -consistent
The utility should run with output to the terminal including:
Source: ".." "cavity"
Target: "." "cavityFine"
Create databases as time
Source time: 0.5
Target time: 0.5
Create meshes
Source mesh size: 400 Target mesh size: 1681
Consistently creating and mapping fields for time 0.5
interpolating p
interpolating U
End
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-33
2.1.5.4 Control adjustments
To maintain a Courant number of less that 1, as discussed in section 2.1.1.4, the time
step must now be halved since the size of all cells has halved. Therefore deltaT should
be set to to 0.0025 s in the controlDict dictionary. Field data is currently written out at
an interval of a ﬁxed number of time steps. Here we demonstrate how to specify data
output at ﬁxed intervals of time. Under the writeControl keyword in controlDict, instead
of requesting output by a ﬁxed number of time steps with the timeStep entry, a ﬁxed
amount of run time can be speciﬁed between the writing of results using the runTime
entry. In this case the user should specify output every 0.1 s and therefore should set
writeInterval to 0.1 and writeControl to runTime. Finally, since the case is starting
with a the solution obtained on the coarse mesh we only need to run it for a short period
to achieve reasonable convergence to steady-state. Therefore the endTime should be set
to 0.7 s. Make sure these settings are correct and then save the ﬁle.
2.1.5.5 Running the code as a background process
The user should experience running icoFoam as a background process, redirecting the
terminal output to a log ﬁle that can be viewed later. From the cavityFine directory, the
user should execute:
icoFoam > log &
cat log
2.1.5.6 Vector plot with the reﬁned mesh
The user can open multiple cases simultaneously in ParaView; essentially because each new
case is simply another module that appears in the Pipeline Browser. There is one minor
inconvenience when opening a new case in ParaView because there is a prerequisite that the
selected data is a ﬁle with a name that has an extension. However, in OpenFOAM, each
case is stored in a multitude of ﬁles with no extensions within a speciﬁc directory structure.
The solution, that the paraFoam script performs automatically, is to create a dummy ﬁle
with the extension .foam — hence, the cavity case module is called cavity.foam.
However, if the user wishes to open another case directly from within ParaView, they
need to create such a dummy ﬁle. For example, to load the cavityFine case the ﬁle would
be created by typing at the command prompt:
cd $FOAM RUN/tutorials/icoFoam
touch cavityFine/cavityFine.foam
Now the cavityFine case can be loaded into ParaView by selecting Open from the File
menu, and having navigated the directory tree, selecting cavityFine.foam. The user can
now make a vector plot of the results from the reﬁned mesh in ParaView. The plot can
be compared with the cavity case by enabling glyph images for both case simultaneously.
2.1.5.7 Plotting graphs
The user may wish to visualise the results by extracting some scalar measure of velocity
and plotting 2-dimensional graphs along lines through the domain. OpenFOAM is well
equipped for this kind of data manipulation. There are numerous utilities that do spe-
cialised data manipulations, and some, simpler calculations are incorporated into a single
utility foamCalc. As a utility, it is unique in that it is executed by
Open∇FOAM-1.5
U-34 Tutorials
Open Display panel
Select Scatter Plot
Select Ux from Line Series
Select arc length
Figure 2.10: Selecting ﬁelds for graph plotting.
foamCalc <calcType> <fieldName1 ... fieldNameN>
The calculator operation is speciﬁed in <calcType>; at the time of writing, the following
operations are implemented: div; components; mag; magGrad; magSqr. The user can
obtain a full list of <calcType> by deliberately calling one that does not exist, so that
foamCalc throws up an error message and lists the types available, e.g.
>> foamCalc xxxx
Selecting calcType xxxx
unknown calcType type xxxx, constructor not in hash table
Valid calcType selections are:
5
(
div
components
mag
magGrad
magSqr
)
The components and mag calcTypes provide usefu l scalar measures of velocity. When
“foamCalc components U” is run on a case, say cavity, it reads in the velocity vector ﬁeld
from each time directory and, in the corresponding time directories, writes scalar ﬁelds
Ux, Uy and Uz representing the x, y and z components of velocity. Similarly “foamCalc
mag U” writes a scalar ﬁeld magU to each time directory representing the magnitude of
velocity.
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-35
The user can run foamCalc with the components calcType on both cavity and cavityFine
cases. For example, for the cavity case the user should execute the following command:
foamCalc components U -case $FOAM RUN/tutorials1.5/icoFoam/cavity
The individual components can be plotted as a graph in ParaView. It is quick, con-
venient and has reasonably good control over labelling and formatting, so the printed
output is a fairly good standard. However, to produce graphs for publication, users may
prefer to write raw data and plot it with a dedicated graphing tool, such as gnuplot or
Grace/xmgr. To do this, we recommend using the sample utility, described in section 6.5
and section 2.2.3.
Before commencing plotting, the user needs to load the newly generated Ux, Uy and
Uz ﬁelds into ParaView. To do this, the user should check the Update GUI button at
the top of the Properties panel of the base module they are working on, e.g.cavity.foam.
Clicking Apply will then cause the new ﬁelds to be loaded into ParaView which will appear
in the Vol Field Status window. Ensure the new ﬁelds are selected and the changes
are applied, i.e. click Apply again if necessary. Also, data is interpolated incorrectly at
boundaries if the boundary regions are selected in the Region Status panel. Therefore the
user should deselect the patches in the Region Status panel, i.e.movingWall, fixedWall
and frontAndBack, and apply the changes.
Now, in order to display a graph in ParaView the user should select the module of
interest, e.g.cavity.foam and apply the Plot Over Line ﬁlter from the Filter->Data
Analysis menu. This opens up a new XY Plot window beside the existing 3D View
window. A ProbeLine module is created in which the user can specify the end points
of the line in the Properties panel. In this example, the user should position the line
vertically up the centre of the domain, i.e. from (0.05, 0, 0.005) to (0.05, 0.1, 0.005), in the
Point1 and Point2 text boxes. The Resolution can be set to 100.
On clicking Apply, a graph is generated in the XY Plot window. In the Display panel,
the user should choose Scatter Plot from the Plot Type menu, with Attribute Mode
Point Data. The Use Data Array option can be selected for the X Axis Data, taking the
arc length option so that the x-axis of the graph represents distance from the base of
the cavity.
The user can choose the ﬁelds to be displayed in the Line Series panel of the Display
window. From the list of scalar ﬁelds to be displayed, it can be seen that the magnitude
and components of vector ﬁelds are available by default, e.g. displayed as U:X, so that
it was not necessary to create Ux using foamCalc. Nevertheless, the user should deselect
all series except Ux (or U:x). A square colour box in the adjacent column to the selected
series indicates the line colour. The user can edit this most easily by a double click of the
mouse over that selection.
In order to format the graph, the user should move over to the XY Plot itself. Now,
with the cursor over the graph, the user can click the right mouse-button and select
Properties from the small ﬂoating menu produced. A Chart Options window appears
with General settings for title and legend and menus for each axis. The menu for each
axis can be expanded by a double click to reveal individual menus for Layout and Title,
one for each axis. The user can set font, colour and alignment of the axes titles, and has
several options for axis range and labels in linear or logarithmic scales.
Figure 2.11 is a graph produced using ParaView. The user can produce a graph how-
ever he/she wishes. For information, the graph in Figure 2.11 was produced with the
options for axes of: Standard type of Notation; Specify Axis Range selected; titles in
Sans Serif 12 font.
Open∇FOAM-1.5
U-36 Tutorials
Figure 2.11: Plotting graphs in paraFoam.
2.1.6 Introducing mesh grading
The error in any solution will be more pronounced in regions where the form of the
true solution diﬀer widely from the form assumed in the chosen numerical schemes. For
example a numerical scheme based on linear variations of variables over cells can only
generate an exact solution if the true solution is itself linear in form. The error is largest
in regions where the true solution deviates greatest from linear form, i.e. where the change
in gradient is largest. Error decreases with cell size.
It is useful to have an intuitive appreciation of the form of the solution before setting
up any problem. It is then possible to anticipate where the errors will be largest and
to grade the mesh so that the smallest cells are in these regions. In the cavity case the
large variations in velocity can be expected near a wall and so in this part of the tutorial
the mesh will be graded to be smaller in this region. By using the same number of cells,
greater accuracy can be achieved without a signiﬁcant increase in computational cost.
A mesh of 20 × 20 cells with grading towards the walls will be created for the lid-
driven cavity problem and the results from the ﬁner mesh of section 2.1.5.2 will then be
mapped onto the graded mesh to use as an initial condition. The results from the graded
mesh will be compared with those from the previous meshes. Since the changes to the
blockMeshDict dictionary are fairly substantial, the case used for this part of the tutorial,
cavityGrade, is supplied in the $FOAM RUN/tutorials/icoFoam directory.
2.1.6.1 Creating the graded mesh
The mesh now needs 4 blocks as diﬀerent mesh grading is needed on the left and right and
top and bottom of the domain. The block structure for this mesh is shown in Figure 2.12.
The user can view the blockMeshDict ﬁle in the constant/polyMesh subdirectory of cavi-
tyGrade; for completeness the key elements of the blockMeshDict ﬁle are also reproduced
below. Each block now has 10 cells in the x and y directions and the ratio between largest
and smallest cells is 2.
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (0.5 0 0)
23 (1 0 0)
24 (0 0.5 0)
25 (0.5 0.5 0)
26 (1 0.5 0)
27 (0 1 0)
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-37
0
z
x
y
3 4 5
6 87
1 2
1715
9 1110
16
12 13 14
0 1
2 3
Figure 2.12: Block structure of the graded mesh for the cavity (block numbers encircled).
28 (0.5 1 0)
29 (1 1 0)
30 (0 0 0.1)
31 (0.5 0 0.1)
32 (1 0 0.1)
33 (0 0.5 0.1)
34 (0.5 0.5 0.1)
35 (1 0.5 0.1)
36 (0 1 0.1)
37 (0.5 1 0.1)
38 (1 1 0.1)
39 );
40
41 blocks
42 (
43 hex (0 1 4 3 9 10 13 12) (10 10 1) simpleGrading (2 2 1)
44 hex (1 2 5 4 10 11 14 13) (10 10 1) simpleGrading (0.5 2 1)
45 hex (3 4 7 6 12 13 16 15) (10 10 1) simpleGrading (2 0.5 1)
46 hex (4 5 8 7 13 14 17 16) (10 10 1) simpleGrading (0.5 0.5 1)
47 );
48
49 edges
50 (
51 );
52
53 patches
54 (
55 wall movingWall
56 (
57 (6 15 16 7)
58 (7 16 17 8)
59 )
60 wall fixedWalls
61 (
62 (3 12 15 6)
63 (0 9 12 3)
64 (0 1 10 9)
65 (1 2 11 10)
66 (2 5 14 11)
67 (5 8 17 14)
68 )
69 empty frontAndBack
70 (
71 (0 3 4 1)
72 (1 4 5 2)
73 (3 6 7 4)
74 (4 7 8 5)
75 (9 10 13 12)
76 (10 11 14 13)
77 (12 13 16 15)
78 (13 14 17 16)
79 )
80 );
81
82 mergePatchPairs
83 (
84 );
Open∇FOAM-1.5
U-38 Tutorials
85
86 // ************************************************************************* //
Once familiar with the blockMeshDict ﬁle for this case, the user can execute blockMesh
from the command line. The graded mesh can be viewed as before using paraFoam as
described in section 2.1.2.
2.1.6.2 Changing time and time step
The highest velocities and smallest cells are next to the lid, therefore the highest Courant
number will be generated next to the lid, for reasons given in section 2.1.1.4. It is therefore
useful to estimate the size of the cells next to the lid to calculate an appropriate time
step for this case.
When a nonuniform mesh grading is used, blockMesh calculates the cell sizes using a
geometric progression. Along a length l, if n cells are requested with a ratio of R between
the last and ﬁrst cells, the size of the smallest cell, δxs, is given by:
δxs = l
r − 1
αr − 1
(2.5)
where r is the ratio between one cell size and the next which is given by:
r = R
1
n−1 (2.6)
and
α =
Rn
for R > 1,
1 − r−n
+ r−1
for R < 1.
(2.7)
For the cavityGrade case the number of cells in each direction in a block is 10, the ratio
between largest and smallest cells is 2 and the block height and width is 0.05 m. Therefore
the smallest cell length is 3.45 mm. From Equation 2.2, the time step should be less than
3.45 ms to maintain a Courant of less than 1. To ensure that results are written out
at convenient time intervals, the time step deltaT should be reduced to 2.5 ms and the
writeInterval set to 40 so that results are written out every 0.1 s. These settings can
be viewed in the cavityGrade/system/controlDict ﬁle.
The startTime needs to be set to that of the ﬁnal conditions of the case cavityFine,
i.e.0.7. Since cavity and cavityFine converged well within the prescribed run time, we can
set the run time for case cavityGrade to 0.1 s, i.e. the endTime should be 0.8.
2.1.6.3 Mapping ﬁelds
As in section 2.1.5.3, use mapFields to map the ﬁnal results from case cavityFine onto the
mesh for case cavityGrade. Enter the cavityGrade directory and execute mapFields by:
cd $FOAM RUN/tutorials/icoFoam/cavityGrade
mapFields ../cavityFine -consistent
Now run icoFoam from the case directory and monitor the run time information. View
the converged results for this case and compare with other results using post-processing
tools described previously in section 2.1.5.6 and section 2.1.5.7.
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-39
2.1.7 Increasing the Reynolds number
The cases solved so far have had a Reynolds number of 10. This is very low and leads
to a stable solution quickly with only small secondary vortices at the bottom corners of
the cavity. We will now increase the Reynolds number to 50, at which point the solution
takes a noticeably longer time to converge. The coarsest mesh in case cavity will be used
initially. The user should make a copy of the cavity case and name it cavityHighRe by
typing:
cd $FOAM_RUN/tutorials/icoFoam
cp -r cavity cavityHighRe
2.1.7.1 Pre-processing
Enter the the cavityHighRe case and edit the transportProperties dictionary. Since the
Reynolds number is required to be increased by a factor of 10, decrease the kinematic
viscosity by a factor of 10, i.e. to 1×10−3
m2
s−1
. We can now run this case by restarting
from the solution at the end of the cavity case run. To do this we can use the option of
setting the startFrom keyword to latestTime so that icoFoam takes as its initial data
the values stored in the directory corresponding to the most recent time, i.e.0.5. The
endTime should be set to 2 s.
2.1.7.2 Running the code
Run icoFoam for this case from the case directory and view the run time information.
When running a job in the background, the following UNIX commands can be useful:
nohup enables a command to keep running after the user who issues the command has
logged out;
nice changes the priority of the job in the kernel’s scheduler; a niceness of -20 is the
highest priority and 19 is the lowest priority.
This is useful, for example, if a user wishes to set a case running on a remote machine
and does not wish to monitor it heavily, in which case they may wish to give it low
priority on the machine. In that case the nohup command allows the user to log out of a
remote machine he/she is running on and the job continues running, while nice can set
the priority to 19. For our case of interest, we can execute the command in this manner
as follows:
cd $FOAM RUN/tutorials/icoFoam
nohup nice -n 19 icoFoam > log &
cat log
In previous runs you may have noticed that icoFoam stops solving for velocity U quite
quickly but continues solving for pressure p for a lot longer or until the end of the run.
In practice, once icoFoam stops solving for U and the initial residual of p is less than
the tolerance set in the fvSolution dictionary (typically 10−6
), the run has eﬀectively
converged and can be stopped once the ﬁeld data has been written out to a time directory.
For example, at convergence a sample of the log ﬁle from the run on the cavityHighRe
case appears as follows in which the velocity has already converged after 1.62 s and
initial pressure residuals are small; No Iterations 0 indicates that the solution of U has
stopped:
Open∇FOAM-1.5
U-40 Tutorials
1
2 Time = 1.63
3
4 Courant Number mean: 0.108642 max: 0.818175
5 DILUPBiCG: Solving for Ux, Initial residual = 7.86044e-06, Final residual = 7.86044e-06,
6 No Iterations 0
7 DILUPBiCG: Solving for Uy, Initial residual = 9.4171e-06, Final residual = 9.4171e-06,
8 No Iterations 0
9 DICPCG: Solving for p, Initial residual = 3.54721e-06, Final residual = 7.13506e-07,
10 No Iterations 4
11 time step continuity errors : sum local = 6.46788e-09, global = -9.44516e-19,
12 cumulative = 1.04595e-17
13 DICPCG: Solving for p, Initial residual = 2.15824e-06, Final residual = 9.95068e-07,
14 No Iterations 3
15 time step continuity errors : sum local = 8.67501e-09, global = 7.54182e-19,
16 cumulative = 1.12136e-17
17 ExecutionTime = 1.02 s ClockTime = 1 s
18
19 Time = 1.635
20
21 Courant Number mean: 0.108643 max: 0.818176
22 DILUPBiCG: Solving for Ux, Initial residual = 7.6728e-06, Final residual = 7.6728e-06,
23 No Iterations 0
24 DILUPBiCG: Solving for Uy, Initial residual = 9.19442e-06, Final residual = 9.19442e-06,
25 No Iterations 0
26 DICPCG: Solving for p, Initial residual = 3.13107e-06, Final residual = 8.60504e-07,
27 No Iterations 4
28 time step continuity errors : sum local = 8.15435e-09, global = -5.84817e-20,
29 cumulative = 1.11552e-17
30 DICPCG: Solving for p, Initial residual = 2.16689e-06, Final residual = 5.27197e-07,
31 No Iterations 14
32 time step continuity errors : sum local = 3.45666e-09, global = -5.62297e-19,
33 cumulative = 1.05929e-17
34 ExecutionTime = 1.02 s ClockTime = 1 s
2.1.8 High Reynolds number ﬂow
View the results in paraFoam and display the velocity vectors. The secondary vortices in
the corners have increased in size somewhat. The user can then increase the Reynolds
number further by decreasing the viscosity and then rerun the case. The number of
vortices increases so the mesh resolution around them will need to increase in order to
resolve the more complicated ﬂow patterns. In addition, as the Reynolds number increases
the time to convergence increases. The user should monitor residuals and extend the
endTime accordingly to ensure convergence.
The need to increase spatial and temporal resolution then becomes impractical as
the ﬂow moves into the turbulent regime, where problems of solution stability may also
occur. Of course, many engineering problems have very high Reynolds numbers and it
is infeasible to bear the huge cost of solving the turbulent behaviour directly. Instead
Reynolds-averaged stress (RAS) turbulence models are used to solve for the mean ﬂow
behaviour and calculate the statistics of the ﬂuctuations. The standard k − ε model
with wall functions will be used in this tutorial to solve the lid-driven cavity case with
a Reynolds number of 104
. Two extra variables are solved for: k, the turbulent kinetic
energy; and, ε, the turbulent dissipation rate. The additional equations and models for
turbulent ﬂow are implemented into a OpenFOAM solver called turbFoam.
2.1.8.1 Pre-processing
Change directory to the cavity case in the $FOAM RUN/tutorials/turbFoam directory (N.B:
the turbFoam directory). Generate the mesh by running blockMesh as before. Mesh
grading towards the wall is not necessary when using the standard k − ε model with
wall functions since the ﬂow in the near wall cell is modelled, rather than having to be
resolved.
Open the ﬁeld ﬁles for k and ε (0/k and 0/epsilon) and examine the boundary con-
ditions. For a wall boundary condition, ε is assigned a zeroGradient boundary condition
and a ﬁxedValue 0 boundary condition is assigned to k. How are the initial values of k
and ǫ arrived at? Positive, non-zero initial values for k and ε must be given to avoid
division by 0 in the solution algorithm. We can specify reasonable initial conditions for
k and ε in terms of an estimated ﬂuctuating component of velocity U′
and a turbulent
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-41
length scale, l. k and ε are deﬁned in terms of these parameters as follows:
k =
1
2
U′ • U′ (2.8)
ε =
C0.75
µ k1.5
l
(2.9)
where Cµ is a constant of the k − ε model equal to 0.09. For a Cartesian coordinate
system, k is given by:
k =
1
2
(U′ 2
x + U′ 2
y + U′ 2
z ) (2.10)
where U′ 2
x , U′ 2
y and U′ 2
z are the ﬂuctuating components of velocity in the x, y and z
directions respectively. Let us assume the initial turbulence is isotropic, i.e. U′ 2
x = U′ 2
y =
U′ 2
z , and equal to 5% of the lid velocity and that l, is equal to 20% of the box width, 0.1
m, then k and ε are given by:
U′
x = U′
y = U′
z =
5
100
1 m s−1
(2.11)
⇒ k =
3
2
5
100
2
m2
s−2
= 3.75 × 10−3
m2
s−2
(2.12)
ε =
C0.75
µ k1.5
l
≈ 7.65 × 10−4
m2
s−3
(2.13)
These form the initial conditions for k and ε. The initial conditions for U and p are
(0, 0, 0) and 0 respectively as before.
Next set the laminar kinematic viscosity in the transportProperties dictionary. To
achieve a Reynolds number of 104
, a kinematic viscosity of 10−5
m is required based on
the Reynolds number deﬁnition given in Equation 2.1.
To select the RAS turbulence model open the RASProperties dictionary. The turbu-
lence model is selected by the RASModel entry. There is a long list of available models
that are listed in Table 3.9. The kEpsilon model should be selected which is is the stan-
dard k − ε model; the user should also ensure that turbulence calculation is switched
on. The coeﬃcients relating to the model are stored in a standard dictionary under
kEpsilonCoeffs; the model also uses the wallFunctionCoeffs.
Next set the startTime, stopTime, deltaT and the writeInterval in the controlDict.
Set deltaT to 0.005 s to satisfy the Courant number restriction and the endTime to 10 s.
2.1.8.2 Running the code
Execute turbFoam by entering the case directory and typing “turbFoam”. In this case,
where the viscosity is low, the boundary layer next to the moving lid is very thin and
the cells next to the lid are comparatively large so the velocity at their centres are much
less than the lid velocity. In fact, after ≈ 100 time steps it becomes apparent that the
velocity in the cells adjacent to the lid reaches an upper limit of around 0.2 m s−1
hence
the maximum Courant number does not rise much above 0.2. It is sensible to increase
the solution time by increasing the time step to a level where the Courant number is
much closer to 1. Therefore reset deltaT to 0.02 s and, on this occasion, set startFrom
to latestTime. This instructs turbFoam to read the start data from the latest time
directory, i.e.10.0. The endTime should be set to 20 s since the run converges a lot slower
than the laminar case. Restart the run as before and monitor the convergence of the
solution. View the results at consecutive time steps as the solution progresses to see if
Open∇FOAM-1.5
U-42 Tutorials
the solution converges to a steady-state or perhaps reaches some periodically oscillating
state. In the latter case, convergence may never occur but this does not mean the results
are inaccurate.
2.1.9 Changing the case geometry
A user may wish to make changes to the geometry of a case and perform a new simulation.
It may be useful to retain some or all of the original solution as the starting conditions
for the new simulation. This is a little complex because the ﬁelds of the original solution
are not consistent with the ﬁelds of the new case. However the mapFields utility can map
ﬁelds that are inconsistent, either in terms of geometry or boundary types or both.
As an example, let us go to the cavityClipped case in the icoFoam directory which
consists of the standard cavity geometry but with a square of length 0.04 m removed from
the bottom right of the cavity, according to the blockMeshDict below:
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (0.6 0 0)
23 (0 0.4 0)
24 (0.6 0.4 0)
25 (1 0.4 0)
26 (0 1 0)
27 (0.6 1 0)
28 (1 1 0)
29
30 (0 0 0.1)
31 (0.6 0 0.1)
32 (0 0.4 0.1)
33 (0.6 0.4 0.1)
34 (1 0.4 0.1)
35 (0 1 0.1)
36 (0.6 1 0.1)
37 (1 1 0.1)
38
39 );
40
41 blocks
42 (
43 hex (0 1 3 2 8 9 11 10) (12 8 1) simpleGrading (1 1 1)
44 hex (2 3 6 5 10 11 14 13) (12 12 1) simpleGrading (1 1 1)
45 hex (3 4 7 6 11 12 15 14) (8 12 1) simpleGrading (1 1 1)
46 );
47
48 edges
49 (
50 );
51
52 patches
53 (
54 wall lid
55 (
56 (5 13 14 6)
57 (6 14 15 7)
58 )
59 wall fixedWalls
60 (
61 (0 8 10 2)
62 (2 10 13 5)
63 (7 15 12 4)
64 (4 12 11 3)
65 (3 11 9 1)
66 (1 9 8 0)
67 )
68 empty frontAndBack
69 (
70 (0 2 3 1)
71 (2 5 6 3)
72 (3 6 7 4)
73 (8 9 11 10)
74 (10 11 14 13)
75 (11 12 15 14)
76 )
77 );
Open∇FOAM-1.5
2.1 Lid-driven cavity ﬂow U-43
78
79 mergePatchPairs
80 (
81 );
82
83 // ************************************************************************* //
Generate the mesh with blockMesh. The patches are set accordingly as in previous cavity
cases. For the sake of clarity in describing the ﬁeld mapping process, the upper wall patch
is renamed lid, previously the movingWall patch of the original cavity.
In an inconsistent mapping, there is no guarantee that all the ﬁeld data can be mapped
from the source case. The remaining data must come from ﬁeld ﬁles in the target case
itself. Therefore ﬁeld data must exist in the time directory of the target case before
mapping takes place. In the cavityClipped case the mapping is set to occur at time 0.5 s,
since the startTime is set to 0.5 sin the controlDict. Therefore the user needs to copy
initial ﬁeld data to that directory, e.g. from time 0:
cd $FOAM RUN/tutorials/icoFoam/cavityClipped
cp -r 0 0.5
Before mapping the data, the user should view the geometry and ﬁelds at 0.5 s.
Now we wish to map the velocity and pressure ﬁelds from cavity onto the new ﬁelds
of cavityClipped. Since the mapping is inconsistent, we need to edit the mapFieldsDict
dictionary, located in the system directory. The dictionary contains 2 keyword entries:
patchMap and cuttingPatches. The patchMap list contains a mapping of patches from
the source ﬁelds to the target ﬁelds. It is used if the user wishes a patch in the target
ﬁeld to inherit values from a corresponding patch in the source ﬁeld. In cavityClipped, we
wish to inherit the boundary values on the lid patch from movingWall in cavity so we
must set the patchMap as:
patchMap
(
lid movingWall
);
The cuttingPatches list contains names of target patches whose values are to be
mapped from the source internal ﬁeld through which the target patch cuts. In this case
we will include the fixedWalls to demonstrate the interpolation process.
cuttingPatches
(
fixedWalls
);
Now the user should run mapFields, from within the cavityClipped directory:
mapFields ../cavity
The user can view the mapped ﬁeld as shown in Figure 2.13. The boundary patches
have inherited values from the source case as we expected. Having demonstrated this,
however, we actually wish to reset the velocity on the fixedWalls patch to (0, 0, 0). Edit
the U ﬁeld, go to the fixedWalls patch and change the ﬁeld from nonuniform to uniform
(0, 0, 0). The nonuniform ﬁeld is a list of values that requires deleting in its entirety. Now
run the case with icoFoam.
Open∇FOAM-1.5
U-44 Tutorials
Figure 2.13: cavity solution velocity ﬁeld mapped onto cavityClipped.
Figure 2.14: cavityClipped solution for velocity ﬁeld.
Open∇FOAM-1.5
2.2 Stress analysis of a plate with a hole U-45
2.1.10 Post-processing the modiﬁed geometry
Velocity glyphs can be generated for the case as normal, ﬁrst at time 0.5 s and later at
time 0.6 s, to compare the initial and ﬁnal solutions. In addition, we provide an outline of
the geometry which requires some care to generate for a 2D case. The user should select
Extract Block from the Filter menu and, in the Parameter panel, highlight the patches
of interest, namely the lid and ﬁxedWalls. On clicking Apply, these items of geometry can
be displayed by selecting Wireframe in the Display panel. Figure 2.14 displays the patches
in black and shows vortices forming in the bottom corners of the modiﬁed geometry.
2.2 Stress analysis of a plate with a hole
This tutorial describes how to pre-process, run and post-process a case involving linear-
elastic, steady-state stress analysis on a square plate with a circular hole at its centre.
The plate dimensions are: side length 4 m and radius R = 0.5 m. It is loaded with a
uniform traction of σ = 10 kPa over its left and right faces as shown in Figure 2.15. Two
symmetry planes can be identiﬁed for this geometry and therefore the solution domain
need only cover a quarter of the geometry, shown by the shaded area in Figure 2.15.
xsymmetry plane
4.0 m
y
σ = 10 kPaσ = 10 kPa
R = 0.5 m
symmetryplane
Figure 2.15: Geometry of the plate with a hole.
The problem can be approximated as 2-dimensional since the load is applied in the
plane of the plate. In a Cartesian coordinate system there are two possible assumptions
to take in regard to the behaviour of the structure in the third dimension: (1) the plane
stress condition, in which the stress components acting out of the 2D plane are assumed
to be negligible; (2) the plane strain condition, in which the strain components out of
the 2D plane are assumed negligible. The plane stress condition is appropriate for solids
whose third dimension is thin as in this case; the plane strain condition is applicable for
solids where the third dimension is thick.
An analytical solution exists for loading of an inﬁnitely large, thin plate with a circular
Open∇FOAM-1.5
U-46 Tutorials
hole. The solution for the stress normal to the vertical plane of symmetry is
(σxx)x=0 =



σ 1 +
R2
2y2
+
3R4
2y4
for |y| ≥ R
0 for |y| < R
(2.14)
Results from the simulation will be compared with this solution. At the end of the
tutorial, the user can: investigate the sensitivity of the solution to mesh resolution and
mesh grading; and, increase the size of the plate in comparison to the hole to try to
estimate the error in comparing the analytical solution for an inﬁnite plate to the solution
of this problem of a ﬁnite plate.
2.2.1 Mesh generation
The domain consists of four blocks, some of which have arc-shaped edges. The block
structure for the part of the mesh in the x − y plane is shown in Figure 2.16. As already
mentioned in section 2.1.1.1, all geometries are generated in 3 dimensions in OpenFOAM
even if the case is to be as a 2 dimensional problem. Therefore a dimension of the block
in the z direction has to be chosen; here, 0.5 m is selected. It does not aﬀect the solution
since the traction boundary condition is speciﬁed as a stress rather than a force, thereby
making the solution independent of the cross-sectional area.
x
y x2
x1 x1
x2
x2
x1
x1
x2
x2
x1
left
left
up 7 up
right
3
down
hole
0
down
right
6
9
8
4
10
10 2
5
2
1
4 3
Figure 2.16: Block structure of the mesh for the plate with a hole.
The user should change into the plateHole case in the $FOAM RUN/tutorials/solid-
DisplacementFoam directory and open the constant/polyMesh/blockMeshDict ﬁle in an
editor, as listed below
Open∇FOAM-1.5
2.2 Stress analysis of a plate with a hole U-47
17 convertToMeters 1;
18
19 vertices
20 (
21 (0.5 0 0)
22 (1 0 0)
23 (2 0 0)
24 (2 0.707107 0)
25 (0.707107 0.707107 0)
26 (0.353553 0.353553 0)
27 (2 2 0)
28 (0.707107 2 0)
29 (0 2 0)
30 (0 1 0)
31 (0 0.5 0)
32 (0.5 0 0.5)
33 (1 0 0.5)
34 (2 0 0.5)
35 (2 0.707107 0.5)
36 (0.707107 0.707107 0.5)
37 (0.353553 0.353553 0.5)
38 (2 2 0.5)
39 (0.707107 2 0.5)
40 (0 2 0.5)
41 (0 1 0.5)
42 (0 0.5 0.5)
43 );
44
45 blocks
46 (
47 hex (5 4 9 10 16 15 20 21) (10 10 1) simpleGrading (1 1 1)
48 hex (0 1 4 5 11 12 15 16) (10 10 1) simpleGrading (1 1 1)
49 hex (1 2 3 4 12 13 14 15) (20 10 1) simpleGrading (1 1 1)
50 hex (4 3 6 7 15 14 17 18) (20 20 1) simpleGrading (1 1 1)
51 hex (9 4 7 8 20 15 18 19) (10 20 1) simpleGrading (1 1 1)
52 );
53
54 edges
55 (
56 arc 0 5 (0.469846 0.17101 0)
57 arc 5 10 (0.17101 0.469846 0)
58 arc 1 4 (0.939693 0.34202 0)
59 arc 4 9 (0.34202 0.939693 0)
60 arc 11 16 (0.469846 0.17101 0.5)
61 arc 16 21 (0.17101 0.469846 0.5)
62 arc 12 15 (0.939693 0.34202 0.5)
63 arc 15 20 (0.34202 0.939693 0.5)
64 );
65
66 patches
67 (
68 symmetryPlane left
69 (
70 (8 9 20 19)
71 (9 10 21 20)
72 )
73 patch right
74 (
75 (2 3 14 13)
76 (3 6 17 14)
77 )
78 symmetryPlane down
79 (
80 (0 1 12 11)
81 (1 2 13 12)
82 )
83 patch up
84 (
85 (7 8 19 18)
86 (6 7 18 17)
87 )
88 patch hole
89 (
90 (10 5 16 21)
91 (5 0 11 16)
92 )
93 empty frontAndBack
94 (
95 (10 9 4 5)
96 (5 4 1 0)
97 (1 4 3 2)
98 (4 7 6 3)
99 (4 9 8 7)
100 (21 16 15 20)
Open∇FOAM-1.5
U-48 Tutorials
101 (16 11 12 15)
102 (12 13 14 15)
103 (15 14 17 18)
104 (15 18 19 20)
105 )
106 );
107
108 mergePatchPairs
109 (
110 );
111
112 // ************************************************************************* //
Until now, we have only speciﬁed straight edges in the geometries of previous tutorials but
here we need to specify curved edges. These are speciﬁed under the edges keyword entry
which is a list of non-straight edges. The syntax of each list entry begins with the type
of curve, including arc, simpleSpline, polyLine etc., described further in section 5.3.1.
In this example, all the edges are circular and so can be speciﬁed by the arc keyword
entry. The following entries are the labels of the start and end vertices of the arc and a
point vector through which the circular arc passes.
The blocks in this blockMeshDict do not all have the same orientation. As can be seen
in Figure 2.16 the x2 direction of block 0 is equivalent to the −x1 direction for block 4.
This means care must be taken when deﬁning the number and distribution of cells in each
block so that the cells match up at the block faces.
6 patches are deﬁned: one for each side of the plate, one for the hole and one for the
front and back planes. The left and down patches are both a symmetry plane. Since this
is a geometric constraint, it is included in the deﬁnition of the mesh, rather than being
purely a speciﬁcation on the boundary condition of the ﬁelds. Therefore they are deﬁned
as such using a special symmetryPlane type as shown in the blockMeshDict.
The frontAndBack patch represents the plane which is ignored in a 2D case. Again
this is a geometric constraint so is deﬁned within the mesh, using the empty type as shown
in the blockMeshDict. For further details of boundary types and geometric constraints,
the user should refer to section 5.2.1.
The remaining patches are of the regular patch type. The mesh should be generated
using blockMesh and can be viewed in paraFoam as described in section 2.1.2. It should
appear as in Figure 2.17.
Figure 2.17: Mesh of the hole in a plate problem.
Open∇FOAM-1.5
2.2 Stress analysis of a plate with a hole U-49
2.2.1.1 Boundary and initial conditions
Once the mesh generation is complete, the initial ﬁeld with boundary conditions must be
set. For a stress analysis case without thermal stresses, only displacement D needs to be
set. The 0/D is as follows:
17 dimensions [0 1 0 0 0 0 0];
18
19 internalField uniform (0 0 0);
20
21 boundaryField
22 {
23 left
24 {
25 type symmetryPlane;
26 }
27 right
28 {
29 type tractionDisplacement;
30 traction uniform ( 10000 0 0 );
31 pressure uniform 0;
32 value uniform (0 0 0);
33 }
34 down
35 {
36 type symmetryPlane;
37 }
38 up
39 {
40 type tractionDisplacement;
41 traction uniform ( 0 0 0 );
42 pressure uniform 0;
43 value uniform (0 0 0);
44 }
45 hole
46 {
47 type tractionDisplacement;
48 traction uniform ( 0 0 0 );
49 pressure uniform 0;
50 value uniform (0 0 0);
51 }
52 frontAndBack
53 {
54 type empty;
55 }
56 }
57
58 // ************************************************************************* //
Firstly, it can be seen that the displacement initial conditions are set to (0, 0, 0) m. The
left and down patches must be both of symmetryPlane type since they are speciﬁed
as such in the mesh description in the constant/polyMesh/boundary ﬁle. Similarly the
frontAndBack patch is declared empty.
The other patches are traction boundary conditions, set by a specialist traction bound-
ary type. The traction boundary conditions are speciﬁed by a linear combination of: (1)
a boundary traction vector under keyword traction; (2) a pressure that produces a trac-
tion normal to the boundary surface that is deﬁned as negative when pointing out of
the surface, under keyword pressure. The up and hole patches are zero traction so the
boundary traction and pressure are set to zero. For the right patch the traction should
be (1e4, 0, 0) Pa and the pressure should be 0 Pa.
2.2.1.2 Mechanical properties
The physical properties for the case are set in the mechanicalProperties dictionary in the
constant directory. For this problem, we need to specify the mechanical properties of
steel given in Table 2.1. In the mechanical properties dictionary, the user must also set
planeStress to yes.
Open∇FOAM-1.5
U-50 Tutorials
Property Units Keyword Value
Density kg m−3
rho 7854
Young’s modulus Pa E 2 × 1011
Poisson’s ratio — nu 0.3
Table 2.1: Mechanical properties for steel
2.2.1.3 Thermal properties
The temperature ﬁeld variable T is present in the solidDisplacementFoam solver since the
user may opt to solve a thermal equation that is coupled with the momentum equation
through the thermal stresses that are generated. The user speciﬁes at run time whether
OpenFOAM should solve the thermal equation by the thermalStress switch in the ther-
malProperties dictionary. This dictionary also sets the thermal properties for the case,
e.g. for steel as listed in Table 2.2.
Property Units Keyword Value
Speciﬁc heat capacity Jkg−1
K−1
C 434
Thermal conductivity Wm−1
K−1
k 60.5
Thermal expansion coeﬀ. K−1
alpha 1.1 × 10−5
Table 2.2: Thermal properties for steel
In this case we do not want to solve for the thermal equation. Therefore we must set
the thermalStress keyword entry to no in the thermalProperties dictionary.
2.2.1.4 Control
As before, the information relating to the control of the solution procedure are read in
from the controlDict dictionary. For this case, the startTime is 0 s. The time step is
not important since this is a steady state case; in this situation it is best to set the time
step deltaT to 1 so it simply acts as an iteration counter for the steady-state case. The
endTime, set to 100, then acts as a limit on the number of iterations. The writeInterval
can be set to 20.
The controlDict entries are as follows:
17 application solidDisplacementFoam;
18
19 startFrom startTime;
20
21 startTime 0;
22
23 stopAt endTime;
24
25 endTime 100;
26
27 deltaT 1;
28
29 writeControl timeStep;
30
31 writeInterval 20;
32
33 purgeWrite 0;
34
35 writeFormat ascii;
36
37 writePrecision 6;
38
39 writeCompression uncompressed;
40
41 timeFormat general;
42
Open∇FOAM-1.5
2.2 Stress analysis of a plate with a hole U-51
43 timePrecision 6;
44
45 graphFormat raw;
46
47 runTimeModifiable yes;
48
49 // ************************************************************************* //
2.2.1.5 Discretisation schemes and linear-solver control
Let us turn our attention to the fvSchemes dictionary. Firstly, the problem we are
analysing is steady-state so the user should select SteadyState for the time derivatives
in timeScheme. This essentially switches oﬀ the time derivative terms. Not all solvers,
especially in ﬂuid dynamics, work for both steady-state and transient problems but solid-
DisplacementFoam does work, since the base algorithm is the same for both types of
simulation.
The momentum equation in linear-elastic stress analysis includes several explicit terms
containing the gradient of displacement. The calculations beneﬁt from accurate and
smooth evaluation of the gradient. Normally, in the ﬁnite volume method the discreti-
sation is based on Gauss’s theorem The Gauss method is suﬃciently accurate for most
purposes but, in this case, the least squares method will be used. The user should there-
fore open the fvSchemes dictionary in the system directory and ensure the leastSquares
method is selected for the grad(U) gradient discretisation scheme in the gradSchemes
sub-dictionary:
17 d2dt2Schemes
18 {
19 default steadyState;
20 }
21
22 gradSchemes
23 {
24 default leastSquares;
25 grad(D) leastSquares;
26 grad(T) leastSquares;
27 }
28
29 divSchemes
30 {
31 default none;
32 div(sigmaD) Gauss linear;
33 }
34
35 laplacianSchemes
36 {
37 default none;
38 laplacian(DD,D) Gauss linear corrected;
39 laplacian(DT,T) Gauss linear corrected;
40 }
41
42 interpolationSchemes
43 {
44 default linear;
45 }
46
47 snGradSchemes
48 {
49 default none;
50 }
51
52 fluxRequired
53 {
54 default no;
55 D yes;
56 T no;
57 }
58
59 // ************************************************************************* //
The fvSolution dictionary in the system directory controls the linear equation solvers and
algorithms used in the solution. The user should ﬁrst look at the solvers sub-dictionary
Open∇FOAM-1.5
U-52 Tutorials
and notice that the GAMG solver is included with entries listed below. The solver tolerance
should be set to 10−6
for this problem. The solver relative tolerance, denoted by relTol,
sets the required reduction in the residuals within each iteration. It is uneconomical to
set a tight (low) relative tolerance within each iteration since a lot of terms are explicit
and are updated as part of the segregated iterative procedure. Therefore a reasonable
value for the relative tolerance is 0.01, or possibly even higher, say 0.1, or in some case
even 0.9.
17 solvers
18 {
19 D GAMG
20 {
21 tolerance 1e-06;
22 relTol 0.9;
23
24 smoother GaussSeidel;
25
26 cacheAgglomeration true;
27
28 nCellsInCoarsestLevel 20;
29
30 agglomerator faceAreaPair;
31 mergeLevels 1;
32 };
33
34 T GAMG
35 {
36 tolerance 1e-06;
37 relTol 0.9;
38
39 smoother GaussSeidel;
40
41 cacheAgglomeration true;
42
43 nCellsInCoarsestLevel 20;
44
45 agglomerator faceAreaPair;
46 mergeLevels 1;
47 };
48 }
49
50 stressAnalysis
51 {
52 compactNormalStress yes;
53 nCorrectors 1;
54 D 1e-06;
55 }
56
57 // ************************************************************************* //
The fvSolution dictionary contains a sub-dictionary, stressAnalysis that contains some con-
trol parameters speciﬁc to the application solver. Firstly there is nCorrectors which
speciﬁes the number of outer loops around the complete system of equations, including
traction boundary conditions within each time step. Since this problem is steady-state,
we are performing a set of iterations towards a converged solution with the ’time step’
acting as an iteration counter. We can therefore set nCorrectors to 1.
The D keyword speciﬁes a convergence tolerance for the outer iteration loop, i.e. sets
a level of initial residual below which solving will cease. It should be set to the desired
solver tolerance speciﬁed earlier, 10−6
for this problem.
2.2.2 Running the code
The user should run the code here in the background from the command line as speciﬁed
below, so he/she can look at convergence information in the log ﬁle afterwards.
cd $FOAM RUN/tutorials/solidDisplacementFoam/plateHole
solidDisplacementFoam > log &
Open∇FOAM-1.5
2.2 Stress analysis of a plate with a hole U-53
The user should check the convergence information by viewing the generated log ﬁle which
shows the number of iterations and the initial and ﬁnal residuals of the displacement in
each direction being solved. The ﬁnal residual should always be less than 0.9 times the
initial residual as this iteration tolerance set. Once both initial residuals have dropped
below the convergence tolerance of 10−6
the run has converged and can be stopped by
killing the batch job.
2.2.3 Post-processing
Post processing can be performed as in section 2.1.4. The solidDisplacementFoam solver
outputs the stress ﬁeld σ as a symmetric tensor ﬁeld sigma. This is consistent with the
way variables are usually represented in OpenFOAM solvers by the mathematical symbol
by which they are represented; in the case of Greek symbols, the variable is named
phonetically.
For post-processing individual scalar ﬁeld components, σxx, σxy etc., can be generated
by running the foamCalc utility as before in section 2.1.5.7, this time on sigma:
foamCalc components sigma
Components named sigmaxx, sigmaxy etc. are written to time directories of the case.
The σxx stresses can be viewed in paraFoam as shown in Figure 2.18.
0
5
10
15
20
25
30
σxx(kPa)
Figure 2.18: σxx stress ﬁeld in the plate with hole.
We would like to compare the analytical solution of Equation 2.14 to our solution.
We therefore must output a set of data of σxx along the left edge symmetry plane of
our domain. The user may generate the required graph data using the sample utility.
The utility uses a sampleDict dictionary located in the system directory, whose entries are
summarised in Table 6.3. The sample line speciﬁed in sets is set between (0.0, 0.5, 0.25)
and (0.0, 2.0, 0.25), and the ﬁelds are speciﬁed in the fields list:
17 interpolationScheme cellPoint;
18
19 setFormat raw;
20
21 sets
22 (
23 leftPatch
24 {
25 type uniform;
26 axis y;
Open∇FOAM-1.5
U-54 Tutorials
0
5
10
15
20
25
30
35
0.6 0.8 1.0 1.2 1.4 1.6 1.8 2.0
Stress(σxx)x=0(kPa)
Distance, y (m)
Numerical prediction Analytical solution
Figure 2.19: Normal stress along the vertical symmetry (σxx)x=0
27 start (0 0.5 0.25);
28 end (0 2 0.25);
29 nPoints 100;
30 }
31 );
32
33 surfaces
34 ();
35
36 fields
37 (
38 sigmaxx
39 );
40
41 // ************************************************************************* //
The user should execute sample as normal. The writeFormat is raw 2 column format.
In an application such as GnuPlot, one could type the following at the command prompt
would be suﬃcient to plot both the numerical data and analytical solution:
plot [0.5:2] ’<datafile>’, 1e4*(1+(0.125/(x**2))+(0.09375/(x**4)))
An example plot is shown in Figure 2.19.
2.2.4 Exercises
The user may wish to experiment with solidDisplacementFoam by trying the following
exercises:
2.2.4.1 Increasing mesh resolution
Increase the mesh resolution in each of the x and y directions. Use mapFields to map the
ﬁnal coarse mesh results from section 2.2.3 to the initial conditions for the ﬁne mesh.
2.2.4.2 Introducing mesh grading
Grade the mesh so that the cells near the hole are ﬁner than those away from the hole.
Design the mesh so that the ratio of sizes between adjacent cells is no more than 1.1
and so that the ratio of cell sizes between blocks is similar to the ratios within blocks.
Open∇FOAM-1.5
2.3 Breaking of a dam U-55
Mesh grading is described in section 2.1.6. Again use mapFields to map the ﬁnal coarse
mesh results from section 2.2.3 to the initial conditions for the graded mesh. Compare
the results with those from the analytical solution and previous calculations. Can this
solution be improved upon using the same number of cells with a diﬀerent solution?
2.2.4.3 Changing the plate size
The analytical solution is for an inﬁnitely large plate with a ﬁnite sized hole in it. There-
fore this solution is not completely accurate for a ﬁnite sized plate. To estimate the error,
increase the plate size while maintaining the hole size at the same value.
2.3 Breaking of a dam
In this tutorial we shall solve a problem of simpliﬁed dam break in 2 dimensions using
the interFoam.The feature of the problem is a transient ﬂow of two ﬂuids separated by
a sharp interface, or free surface. The two-phase algorithm in interFoam is based on the
volume of ﬂuid (VOF) method in which a specie transport equation is used to determine
the relative volume fraction of the two phases, or phase fraction γ, in each computational
cell. Physical properties are calculated as weighted averages based on this fraction. The
nature of the VOF method means that an interface between the species is not explicitly
computed, but rather emerges as a property of the phase fraction ﬁeld. Since the phase
fraction can have any value between 0 and 1, the interface is never sharply deﬁned, but
occupies a volume around the region where a sharp interface should exist.
The test setup consists of a column of water at rest located behind a membrane on
the left side of a tank. At time t = 0 s, the membrane is removed and the column of
water collapses. During the collapse, the water impacts an obstacle at the bottom of the
tank and creates a complicated ﬂow structure, including several captured pockets of air.
The geometry and the initial setup is shown in Figure 2.20.
0.584 m
0.048 m
0.024 m
0.584 m
0.292 m
0.1459 m0.1461 m
water column
Figure 2.20: Geometry of the dam break.
Open∇FOAM-1.5
U-56 Tutorials
2.3.1 Mesh generation
The user should go to the damBreak case in their $FOAM RUN/tutorials/interFoam direc-
tory. Generate the mesh running blockMesh as described previously. The damBreak mesh
consist of 5 blocks; the blockMeshDict entries are given below.
17 convertToMeters 0.146;
18
19 vertices
20 (
21 (0 0 0)
22 (2 0 0)
23 (2.16438 0 0)
24 (4 0 0)
25 (0 0.32876 0)
26 (2 0.32876 0)
27 (2.16438 0.32876 0)
28 (4 0.32876 0)
29 (0 4 0)
30 (2 4 0)
31 (2.16438 4 0)
32 (4 4 0)
33 (0 0 0.1)
34 (2 0 0.1)
35 (2.16438 0 0.1)
36 (4 0 0.1)
37 (0 0.32876 0.1)
38 (2 0.32876 0.1)
39 (2.16438 0.32876 0.1)
40 (4 0.32876 0.1)
41 (0 4 0.1)
42 (2 4 0.1)
43 (2.16438 4 0.1)
44 (4 4 0.1)
45 );
46
47 blocks
48 (
49 hex (0 1 5 4 12 13 17 16) (23 8 1) simpleGrading (1 1 1)
50 hex (2 3 7 6 14 15 19 18) (19 8 1) simpleGrading (1 1 1)
51 hex (4 5 9 8 16 17 21 20) (23 42 1) simpleGrading (1 1 1)
52 hex (5 6 10 9 17 18 22 21) (4 42 1) simpleGrading (1 1 1)
53 hex (6 7 11 10 18 19 23 22) (19 42 1) simpleGrading (1 1 1)
54 );
55
56 edges
57 (
58 );
59
60 patches
61 (
62 wall leftWall
63 (
64 (0 12 16 4)
65 (4 16 20 8)
66 )
67 wall rightWall
68 (
69 (7 19 15 3)
70 (11 23 19 7)
71 )
72 wall lowerWall
73 (
74 (0 1 13 12)
75 (1 5 17 13)
76 (5 6 18 17)
77 (2 14 18 6)
78 (2 3 15 14)
79 )
80 patch atmosphere
81 (
82 (8 20 21 9)
83 (9 21 22 10)
84 (10 22 23 11)
85 )
86 );
87
88 mergePatchPairs
89 (
90 );
91
92 // ************************************************************************* //
Open∇FOAM-1.5
2.3 Breaking of a dam U-57
2.3.2 Boundary conditions
The user can examine the boundary geometry generated by blockMesh by viewing the
boundary ﬁle in the constant/polyMesh directory. The ﬁle contains a list of 5 boundary
patches: leftWall, rightWall, lowerWall, atmosphere and defaultFaces. The user
should notice the type of the patches. The atmosphere is a standard patch, i.e. has no
special attributes, merely an entity on which boundary conditions can be speciﬁed. The
defaultFaces patch is empty since the patch normal is in the direction we will not solve
in this 2D case. The leftWall, rightWall and lowerWall patches are each a wall. Like
the plain patch, the wall type contains no geometric or topological information about the
mesh and only diﬀers from the plain patch in that it identiﬁes the patch as a wall, should
an application need to know, e.g. to apply special wall surface modelling.
A good example is that the interFoam solver includes modelling of surface tension at
the contact point between the interface and wall surface. The models are applied by
specifying the gammaContactAngle boundary condition on the gamma (γ) ﬁeld. With it,
the user must specify the following: a static contact angle, theta0 θ0; leading and trailing
edge dynamic contact angles, thetaA θA and thetaR θR respectively; and a velocity scaling
function for dynamic contact angle, uTheta.
In this tutorial we would like to ignore surface tension eﬀects between the wall and
interface. We can do this by setting the static contact angle, θ0 = 90◦
and the velocity
scaling function to 0. However, the simpler option which we shall choose here is to
specify a zeroGradient type on gamma, rather than use the gammaContactAngle boundary
condition.
The top boundary is free to the atmosphere and so is given an atmosphere boundary
type; the defaultFaces representing the front and back planes of the 2D problem, is, as
usual, an empty type.
2.3.3 Setting initial ﬁeld
Unlike the previous cases, we shall now specify a non-uniform initial condition for the
phase fraction γ where
γ =
1 for the liquid phase
0 for the gas phase
(2.15)
This will be done by running the setFields utility. It requires a setFieldsDict dictionary,
located in the system directory, whose entries for this case are shown below.
17 defaultFieldValues
18 (
19 volScalarFieldValue gamma 0
20 volVectorFieldValue U (0 0 0)
21 );
22
23 regions
24 (
25 boxToCell
26 {
27 box (0 0 -1) (0.1461 0.292 1);
28
29 fieldValues
30 (
31 volScalarFieldValue gamma 1
32 );
33 }
34 );
35
36 // ************************************************************************* //
Open∇FOAM-1.5
U-58 Tutorials
The defaultFieldValues sets the default value of the ﬁelds, i.e. the value the ﬁeld
takes unless speciﬁed otherwise in the regions sub-dictionary. That sub-dictionary con-
tains a list of subdictionaries containing fieldValues that override the defaults in a
speciﬁed region. The region is expressed in terms of a topoSetSource that creates a set
of points, cells or faces based on some topological constraint. Here, boxToCell creates
a bounding box within a vector minimum and maximum to deﬁne the set of cells of the
liquid region. The phase fraction γ is deﬁned as 1 in this region.
The user should execute setFields as any other utility is executed. Using paraFoam,
check that the initial gamma ﬁeld corresponds to the desired distribution as in Figure 2.21.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, γ
Figure 2.21: Initial conditions for phase fraction gamma.
2.3.4 Fluid properties
Let us examine the transportProperties ﬁle in the constant directory. It dictionary con-
tains the material properties for each ﬂuid, separated into two subdictionaries phase1
and phase2. The transport model for each phase is selected by the transportModel
keyword. The user should select Newtonian in which case the kinematic viscosity is sin-
gle valued and speciﬁed under the keyword nu. The viscosity parameters for the other
models, e.g.CrossPowerLaw, are speciﬁed within subdictionaries with the generic name
<model>Coeﬀs, i.e.CrossPowerLawCoeﬀs in this example. The density is speciﬁed under
the keyword rho.
The surface tension between the two phases is speciﬁed under the keyword sigma.
The values used in this tutorial are listed in Table 2.3.
The environmentalProperties dictionary speciﬁes the gravity acceleration vector which
should be set to (0, 9.81, 0) m s−2
for this tutorial.
2.3.5 Time step control
Time step control is an important issue in free surface tracking since the surface-tracking
algorithm is considerably more sensitive to the Courant number Co than in standard ﬂuid
ﬂow calculations. Ideally, we should not exceed an upper limit Co ≈ 0.2 in the region
of the interface. In some cases, where the propagation velocity is easy to predict, the
user should specify a ﬁxed time-step to satisfy the Co criterion. For more complex cases,
Open∇FOAM-1.5
2.3 Breaking of a dam U-59
phase1 properties
Kinematic viscosity m2
s−1
nu 1.0 × 10−6
Density kg m−3
rho 1.0 × 103
phase2 properties
Kinematic viscosity m2
s−1
nu 1.48 × 10−5
Density kg m−3
rho 1.0
Properties of both phases
Surface tension N m−1
sigma 0.07
Table 2.3: Fluid properties for the damBreak tutorial
this is considerably more diﬃcult. interFoam therefore oﬀers automatic adjustment of the
time step as standard in the controlDict. The user should specify adjustTimeStep to be
on and the the maximum Co, maxCo to be 0.5. The upper limit on time step maxDeltaT
can be set to a value that will not be exceeded in this simulation, e.g. 1.0.
By using automatic time step control, the steps themselves are never rounded to a
convenient value. Consequently if we request that OpenFOAM saves results at a ﬁxed
number of time step intervals, the times at which results are saved are somewhat arbitrary.
However even with automatic time step adjustment, OpenFOAM allows the user to specify
that results are written at ﬁxed times; in this case OpenFOAM forces the automatic time
stepping procedure to adjust time steps so that it ‘hits’ on the exact times speciﬁed for
write output. The user selects this with the adjustableRunTime option for writeControl
in the controlDict dictionary. The controlDict dictionary entries should be:
17 application interFoam;
18
19 startFrom startTime;
20
21 startTime 0;
22
23 stopAt endTime;
24
25 endTime 1;
26
27 deltaT 0.001;
28
29 writeControl adjustableRunTime;
30
31 writeInterval 0.05;
32
33 purgeWrite 0;
34
35 writeFormat ascii;
36
37 writePrecision 6;
38
39 writeCompression uncompressed;
40
41 timeFormat general;
42
43 timePrecision 6;
44
45 runTimeModifiable yes;
46
47 adjustTimeStep yes;
48
49 maxCo 0.5;
50
51 maxDeltaT 1;
52
53 // ************************************************************************* //
Open∇FOAM-1.5
U-60 Tutorials
2.3.6 Discretisation schemes
The free surface treatment in OpenFOAM does not account for the eﬀects of turbulence.
This is a consequence of the fact that the Reynolds averaged approach to turbulence
modelling does not match the notion of an inﬁnitesimally thin interface between air and
water. As a consequence, all free surface simulations can be viewed as a direct numerical
simulation (DNS) of ﬂuid ﬂow. DNS is associated with certain requirements on the mesh
size, far beyond the mesh resolution of our test case.
This solver uses the multidimensional universal limiter for explicit solution (MULES)
method, created by OpenCFD, to maintain boundedness of the phase fraction indepen-
dent of underlying numerical scheme, mesh structure, etc.. The choice of schemes for
convection are therfore not restricted to those that are strongly stable or bounded, e.g.
upwind diﬀerencing.
The convection schemes settings are made in the divSchemes sub-dictionary of the
fvSchemes dictionary. In this example, the convection term in the momentum equa-
tion (∇ • (ρφU)), denoted by the div(rho*phi,U) keyword, uses Gauss limitedLinearV
1.0 to produce good accuracy. The limited linear schemes require a coeﬃcient φ as de-
scribed in section 4.4.1. Here, we have opted for best stability with φ = 1.0. The
∇ • (φγ) term, represented by the div(phi,gamma) keyword uses the vanLeer scheme.
The ∇ • (φrbγ) term, represented by the div(phirb,gamma) keyword, can similarly use
the vanLeer scheme, but generally produces smoother interfaces using the specialised
interfaceCompression scheme.
The other discretised terms use commonly employed schemes so that the fvSchemes
dictionary entries should therefore be:
17 ddtSchemes
18 {
19 default Euler;
20 }
21
22 gradSchemes
23 {
24 default Gauss linear;
25 grad(U) Gauss linear;
26 grad(gamma) Gauss linear;
27 }
28
29 divSchemes
30 {
31 div(rho*phi,U) Gauss limitedLinearV 1;
32 div(phi,gamma) Gauss vanLeer;
33 div(phirb,gamma) Gauss interfaceCompression;
34 }
35
36 laplacianSchemes
37 {
38 default Gauss linear corrected;
39 }
40
41 interpolationSchemes
42 {
43 default linear;
44 }
45
46 snGradSchemes
47 {
48 default corrected;
49 }
50
51 fluxRequired
52 {
53 default no;
54 pd;
55 pcorr;
56 gamma;
57 }
58
59 // ************************************************************************* //
Open∇FOAM-1.5
2.3 Breaking of a dam U-61
2.3.7 Linear-solver control
In the fvSolution, the PISO sub-dictionary contains elements that are speciﬁc to interFoam.
There are the usual correctors to the momentum equation but also correctors to a PISO
loop around the γ phase equation. Of particular interest are the nGammaSubCycles and
cGamma keywords. nGammaSubCycles represents the number of sub-cycles within the γ
equation; sub-cycles are additional solutions to an equation within a given time step. It
is used to enable the solution to be stable without reducing the time step and vastly
increasing the solution time. Here we specify 4 sub-cycles, which means that the γ
equation is solved in 4× quarter length time steps within each actual time step.
The cGamma keyword is a factor that controls the compression of the interface where: 0
corresponds to no compression; 1 corresponds to conservative compression; and, anything
larger than 1, relates to enhanced compression of the interface. We generally recommend
a value of 1.0 which is employed in this example.
2.3.8 Running the code
Running of the code has been described in detail in previous tutorials. Try the following,
that uses tee, a command that enables output to be written to both standard output and
ﬁles:
cd $FOAM RUN/tutorials/interFoam
interFoam | tee log
The code will now be run interactively, with a copy of output stored in the log ﬁle.
2.3.9 Post-processing
Post-processing of the results can now be done in the usual way. The user can monitor
the development of the phase fraction gamma in time; Figure 2.22.
2.3.10 Running in parallel
The results from the previous example are generated using a fairly coarse mesh. We now
wish to increase the mesh resolution and re-run the case. The new case will typically
take a few hours to run with a single processor so, should the user have access to multiple
processors, we can demonstrate the parallel processing capability of OpenFOAM.
The user should ﬁrst make a copy of the damBreak case, e.g. by
cd $FOAM RUN/tutorials/interFoam
mkdir damBreakFine
cp -r damBreak/0 damBreakFine
cp -r damBreak/system damBreakFine
cp -r damBreak/constant damBreakFine
Enter the new case directory and change the blocks description in the blockMeshDict
dictionary to
blocks
(
hex (0 1 5 4 12 13 17 16) (46 10 1) simpleGrading (1 1 1)
Open∇FOAM-1.5
U-62 Tutorials
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, γ
(a) At t = 0.25 s.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, γ
(b) At t = 0.50 s.
Figure 2.22: Snapshots of phase γ.
Open∇FOAM-1.5
2.3 Breaking of a dam U-63
hex (2 3 7 6 14 15 19 18) (40 10 1) simpleGrading (1 1 1)
hex (4 5 9 8 16 17 21 20) (46 76 1) simpleGrading (1 2 1)
hex (5 6 10 9 17 18 22 21) (4 76 1) simpleGrading (1 2 1)
hex (6 7 11 10 18 19 23 22) (40 76 1) simpleGrading (1 2 1)
);
Here, the entry is presented as printed from the blockMeshDict ﬁle; in short the user must
change the mesh densities, e.g. the 46 10 1 entry, and some of the mesh grading entries
to 1 2 1. Once the dictionary is correct, generate the mesh.
As the mesh has now changed from the damBreak example, the user must re-initialise
the phase ﬁeld gamma in the 0 time directory since it contains a number of elements that
is inconsistent with the new mesh. Note that there is no need to change the U and p
ﬁelds since they are speciﬁed as uniform which is independent of the number of elements
in the ﬁeld. We wish to initialise the ﬁeld with a sharp interface, i.e. it elements would
have γ = 1 or γ = 0. Updating the ﬁeld with mapFields may produce interpolated values
0 < γ < 1 at the interface, so it is better to rerun the setFields utility. There is a
backup copy of the initial uniform γ ﬁeld named 0/gamma.org that the user should copy
to 0/gamma before running setFields:
cd $FOAM RUN/tutorials/interFoam/damBreakFine
cp -r 0/gamma.org 0/gamma
setFields
The method of parallel computing used by OpenFOAM is known as domain de-
composition, in which the geometry and associated ﬁelds are broken into pieces and
allocated to separate processors for solution. The ﬁrst step required to run a parallel
case is therefore to decompose the domain using the decomposePar utility. There is a
dictionary associated with decomposePar named decomposeParDict which is located in
the system directory of the tutorial case; also, like with many utilities, a default dic-
tionary can be found in the directory of the source code of the speciﬁc utility, i.e. in
$FOAM UTILITIES/parallelProcessing/decomposePar for this case.
The ﬁrst entry is numberOfSubdomains which speciﬁes the number of subdomains into
which the case will be decomposed, usually corresponding to the number of processors
available for the case.
In this tutorial, the method of decomposition should be simple and the corresponding
simpleCoeffs should be edited according to the following criteria. The domain is split
into pieces, or subdomains, in the x, y and z directions, the number of subdomains in
each direction being given by the vector n. As this geometry is 2 dimensional, the 3rd
direction, z, cannot be split, hence nz must equal 1. The nx and ny components of n
split the domain in the x and y directions and must be speciﬁed so that the number
of subdomains speciﬁed by nx and ny equals the speciﬁed numberOfSubdomains, i.e.
nxny = numberOfSubdomains. It is beneﬁcial to keep the number of cell faces adjoining
the subdomains to a minimum so, for a square geometry, it is best to keep the split
between the x and y directions should be fairly even. The delta keyword should be set
to 0.001.
For example, let us assume we wish to run on 4 processors. We would set number-
OfSubdomains to 4 and n = (2, 2, 1). When running decomposePar, we can see from the
screen messages that the decomposition is distributed fairly even between the processors.
The user should consult section 3.4 for details of how to run a case in parallel; in
this tutorial we merely present an example of running in parallel. We use the openMPI
Open∇FOAM-1.5
U-64 Tutorials
implementation of the standard message-passing interface (MPI). As a test here, the user
can run in parallel on a single node, the local host only, by typing:
mpirun -np 4 interFoam -parallel > log &
The user may run on more nodes over a network by creating a ﬁle that lists the host
names of the machines on which the case is to be run as described in section 3.4.2. The
case should run in the background and the user can follow its progress by monitoring the
log ﬁle as usual.
Figure 2.23: Mesh of processor 2 in parallel processed case.
2.3.11 Post-processing a case run in parallel
Once the case has completed running, the decomposed ﬁelds and mesh must be reassem-
bled for post-processing using the reconstructPar utility. Simply execute it from the com-
mand line. The results from the ﬁne mesh are shown in Figure 2.24. The user can see
that the resolution of interface has improved signiﬁcantly compared to the coarse mesh.
The user may also post-process a segment of the decomposed domain individually by
simply treating the individual processor directory as a case in its own right. For example
if the user starts paraFoam by
paraFoam -case processor1
then processor1 will appear as a case module in ParaView. Figure 2.23 shows the mesh
from processor 1 following the decomposition of the domain using the simple method.
Open∇FOAM-1.5
2.3 Breaking of a dam U-65
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, γ
(a) At t = 0.25 s.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, γ
(b) At t = 0.50 s.
Figure 2.24: Snapshots of phase γ with reﬁned mesh.
Open∇FOAM-1.5
U-66 Tutorials
Open∇FOAM-1.5
Chapter 3
Applications and libraries
We should reiterate from the outset that OpenFOAM is a C++ library used primarily to
create executables, known as applications. OpenFOAM is distributed with a large set of
precompiled applications but users also have the freedom to create their own or modify
existing ones. Applications are split into two main categories:
solvers that are each designed to solve a speciﬁc problem in computational continuum
mechanics;
utilities that perform simple pre-and post-processing tasks, mainly involving data ma-
nipulation and algebraic calculations.
OpenFOAM is divided into a set of precompiled libraries that are dynamically linked
during compilation of the solvers and utilities. Libraries such as those for physical models
are supplied as source code so that users may conveniently add their own models to the
libraries.
This chapter gives an overview of solvers, utilities and libraries, their creation, mod-
iﬁcation, compilation and execution. The actual writing of code for solvers and utilities
is not described here but is within the Programmer’s Guide. The Programmer’s Guide is
currently under development so, if users have any queries, further information may also
available at the OpenFOAM discussion group and the OpenFOAM web site.
3.1 The programming language of OpenFOAM
In order to understand the way in which the OpenFOAM library works, some background
knowledge of C++, the base language of OpenFOAM, is required; the necessary infor-
mation will be presented in this chapter. Before doing so, it is worthwhile addressing the
concept of language in general terms to explain some of the ideas behind object-oriented
programming and our choice of C++ as the main programming language of OpenFOAM.
3.1.1 Language in general
The success of verbal language and mathematics is based on eﬃciency, especially in
expressing abstract concepts. For example, in ﬂuid ﬂow, we use the term “velocity ﬁeld”,
which has meaning without any reference to the nature of the ﬂow or any speciﬁc velocity
data. The term encapsulates the idea of movement with direction and magnitude and
relates to other physical properties. In mathematics, we can represent velocity ﬁeld by
a single symbol, e.g. U, and express certain concepts using symbols, e.g. “the ﬁeld of
velocity magnitude” by |U|. The advantage of mathematics over verbal language is its
greater eﬃciency, making it possible to express complex concepts with extreme clarity.
U-68 Applications and libraries
The problems that we wish to solve in continuum mechanics are not presented in
terms of intrinsic entities, or types, known to a computer, e.g. bits, bytes, integers. They
are usually presented ﬁrst in verbal language, then as partial diﬀerential equations in 3
dimensions of space and time. The equations contain the following concepts: scalars,
vectors, tensors, and ﬁelds thereof; tensor algebra; tensor calculus; dimensional units.
The solution to these equations involves discretisation procedures, matrices, solvers, and
solution algorithms. The topics of tensor mathematics and numerics are the subjects of
chapter 1 and chapter 2 of the Programmer’s Guide.
3.1.2 Object-orientation and C++
Progamming languages that are object-oriented, such as C++, provide the mechanism
— classes — to declare types and associated operations that are part of the verbal and
mathematical languages used in science and engineering. Our velocity ﬁeld introduced
earlier can be represented in programming code by the symbol U and “the ﬁeld of velocity
magnitude” can be mag(U). The velocity is a vector ﬁeld for which there should exist,
in an object-oriented code, a vectorField class. The velocity ﬁeld U would then be an
instance, or object, of the vectorField class; hence the term object-oriented.
The clarity of having objects in programming that represent physical objects and
abstract entities should not be underestimated. The class structure concentrates code
development to contained regions of the code, i.e. the classes themselves, thereby making
the code easier to manage. New classes can be derived or inherit properties from other
classes, e.g. the vectorField can be derived from a vector class and a Field class. C++
provides the mechanism of template classes such that the template class Field<Type> can
represent a ﬁeld of any <Type>, e.g.scalar, vector, tensor. The general features of the
template class are passed on to any class created from the template. Templating and
inheritance reduce duplication of code and create class hierarchies that impose an overall
structure on the code.
3.1.3 Equation representation
A central theme of the OpenFOAM design is that the solver applications, written using the
OpenFOAM classes, have a syntax that closely resembles the partial diﬀerential equations
being solved. For example the equation
∂ρU
∂t
+ ∇ • φU − ∇ • µ∇U = −∇p
is represented by the code
solve
(
fvm::ddt(rho, U)
+ fvm::div(phi, U)
- fvm::laplacian(mu, U)
==
- fvc::grad(p)
);
This and other requirements demand that the principal programming language of Open-
FOAM has object-oriented features such as inheritance, template classes, virtual functions
Open∇FOAM-1.5
3.2 Compiling applications and libraries U-69
and operator overloading. These features are not available in many languages that pur-
port to be object-orientated but actually have very limited object-orientated capability,
such as FORTRAN-90. C++, however, possesses all these features while having the ad-
ditional advantage that it is widely used with a standard speciﬁcation so that reliable
compilers are available that produce eﬃcient executables. It is therefore the primary
language of OpenFOAM.
3.1.4 Solver codes
Solver codes are largely procedural since they are a close representation of solution algo-
rithms and equations, which are themselves procedural in nature. Users do not need a
deep knowledge of object-orientation and C++ programming to write a solver but should
know the principles behind object-orientation and classes, and to have a basic knowledge
of some C++ code syntax. An understanding of the underlying equations, models and
solution method and algorithms is far more important.
There is often little need for a user to immerse themselves in the code of any of the
OpenFOAM classes. The essence of object-orientation is that the user should not have
to; merely the knowledge of the class’ existence and its functionality are suﬃcient to use
the class. A description of each class, its functions etc. is supplied with the OpenFOAM
distribution in HTML documentation generated with Doxygen at $WM PROJECT DIR/-
doc/Doxygen/html/index.html.
3.2 Compiling applications and libraries
Compilation is an integral part of application development that requires careful man-
agement since every piece of code requires its own set instructions to access dependent
components of the OpenFOAM library. In UNIX/Linux systems these instructions are of-
ten organised and delivered to the compiler using the standard UNIXmake utility. Open-
FOAM, however, is supplied with the wmake compilation script that is based on make
but is considerably more versatile and easier to use; wmake can, in fact, be used on any
code, not simply the OpenFOAM library. To understand the compilation process, we
ﬁrst need to explain certain aspects of C++ and its ﬁle structure, shown schematically
in Figure 3.1. A class is deﬁned through a set of instructions such as object construction,
data storage and class member functions. The ﬁle containing the class deﬁnition takes
a .C extension, e.g. a class nc would be written in the ﬁle nc.C. This ﬁle can be com-
piled independently of other code into a binary executable library ﬁle known as a shared
object library with the .so ﬁle extension, i.e.nc.so. When compiling a piece of code, say
newApp.C, that uses the nc class, nc.C need not be recompiled, rather newApp.C calls
nc.so at runtime. This is known as dynamic linking.
3.2.1 Header .H ﬁles
As a means of checking errors, the piece of code being compiled must know that the classes
it uses and the operations they perform actually exist. Therefore each class requires a
class declaration, contained in a header ﬁle with a .H ﬁle extension, e.g.nc.H, that includes
the names of the class and its functions. This ﬁle is included at the beginning of any piece
of code using the class, including the class declaration code itself. Any piece of .C code
can resource any number of classes and must begin with all the .H ﬁles required to declare
these classes. The classes in turn can resource other classes and begin with the relevant
.H ﬁles. By searching recursively down the class hierarchy we can produce a complete list
Open∇FOAM-1.5
U-70 Applications and libraries
int main()
...
...
return(0);
{
}
nc.so
Library
option-I#include "nc.H"
Main code
Code...
Compiled
nc.H
nc.C
#include "nc.H"
nc class
Definition...
Compiled
Executable
Header ﬁle
Linked
option-l
newApp.C
newApp
Figure 3.1: Header ﬁles, source ﬁles, compilation and linking.
of header ﬁles for all the classes on which the top level .C code ultimately depends; these
.H ﬁles are known as the dependencies. With a dependency list, a compiler can check
whether the source ﬁles have been updated since their last compilation and selectively
compile only those that need to be.
Header ﬁles are included in the code using # include statements, e.g.
# include "otherHeader.H";
causes the compiler to suspend reading from the current ﬁle to read the ﬁle speciﬁed.
Any self-contained piece of code can be put into a header ﬁle and included at the rel-
evant location in the main code in order to improve code readability. For example, in
most OpenFOAM applications the code for creating ﬁelds and reading ﬁeld input data is
included in a ﬁle createFields.H which is called at the beginning of the code. In this way,
header ﬁles are not solely used as class declarations. It is wmake that performs the task
of maintaining ﬁle dependency lists amongst other functions listed below.
• Automatic generation and maintenance of ﬁle dependency lists, i.e. lists of ﬁles
which are included in the source ﬁles and hence on which they depend.
• Multi-platform compilation and linkage, handled through appropriate directory
structure.
• Multi-language compilation and linkage, e.g. C, C++, Java.
• Multi-option compilation and linkage, e.g. debug, optimised, parallel and proﬁling.
• Support for source code generation programs, e.g. lex, yacc, IDL, MOC.
• Simple syntax for source ﬁle lists.
• Automatic creation of source ﬁle lists for new codes.
• Simple handling of multiple shared or static libraries.
• Extensible to new machine types.
Open∇FOAM-1.5
3.2 Compiling applications and libraries U-71
• Extremely portable, works on any machine with: make; sh, ksh or csh; lex, cc.
• Has been tested on Apollo, SUN, SGI, HP (HPUX), Compaq (DEC), IBM (AIX),
Cray, Ardent, Stardent, PC Linux, PPC Linux, NEC, SX4, Fujitsu VP1000.
3.2.2 Compiling with wmake
OpenFOAM applications are organised using a standard convention that the source code
of each application is placed in a directory whose name is that of the application. The
top level source ﬁle takes the application name with the .C extension. For example, the
source code for an application called newApp would reside is a directory newApp and the
top level ﬁle would be newApp.C as shown in Figure 3.2. The directory must also contain
newApp
newApp.C
otherHeader.H
Make
ﬁles
options
Figure 3.2: Directory structure for an application
a Make subdirectory containing 2 ﬁles, options and ﬁles, that are described in the following
sections.
3.2.2.1 Including headers
The compiler searches for the included header ﬁles in the following order, speciﬁed with
the -I option in wmake:
1. the $WM PROJECT DIR/src/OpenFOAM/lnInclude directory;
2. a local lnInclude directory, i.e.newApp/lnInclude;
3. the local directory, i.e.newApp;
4. platform dependent paths set in ﬁles in the $WM PROJECT DIR/wmake/rules/-
$WM ARCH/ directory, e.g./usr/X11/include and $(MPICH ARCH PATH)/include;
5. other directories speciﬁed explicitly in the Make/options ﬁle with the -I option.
The Make/options ﬁle contains the full directory paths to locate header ﬁles using the
syntax:
EXE INC = \
-I<directoryPath1> \
-I<directoryPath2> \
... \
-I<directoryPathN>
Notice ﬁrst that the directory names are preceeded by the -I ﬂag and that the syntax
uses the \ to continue the EXE INC across several lines, with no \ after the ﬁnal entry.
Open∇FOAM-1.5
U-72 Applications and libraries
3.2.2.2 Linking to libraries
The compiler links to shared object library ﬁles in the following directory paths, speciﬁed
with the -L option in wmake:
1. the $FOAM LIBBIN directory;
2. platform dependent paths set in ﬁles in the $WM DIR/rules/$WM ARCH/ directory,
e.g./usr/X11/lib and $(MPICH ARCH PATH)/lib;
3. other directories speciﬁed in the Make/options ﬁle.
The actual library ﬁles to be linked must be speciﬁed using the -l option and removing
the lib preﬁx and .so extension from the library ﬁle name, e.g.libnew.so is included with
the ﬂag -lnew. By default, wmake loads the following libraries:
1. the libOpenFOAM.so library from the $FOAM LIBBIN directory;
2. platform dependent libraries speciﬁed in set in ﬁles in the $WM DIR/rules/$WM ARCH/
directory, e.g.libm.so from /usr/X11/lib and liblam.so from $(LAM ARCH PATH)/lib;
3. other libraries speciﬁed in the Make/options ﬁle.
The Make/options ﬁle contains the full directory paths and library names using the syntax:
EXE LIBS = \
-L<libraryPath1> \
-L<libraryPath2> \
... \
-L<libraryPathN> \
-l<library1> \
-l<library2> \
... \
-l<libraryN>
Let us reiterate that the directory paths are preceeded by the -L ﬂag, the library names
are preceeded by the -l ﬂag.
3.2.2.3 Source ﬁles to be compiled
The compiler requires a list of .C source ﬁles that must be compiled. The list must contain
the main .C ﬁle but also any other source ﬁles that are created for the speciﬁc application
but are not included in a class library. For example, users may create a new class or
some new functionality to an existing class for a particular application. The full list of
.C source ﬁles must be included in the Make/ﬁles ﬁle. As might be expected, for many
applications the list only includes the name of the main .C ﬁle, e.g.newApp.C in the case
of our earlier example.
The Make/ﬁles ﬁle also includes a full path and name of the compiled executable,
speciﬁed by the EXE = syntax. Standard convention stipulates the name is that of the ap-
plication, i.e.newApp in our example. The OpenFOAM release oﬀers two useful choices for
path: standard release applications are stored in $FOAM APPBIN; applications developed
by the user are stored in $FOAM USER APPBIN.
If the user is developing their own applications, we recommend they create an appli-
cations subdirectory in their $WM PROJECT USER DIR directory containing the source
Open∇FOAM-1.5
3.2 Compiling applications and libraries U-73
code for personal OpenFOAM applications. As with standard applications, the source
code for each OpenFOAM application should be stored within its own directory. The
only diﬀerence between a user application and one from the standard release is that the
Make/ﬁles ﬁle should specify that the user’s executables are written into their $FOAM -
USER APPBIN directory. The Make/ﬁles ﬁle for our example would appear as follows:
newApp.C
EXE = $(FOAM_USER_APPBIN)/newApp
3.2.2.4 Running wmake
The wmake script is executed by typing:
wmake <optionalArguments> <optionalDirectory>
The <optionalDirectory> is the directory path of the application that is being com-
piled. Typically, wmake is executed from within the directory of the application being
compiled, in which case <optionalDirectory> can be omitted.
If a user wishes to build an application executable, then no <optionalArguments>
are required. However <optionalArguments> may be speciﬁed for building libraries etc.
as described in Table 3.1.
Argument Type of compilation
lib Build a statically-linked library
libso Build a dynamically-linked library
libo Build a statically-linked object ﬁle library
jar Build a JAVA archive
exe Build an application independent of the speciﬁed project library
Table 3.1: Optional compilation arguments to wmake.
3.2.2.5 wmake environment variables
For information, the environment variable settings used by wmake are listed in Table 3.2.
3.2.3 Removing dependency lists: wclean and rmdepall
On execution, wmake builds a dependency list ﬁle with a .dep ﬁle extension, e.g.newApp.dep
in our example, and a list of ﬁles in a Make/$WM OPTIONS directory. If the user wishes
to remove these ﬁles, perhaps after making code changes, the user can run the wclean
script by typing:
wclean <optionalArguments> <optionalDirectory>
Again, the <optionalDirectory> is a path to the directory of the application that is
being compiled. Typically, wclean is executed from within the directory of the application,
in which case the path can be omitted.
Open∇FOAM-1.5
U-74 Applications and libraries
Main paths
$WM PROJECT INST DIR Full path to installation directory,
e.g.$HOME/OpenFOAM
$WM PROJECT Name of the project being compiled: OpenFOAM
$WM PROJECT VERSION Version of the project being compiled: 1.5
$WM PROJECT DIR Full path to locate binary executables of OpenFOAM
release, e.g.$HOME/OpenFOAM/OpenFOAM-1.5
$WM PROJECT USER DIR Full path to locate binary executables of the user
e.g.$HOME/OpenFOAM/${USER}-1.5
Other paths/settings
$WM ARCH Machine architecture: cray decAlpha dec ibm linux
linuxPPC sgi3 sgi32 sgi64 sgiN32 solaris sx4 t3d
$WM COMPILER Compiler being used: Gcc3 - gcc 4.3.1, KAI - KAI
$WM COMPILER DIR Compiler installation directory
$WM COMPILER BIN Compiler installation binaries $WM COMPILER BIN/bin
$WM COMPILER LIB Compiler installation libraries $WM COMPILER BIN/lib
$WM COMPILE OPTION Compilation option: Debug - debugging, Opt optimisa-
tion.
$WM DIR Full path of the wmake directory
$WM JAVAC OPTION Compilation option for JAVA: Debug - debugging, Opt
optimisation.
$WM LINK LANGUAGE Compiler used to link libraries and executables. In multi-
language projects a $WM LINK LANGUAGE is set to the
primary language.
$WM MPLIB Parallel communications library: LAM, MPI, MPICH, PVM
$WM OPTIONS = $WM ARCH$WM COMPILER...
...$WM COMPILE OPTION$WM MPLIB
e.g.linuxGcc3OptMPICH
$WM PROJECT LANGUAGE Programming language of project, e.g.c++
$WM SHELL Shell used for the wmake scripts bash, csh, ksh, tcsh
Table 3.2: Environment variable settings for wmake.
If a user wishes to remove the dependency ﬁles and ﬁles from the Make directory, then
no <optionalArguments> are required. However if lib is speciﬁed in <optionalArguments>
a local lnInclude directory will be deleted also.
An additional script, rmdepall removes all dependency .dep ﬁles recursively down the
directory tree from the point at which it is executed. This can be useful when updating
OpenFOAM libraries.
3.2.4 Compilation example: the turbFoam application
The source code for application turbFoam is in the $FOAM APP/solvers/turbFoam direc-
tory and the top level source ﬁle is named turbFoam.C. The turbFoam.C source code is:
1 /*---------------------------------------------------------------------------*\
2 ========= |
3 \\ / F ield | OpenFOAM: The Open Source CFD Toolbox
4 \\ / O peration |
5 \\ / A nd | Copyright (C) 1991-2008 OpenCFD Ltd.
Open∇FOAM-1.5
3.2 Compiling applications and libraries U-75
6 \\/ M anipulation |
7 -------------------------------------------------------------------------------
8 License
9 This file is part of OpenFOAM.
10
11 OpenFOAM is free software; you can redistribute it and/or modify it
12 under the terms of the GNU General Public License as published by the
13 Free Software Foundation; either version 2 of the License, or (at your
14 option) any later version.
15
16 OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
17 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
18 FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
19 for more details.
20
21 You should have received a copy of the GNU General Public License
22 along with OpenFOAM; if not, write to the Free Software Foundation,
23 Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
24
25 Application
26 turbFoam
27
28 Description
29 Transient solver for incompressible, turbulent flow.
30
31 \*---------------------------------------------------------------------------*/
32
33 #include "fvCFD.H"
34 #include "incompressible/singlePhaseTransportModel/singlePhaseTransportModel.H"
35 #include "incompressible/RASModel/RASModel.H"
36
37 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
38
39 int main(int argc, char *argv[])
40 {
41
42 # include "setRootCase.H"
43
44 # include "createTime.H"
45 # include "createMesh.H"
46 # include "createFields.H"
47 # include "initContinuityErrs.H"
48
49 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
50
51 Info<< "\nStarting time loop\n" << endl;
52
53 for (runTime++; !runTime.end(); runTime++)
54 {
55 Info<< "Time = " << runTime.timeName() << nl << endl;
56
57 # include "readPISOControls.H"
58 # include "CourantNo.H"
59
60 // Pressure-velocity PISO corrector
61 {
62 // Momentum predictor
63
64 fvVectorMatrix UEqn
65 (
66 fvm::ddt(U)
67 + fvm::div(phi, U)
68 + turbulence->divDevReff(U)
69 );
70
71 if (momentumPredictor)
72 {
73 solve(UEqn == -fvc::grad(p));
74 }
75
76 // --- PISO loop
77
78 for (int corr=0; corr<nCorr; corr++)
79 {
80 volScalarField rUA = 1.0/UEqn.A();
81
82 U = rUA*UEqn.H();
83 phi = (fvc::interpolate(U) & mesh.Sf())
84 + fvc::ddtPhiCorr(rUA, U, phi);
85
86 adjustPhi(phi, U, p);
87
88 // Non-orthogonal pressure corrector loop
89 for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
Open∇FOAM-1.5
U-76 Applications and libraries
90 {
91 // Pressure corrector
92
93 fvScalarMatrix pEqn
94 (
95 fvm::laplacian(rUA, p) == fvc::div(phi)
96 );
97
98 pEqn.setReference(pRefCell, pRefValue);
99 pEqn.solve();
100
101 if (nonOrth == nNonOrthCorr)
102 {
103 phi -= pEqn.flux();
104 }
105 }
106
107 # include "continuityErrs.H"
108
109 U -= rUA*fvc::grad(p);
110 U.correctBoundaryConditions();
111 }
112 }
113
114 turbulence->correct();
115
116 runTime.write();
117
118 Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
119 << " ClockTime = " << runTime.elapsedClockTime() << " s"
120 << nl << endl;
121 }
122
123 Info<< "End\n" << endl;
124
125 return(0);
126 }
127
128
129 // ************************************************************************* //
The code begins with a brief description of the application contained within comments
over 1 line (//) and multiple lines (/*...*/). Following that, the code contains several
# include statements, e.g.# include "fvCFD.H", which causes the compiler to suspend
reading from the current ﬁle, turbFoam.C to read the fvCFD.H.
turbFoam resources the cfdTools, incompressibleRASModels and incompressibleTrans-
portModels libraries and therefore requires the necessary header ﬁles, speciﬁed by the
EXE INC = -I... option, and links to the libraries with the EXE LIBS = -l... option.
The Make/options therefore contains the following:
1 EXE_INC = \
2 -I$(LIB_SRC)/turbulenceModels/RAS \
3 -I$(LIB_SRC)/transportModels \
4 -I$(LIB_SRC)/finiteVolume/lnInclude
5
6 EXE_LIBS = \
7 -lincompressibleRASModels \
8 -lincompressibleTransportModels \
9 -lfiniteVolume \
10 -lmeshTools
turbFoam contains only the turbFoam.C source and the executable is written to the
$FOAM APPBIN directory as all standard applications are. The Make/ﬁles therefore con-
tains:
1 turbFoam.C
2
3 EXE = $(FOAM_APPBIN)/turbFoam
The user can compile turbFoam by going to the $FOAM CFD/turbFoam directory and
typing:
wmake
Open∇FOAM-1.5
3.2 Compiling applications and libraries U-77
The code should compile and produce a message similar to the following
Making dependency list for source file turbFoam.C
SOURCE DIR=.
SOURCE=turbFoam.C ;
g++ -DFOAM EXCEPTION -Dlinux -DlinuxOptMPICH
-DscalarMachine -DoptSolvers -DPARALLEL -DUSEMPI -Wall -O2 -DNoRepository
-ftemplate-depth-17 -I/export/warhol/chris/OpenFOAM/OpenFOAM-1.5/src/OpenFOAM/lnInclude
-IlnInclude
-I.
......
-lmpich -L/usr/X11/lib -lm
-o /export/warhol/chris/OpenFOAM/OpenFOAM-1.5/applications/bin/linuxOptMPICH/turbFoam
The user can now try recompiling and will receive a message similar to the following to
say that the executable is up to date and compiling is not necessary:
make: Nothing to be done for ‘allFiles’.
make: ‘Make/linuxOptMPICH/dependencies’ is up to date.
make: ‘/export/warhol/chris/OpenFOAM/OpenFOAM-1.5/applications/bin/linuxOptMPICH/turbFoam’
is up to date.
The user can compile the application from scratch by removing the dependency list with
wclean
and running wmake.
3.2.5 Debug messaging and optimisation switches
OpenFOAM provides a system of messaging that is written during runtime, most of which
are to help debugging problems encountered during running of a OpenFOAM case. The
switches are listed in the $WM PROJECT DIR/.OpenFOAM-1.5/controlDict ﬁle; should
the user wish to change the settings they should make a copy to their $HOME directory,
i.e.$HOME/.OpenFOAM-1.5/controlDict ﬁle. The list of possible switches is extensive
and can be viewed by running the foamDebugSwitches application. Most of the switches
correspond to a class or range of functionality and can be switched on by their inclusion
in the controlDict ﬁle, and by being set to 1. For example, OpenFOAM can perform the
checking of dimensional units in all calculations by setting the dimensionSet switch to
1. There are some switches that control messaging at a higher level than most, listed in
Table 3.3.
In addition, there are some switches that control certain operational and optimisa-
tion issues. These switches are also listed in Table 3.3. Of particular importance is
fileModificationSkew. OpenFOAM scans the write time of data ﬁles to check for mod-
iﬁcation. When running over a NFS with some disparity in the clock settings on diﬀerent
machines, ﬁeld data ﬁles appear to be modiﬁed ahead of time. This can cause a problem
if OpenFOAM views the ﬁles as newly modiﬁed and attempting to re-read this data. The
fileModificationSkew keyword is the time in seconds that OpenFOAM will subtract
from the ﬁle write time when assessing whether the ﬁle has been newly modiﬁed.
Open∇FOAM-1.5
U-78 Applications and libraries
High level debugging switches - sub-dictionary DebugSwitches
level Overall level of debugging messaging for OpenFOAM- - 3 levels 0,
1, 2
lduMatrix Messaging for solver convergence during a run - 3 levels 0, 1, 2
Optimisation switches - sub-dictionary OptimisationSwitches
fileModific-
ationSkew
A time in seconds that should be set higher than the maximum
delay in NFS updates and clock diﬀerence for running OpenFOAM
over a NFS.
nProcsSimpleSum Optimises global sum for parallel processing; sets number of pro-
cessors above which hierarchical sum is performed rather than a
linear sum (default 16)
Table 3.3: Runtime message switches.
3.2.6 Linking new user-deﬁned libraries to existing applications
The situation may arise that a user creates a new library, say new, and wishes the features
within that library to be available across a range of applications. For example, the
user may create a new boundary condition, compiled into new, that would need to be
recognised by a range of solver applications, pre- and post-processing utilities, mesh tools,
etc. Under normal circumstances, the user would need to recompile every application with
the new linked to it.
Instead, OpenFOAM uses a special library called foamUser to eliminate the need to
recompile. It works by ﬁrst having the foamUser library compiled into each application
by default. The foamUser library is compiled from code located in $FOAM SRC/foamUser
directory. The user simply needs to add the new library to the linked libraries in the
Make/options ﬁle of foamUser and recompile foamUser.
Taking the example already given, the user should therefore make a local copy of the
foamUser directory, and move to that directory, e.g.:
cp -r $WM PROJECT DIR/src/foamUser $WM PROJECT USER DIR/applications
cd $WM PROJECT USER DIR/applications/foamUser
It is recommended to edit the Make/ﬁles ﬁle so that the foamUser library is compiled
locally into $FOAM USER LIBBIN as follows:
libfoamUser.C
LIB = $(FOAM USER LIBBIN)/libfoamUser
The new library should be added to the LIB LIBS in Make/options
LIB_LIBS = \
-l... \
-lnew
Finally, the library should be recompiled with:
wmake libso
Open∇FOAM-1.5
3.3 Running applications U-79
3.3 Running applications
Each application is designed to be executed from a terminal command line, typically
reading and writing a set of data ﬁles associated with a particular case. The data ﬁles
for a case are stored in a directory named after the case as described in section 4.1; the
directory name with full path is here given the generic name <caseDir>.
For any application, the form of the command line entry for any can be found by
simply entering the application name at the command line with the -help option, e.g.
typing
blockMesh -help
returns the usage
Usage: blockMesh [-region region name] [-case dir] [-blockTopology]
[-help] [-doc] [-srcDoc]
The arguments in square brackets, [ ], are optional ﬂags. If the application is exe-
cuted from within a case directory, it will operate on that case. Alternatively, the -case
<caseDir> option allows the case to be speciﬁed directly so that the application can be
executed from anywhere in the ﬁling system.
Like any UNIX/Linux executable, applications can be run as as a background process,
i.e. one which does not have to be completed before the user can give the shell additional
commands. If the user wished to run the blockMesh example as a background process
and output the case progress to a log ﬁle, they could enter:
blockMesh > log &
3.4 Running applications in parallel
This section describes how to run OpenFOAM in parallel on distributed processors. The
method of parallel computing used by OpenFOAM is known as domain decomposition, in
which the geometry and associated ﬁelds are broken into pieces and allocated to separate
processors for solution. The process of parallel computation involves: decomposition of
mesh and ﬁelds; running the application in parallel; and, post-processing the decomposed
case as described in the following sections. The parallel running uses the public domain
openMPI implementation of the standard message passing interface (MPI). OpenFOAM
can also be run using the MPICH implementation of MPI which is described in section B.1.
3.4.1 Decomposition of mesh and initial ﬁeld data
The mesh and ﬁelds are decomposed using the decomposePar utility. The underlying
aim is to break up the domain with minimal eﬀort but in such a way to guarantee a
fairly economic solution. The geometry and ﬁelds are broken up according to a set of
parameters speciﬁed in a dictionary named decomposeParDict that must be located in
the system directory of the case of interest. An example decomposeParDict dictionary can
be copied from the interFoam/damBreak tutorial if the user requires one; the dictionary
entries within it are reproduced below:
Open∇FOAM-1.5
U-80 Applications and libraries
17 numberOfSubdomains 4;
18
19 method simple;
20
21 simpleCoeffs
22 {
23 n (2 2 1);
24 delta 0.001;
25 }
26
27 hierarchicalCoeffs
28 {
29 n (1 1 1);
30 delta 0.001;
31 order xyz;
32 }
33
34 metisCoeffs
35 {
36 processorWeights
37 (
38 1
39 1
40 1
41 1
42 );
43 }
44
45 manualCoeffs
46 {
47 dataFile "";
48 }
49
50 distributed no;
51
52 roots
53 (
54 );
55
56 // ************************************************************************* //
The user has a choice of four methods of decomposition, speciﬁed by the method keyword
as described below.
simple Simple geometric decomposition in which the domain is split into pieces by di-
rection, e.g. 2 pieces in the x direction, 1 in y etc.
hierarchical Hierarchical geometric decomposition which is the same as simple except
the user speciﬁes the order in which the directional split is done, e.g. ﬁrst in the
y-direction, then the x-direction etc.
metis METIS decomposition which requires no geometric input from the user and at-
tempts to minimise the number of processor boundaries. The user can specify a
weighting for the decomposition between processors which can be useful on ma-
chines with diﬀering performance between processors.
manual Manual decomposition, where the user directly speciﬁes the allocation of each
cell to a particular processor.
For each method there are a set of coeﬃcients speciﬁed in a sub-dictionary of decom-
positionDict, named <method>Coeﬀs as shown in the dictionary listing. The full set of
keyword entries in the decomposeParDict dictionary are explained in Table 3.4.
The decomposePar utility is executed in the normal manner by typing
decomposePar
On completion, a set of subdirectories will have been created, one for each processor, in
the case directory. The directories are named processorN where N = 0, 1, . . . represents a
processor number and contains a time directory, containing the decomposed ﬁeld descrip-
tions, and a constant/polyMesh directory containing the decomposed mesh description.
Open∇FOAM-1.5
3.4 Running applications in parallel U-81
Compulsory entries
numberOfSubdomains Total number of subdomains N
method Method of decomposition simple/
hierarchical/
metis/ manual/
simpleCoeffs entries
n Number of subdomains in x, y, z (nx ny nz)
delta Cell skew factor Typically, 10−3
hierarchicalCoeffs entries
n Number of subdomains in x, y, z (nx ny nz)
delta Cell skew factor Typically, 10−3
order Order of decomposition xyz/xzy/yxz. . .
metisCoeffs entries
processorWeights List of weighting factors for allocation
of cells to processors; <wt1> is the
weighting factor for processor 1, etc.;
weights are normalised so can take any
range of values.
(<wt1>...<wtN>)
manualCoeffs entries
dataFile Name of ﬁle containing data of alloca-
tion of cells to processors
"<fileName>"
Distributed data entries (optional) — see section 3.4.3
distributed Is the data distributed across several
disks?
yes/no
roots Root paths to case directories; <rt1>
is the root path for node 1, etc.
(<rt1>...<rtN>)
Table 3.4: Keywords in decompositionDict dictionary.
3.4.2 Running a decomposed case
A decomposed OpenFOAM case is run in parallel using the openMPI implementation of
MPI (openMPI).
openMPI can be run on a local multiprocessor machine very simply but when run-
ning on machines across a network, a ﬁle must be created that contains the host names
of the machines. The ﬁle can be given any name and located at any path. In the fol-
lowing description we shall refer to such a ﬁle by the generic name, including full path,
<machines>.
The <machines> ﬁle contains the names of the machines listed one machine per line.
The names must correspond to a fully resolved hostname in the /etc/hosts ﬁle of the
machine on which the openMPI is run. The list must contain the name of the machine
running the openMPI. Where a machine node contains more than one processor, the node
name may be followed by the entry cpu=n where n is the number of processors openMPI
should run on that node.
For example, let us imagine a user wishes to run openMPI from machine aaa on the
Open∇FOAM-1.5
U-82 Applications and libraries
following machines: aaa; bbb, which has 2 processors; and ccc. The <machines> would
contain:
aaa
bbb cpu=2
ccc
An application is run in parallel using mpirun.
mpirun --hostfile <machines> -np <nProcs>
<foamExec> <otherArgs> -parallel > log
&
where: <nProcs> is the number of processors; <foamExec> is the executable, e.g.icoFoam;
and, the output is redirected to a ﬁle named log. For example, if icoFoam is run on 4
nodes, speciﬁed in a ﬁle named machines, on the cavity tutorial in the $FOAM RUN/tutorials/icoFoam
directory, then the following command should be executed:
mpirun --hostfile machines -np 4 icoFoam
$FOAM RUN/tutorials/icoFoam cavity -parallel > log &
3.4.3 Distributing data across several disks
Data ﬁles may need to be distributed if, for example, if only local disks are used in
order to improve performance. In this case, the user may ﬁnd that the root path to the
case directory may diﬀer between machines. The paths must then be speciﬁed in the
decomposeParDict dictionary using distributed and roots keywords. The distributed
entry should read
distributed yes;
and the roots entry is a list of root paths, <root0>, <root1>, . . . , for each node
roots
<nRoots>
(
"<root0>"
"<root1>"
...
);
where <nRoots> is the number of roots.
Each of the processorN directories should be placed in the case directory at each of
the root paths speciﬁed in the decomposeParDict dictionary. The system directory and
ﬁles within the constant directory must also be present in each case directory. Note: the
ﬁles in the constant directory are needed, but the polyMesh directory is not.
3.4.4 Post-processing parallel processed cases
When post-processing cases that have been run in parallel the user has two options:
• reconstruction of the mesh and ﬁeld data to recreate the complete domain and ﬁelds,
which can be post-processed as normal;
• post-processing each segment of decomposed domain individually.
Open∇FOAM-1.5
3.5 Standard solvers U-83
3.4.4.1 Reconstructing mesh and data
After a case has been run in parallel, it can be reconstructed for post-processing. The case
is reconstructed by merging the sets of time directories from each processorN directory into
a single set of time directories. The reconstructPar utility performs such a reconstruction
by executing the command:
reconstructPar
When the data is distributed across several disks, it must be ﬁrst copied to the local case
directory for reconstruction.
3.4.4.2 Post-processing decomposed cases
The user may post-process decomposed cases using the paraFoam post-processor, de-
scribed in section 6.1. The whole simulation can be post-processed by reconstructing the
case or alternatively it is possible to post-process a segment of the decomposed domain
individually by simply treating the individual processor directory as a case in its own
right.
3.5 Standard solvers
The solvers with the OpenFOAM distribution are in the $FOAM APP/solvers directory,
reached quickly by typing app at the command line. This directory is further subdivided
into several directories by category of continuum mechanics, e.g. incompressible ﬂow,
combustion and solid body stress analysis. Each solver is given a name that is reasonably
descriptive, e.g.icoFoam solves incompressible, laminar ﬂow, turbFoam solves incompress-
ible, turbulent ﬂow. The current list of solvers distributed with OpenFOAM is given in
Table 3.5.
‘Basic’ CFD codes
laplacianFoam Solves a simple Laplace equation, e.g. for thermal diﬀusion
in a solid
potentialFoam Simple potential ﬂow solver which can be used to generate
starting ﬁelds for full Navier-Stokes codes
scalarTransportFoam Solves a transport equation for a passive scalar
Incompressible ﬂow
boundaryFoam Steady-state solver for 1D turbulent ﬂow, typically to generate
boundary layer conditions at an inlet, for use in a simulation.
channelOodles Incompressible LES solver for ﬂow in a channel
icoDyMFoam Transient solver for incompressible, laminar ﬂow of Newtonian
ﬂuids with dynamic mesh
icoFoam Transient solver for incompressible, laminar ﬂow of Newtonian
ﬂuids
nonNewtonianIcoFoam Transient solver for incompressible, laminar ﬂow of non-
Newtonian ﬂuids
oodles Incompressible LES solver
simpleFoam Steady-state solver for incompressible, turbulent ﬂow of non-
Newtonian ﬂuids
Continued on next page
Open∇FOAM-1.5
U-84 Applications and libraries
Continued from previous page
turbDyMFoam Transient solver for incompressible, turbulent ﬂow of Newto-
nian ﬂuids with dynamic mesh
turbFoam Transient solver for incompressible, turbulent ﬂow
Compressible ﬂow
coodles Compressible LES solver
rhoCentralFoam Density-based compressible ﬂow solver based on central-
upwind schemes
rhoPimpleFoam Transient solver for turbulent ﬂow of compressible ﬂuids for
ventilation and heat-transfer
rhoPorousSimpleFoam Steady-state solver for turbulent ﬂow of compressible ﬂuids
with implicit or explicit porosity treatment
rhopSonicFoam Pressure-density-based compressible ﬂow solver
rhoSimpleFoam Steady-state solver for turbulent ﬂow of compressible ﬂuids
for ventilation and heat-transfer
rhoSonicFoam Density-based compressible ﬂow solver
rhoTurbFoam Transient solver for compressible, turbulent ﬂow
sonicFoam Transient solver for trans-sonic/supersonic, laminar ﬂow of a
compressible gas.
sonicFoamAutoMotion Transient solver for trans-sonic/supersonic, laminar ﬂow of a
compressible gas with mesh motion
sonicLiquidFoam Transient solver for trans-sonic/supersonic, laminar ﬂow of a
compressible liquid
sonicTurbFoam Transient solver for trans-sonic/supersonic, turbulent ﬂow of
a compressible gas
Multiphase ﬂow
bubbleFoam Solver for a system of 2 incompressible ﬂuid phases with one
phase dispersed, e.g. gas bubbles in a liquid
compressibleLes-
InterFoam
Solver for 2 compressible, isothermal immiscible ﬂuids using
a volume of ﬂuid (VOF) phase-fraction based interface cap-
turing approach, with LES
interDyMFoam Solver for 2 incompressible ﬂuids, which captures the interface
using a VOF method with optional mesh motion
interFoam Solver for 2 incompressible ﬂuids, which captures the interface
using a VOF method
interPhaseChangeFoam Solver for 2 incompressible, isothermal immiscible ﬂuids with
phase-change, e.g. cavitation, using a VOF method
lesCavitatingFoam Transient cavitation code with LES turbulence
lesInterFoam Solver for 2 incompressible ﬂuids capturing the interface. Tur-
bulence is modelled using a runtime selectable incompressible
LES model
multiphaseInterFoam Solver for an arbitrary number of incompressible immiscible
ﬂuids, capturing the multiple interfaces using a VOF method
rasCavitatingFoam Transient cavitation code with RAS turbulence
rasInterFoam Solver for 2 incompressible ﬂuids capturing the interface. Tur-
bulence is modelled using a runtime selectable incompressible
RAS model
Continued on next page
Open∇FOAM-1.5
3.5 Standard solvers U-85
Continued from previous page
settlingFoam Solver for 2 incompressible ﬂuids for simulating the settling
of the dispersed phase
twoLiquidMixingFoam Solver for mixing 2 incompressible ﬂuids
twoPhaseEulerFoam Solver for a system of 2 incompressible ﬂuid phases with one
phase dispersed, e.g. gas bubbles in a liquid
Direct numerical simulation (DNS)
dnsFoam Direct numerical simulation solver for boxes of isotropic tur-
bulence
Combustion
coldEngineFoam Solver for cold-ﬂow in internal combustion engines
dieselEngineFoam Diesel engine spray and combustion code
dieselFoam Diesel spray and combustion code
engineFoam Solver for internal combustion engines
PDRFoam compressible premixed/partially-premixed turbulent com-
bustion solver that includes porosity/distributed resistance
(PDR) modelling to handle regions containing solid blockages
that cannot be resolved by the mesh
reactingFoam Chemical reaction code
XiFoam Compressible premixed/partially-premixed combustion solver
with turbulence modelling
Xoodles Compressible premixed/partially-premixed combustion solver
with large-eddy simulation (LES) turbulence modelling
Heat transfer
buoyantFoam Transient Solver for buoyant, turbulent ﬂow of compressible
ﬂuids for ventilation and heat-transfer
buoyantSimpleFoam Steady-state solver for buoyant, turbulent ﬂow of compressible
ﬂuids for ventilation and heat-transfer
buoyantSimple-
RadiationFoam
Steady-state solver for buoyant, turbulent ﬂow of compressible
ﬂuids with radiation, for ventilation and heat-transfer
chtMultiRegionFoam Solver that couples conjugate heat transfer in a solid to a
buoyancy-driven ﬂow simulation
lesBuoyantFoam Transient solver for buoyant, turbulent ﬂow of compressible
ﬂuids for ventilation and heat-transfer with LES turbulence
modelling
Electromagnetics
electrostaticFoam Solver for electrostatics
mhdFoam Solver for magnetohydrodynamics (MHD): incompressible,
laminar ﬂow of a conducting ﬂuid under the inﬂuence of a
magnetic ﬁeld
Stress analysis of solids
solidDisplacementFoam Transient segregated ﬁnite-volume solver of linear-elastic,
small-strain deformation of a solid body, with optional ther-
mal diﬀusion and thermal stresses
Continued on next page
Open∇FOAM-1.5
U-86 Applications and libraries
Continued from previous page
solidEquilibrium-
DisplacementFoam
Steady-state segregated ﬁnite-volume solver of linear-elastic,
small-strain deformation of a solid body
Molecular dynamics
gnemdFoam General purpose molecular dynamics solver to simulate atoms
in arbitrary shaped domains and average atomic/molecular
quantities to the mesh to create ﬁeld data
mdEquilibrationFoam Solver that equilibrates and/or preconditions molecular dy-
namics systems
Finance
ﬁnancialFoam Solves the Black-Scholes equation to price commodities
Table 3.5: Standard library solvers.
3.6 Standard utilities
The utilities with the OpenFOAM distribution are in the $FOAM APP/utilities directory,
reached quickly by typing util at the command line. Again the names are reasonably
descriptive, e.g.magU calculates the magnitude of velocity from velocity ﬁeld data, ideasT-
oFoam converts mesh data from the format written by I-DEAS to the OpenFOAM format.
The current list of utilities distributed with OpenFOAM is given in Table 3.6.
Pre-processing
boxTurb Makes a box of turbulence which conforms to a given energy
spectrum and is divergence free
engineSwirl Generates a swirling ﬂow for engine calulations
FoamX (Description not found)
mapFields Maps volume ﬁelds from one mesh to another, reading and
interpolating all ﬁelds present in the time directory of both
cases. Parallel and non-parallel cases are handled without the
need to reconstruct them ﬁrst
setFields Selects a cell set through a dictionary
Mesh generation — see section 5.3
blockMesh Mesh generator: blockOﬀsets (createBlockOﬀsets()),
mergeList (createMergeList()), points (createPoints()),
cells (createCells()), patches (createPatches())
extrudeMesh Extrude mesh from existing patch or from patch read from
ﬁle
Mesh conversion — see section 5.5
ansysToFoam Converts an ANSYS input mesh ﬁle, exported from I-DEAS,
to OpenFOAM format
ccm26ToFoam CCM mesh converter using CCM version 2.6 library
cfxToFoam Converts a CFX mesh to OpenFOAM format
Continued on next page
Open∇FOAM-1.5
3.6 Standard utilities U-87
Continued from previous page
ﬂuentMeshToFoam Converts a Fluent mesh to OpenFOAM format including mul-
tiple region and region boundary handling
foamMeshToFluent Writes out the OpenFOAM mesh in Fluent mesh format
gambitToFoam Converts a GAMBIT mesh to OpenFOAM format
gmshToFoam Reads .msh ﬁle as written by Gmsh
ideasUnvToFoam Converts meshes from I-DEAS .unv format to OpenFOAM
format
kivaToFoam Converts a KIVA3v grid to OpenFOAM format
mshToFoam Reads .msh format generated by the Adventure system
netgenNeutralToFoam read Neutral ﬁle format as written by Netgen4.4
plot3dToFoam Plot3d mesh (ascii format) converter
polyDualMesh (Currently no description)
sammToFoam Converts a STAR-CDSAMM mesh to OpenFOAM format
starToFoam Converts a STAR-CDPROSTAR mesh into OpenFOAM format
tetgenToFoam Reads .ele and .node and .face ﬁles as written by tetgen
writeMeshObj For mesh debugging: writes mesh as three separate OBJ ﬁles
which can be viewed with e.g. javaview
Mesh manipulation
attachMesh Attach topologically detached mesh using prescribed mesh
modiﬁers
autoPatch Divides external faces into patches based on (user supplied)
feature angle
cellSet Selects a cell set through a dictionary
checkMesh Checks validity of a mesh
couplePatches Utility to reorder cyclic and processor patches
createPatch Utility to create patches out of selected boundary faces. Faces
come either from existing patches or from a faceSet
deformedGeom Deforms a polyMesh using a displacement ﬁeld U and a scaling
factor supplied as an argument
faceSet Selects a face set through a dictionary
ﬂattenMesh Flatten the front and back planes of a 2D Cartesian mesh
insideCells Pick up cells with cell centre ‘inside’ of surface. Requires
surface to be closed and singly connected
mergeMeshes Merge two meshes
mirrorMesh (Currently no description)
moveDynamicMesh Mesh motion and topological mesh changes utility
moveEngineMesh Solver for moving meshes for engine calculations.
moveMesh Solver for moving meshes
objToVTK Read obj line (not surface!) ﬁle and convert into vtk
patchTool (Description not found)
pointSet Selects a point set through a dictionary
reﬁneMesh Utility to reﬁne cells in multiple directions. Either supply -all
option to reﬁne all cells (3D reﬁnement for 3D cases; 2D for
2D cases) or reads a reﬁneMeshDict with - cellSet to reﬁne -
directions to reﬁne
renumberMesh Renumbers the cell list in order to reduce the bandwidth,
reading and renumbering all ﬁelds from all the time directories
Continued on next page
Open∇FOAM-1.5
U-88 Applications and libraries
Continued from previous page
rotateMesh Rotates the mesh and ﬁelds from the direction n1 to the di-
rection n2
splitMesh Splits mesh by making internal faces external. Uses attachDe-
tach
splitMeshRegions Splits mesh into multiple regions and writes them to consec-
utive time directories. Each region is deﬁned as a domain
whose cells can all be reached by cell-face-cell walking. Uses
meshWave. Could work in parallel but never tested
stitchMesh ‘Stitches’ a mesh
subsetMesh Selects a section of mesh based on a cellSet
tetDecomposition Takes a mesh and decomposes it into tetrahedra using a face-
cell centre decomposition
transformPoints Transforms the mesh points in the polyMesh directory accord-
ing to the options:
zipUpMesh Reads in a mesh with hanging vertices and zips up the cells
to guarantee that all polyhedral cells of valid shape are closed
Post-processing graphics — see chapter 6
ensight76FoamExec Module for EnSight 7.6 to read OpenFOAM data directly
without translation
paraFoam (Description not found)
Post-processing data converters — see chapter 6
foamDataToFluent Translates OpenFOAM data to Fluent format
foamToEnsight Translates OpenFOAM data to EnSight format
foamToFieldview9 Write out the OpenFOAM mesh in Version 3.0 Fieldview-UNS
format (binary). See Fieldview Release 9 Reference Manual
- Appendix D (Unstructured Data Format) Borrows various
from uns/write binary uns.c from FieldView dist
foamToGMV Translates foam output to GMV readable ﬁles. A free
post-processor with available binaries from http://www-
xdiv.lanl.gov/XCM/gmv/
foamToVTK legacy VTK ﬁle format writer. - handles volScalar, volVec-
tor, pointScalar, pointVector, surfaceScalar ﬁelds. - mesh topo
changes. - both ascii and binary. - single time step writ-
ing. - write subset only. - automatic decomposition of cells;
polygons on boundary undecomposed since handled by vtk
smapToFoam Translates a STAR-CD SMAP data ﬁle into OpenFOAM ﬁeld
format
Post-processing velocity ﬁelds
Co Conﬁgurable graph drawing program
divU Calculates and writes the divergence of velocity ﬁeld U at each
time
enstrophy Calculates and writes the enstrophy of velocity ﬁeld U at each
time
ﬂowType Calculates and writes the ﬂowType of velocity ﬁeld U at each
time
Continued on next page
Open∇FOAM-1.5
3.6 Standard utilities U-89
Continued from previous page
Lambda2 Calculates and writes the second largest eigenvalue of the sum
of the square of the symmetrical and anti-symmetrical parts
of the velocity gradient tensor, for each time
Mach Calculates and writes the local Mach number from the velocity
ﬁeld U at each time
magGradU Calculates and writes the scalar magnitude of velocity ﬁeld U
at each time
magU Calculates and writes the scalar magnitude of the gradient of
the velocity ﬁeld U for each time
Pe Calculates and writes the Pe number as a surfaceScalarField
obtained from ﬁeld phi for each time
Q Calculates and writes the second invariant of the velocity gra-
dient tensor for each time
streamFunction Calculates and writes the stream function of velocity ﬁeld U
at each time
Ucomponents Writes the three scalar ﬁelds, Ux, Uy and Uz, for each compo-
nent of the velocity ﬁeld U for each time
uprime Calculates and writes the scalar ﬁeld of uprime ( 2
3
k) at each
time
vorticity Calculates and writes the vorticity of velocity ﬁeld U at each
time
Post-processing stress ﬁelds
R Calculates and writes the Reynolds stress R for the current
time step
Rcomponents Calculates and writes the scalar ﬁelds of the six components
of the Reynolds stress R for each time
stressComponents Calculates and writes the scalar ﬁelds of the six components
of the stress tensor sigma for each time
Post-processing at walls
checkYPlus Calculates and reports yPlus for all wall patches, for each
time in a database
wallGradU Calculates and writes the gradient of U at the wall
wallHeatFlux Calculates and writes the heat ﬂux for all patches as the
boundary ﬁeld of a volScalarField and also prints the inte-
grated ﬂux for all wall patches
wallShearStress Calculates and writes the wall shear stress for the current time
step
yPlusLES Calculates the yPlus of the near-wall cells for an LES
Post-processing at patches
patchAverage Calculate average of ﬁelds over all patches
patchIntegrate Integrates ﬁelds over all patches
Miscellaneous post-processing
Continued on next page
Open∇FOAM-1.5
U-90 Applications and libraries
Continued from previous page
engineCompRatio Calculate the geometric compression ratio. Note that if you
have valves and/or extra volumes it will not work, since it
calculates the volume at BDC and TCD
postChannel Post-processes data from channel ﬂow calculations
ptot For each time: calculate the total pressure
sample Sample ﬁeld data with a choice of interpolation schemes, sam-
pling options and write formats
sampleSurface Surface sampling. Runs in parallel (but does not merge
points)
wdot Calculates and writes wdot for each time
writeCellCentres Write the three components of the cell centres as
volScalarFields so they can be used in postprocessing in
thresholding
Parallel processing — see section 3.4
decomposePar Automatically decomposes a mesh and ﬁelds of a case for
parallel execution of OpenFOAM
reconstructPar Reconstructs a mesh and ﬁelds of a case that is decomposed
for parallel execution of OpenFOAM
reconstructParMesh Reconstructs a mesh using geometric information only. Writes
point/face/cell procAddressing so afterwards reconstructPar
can be used to reconstruct ﬁelds
Thermophysical-related utilities
adiabaticFlameT Calculates the adiabatic ﬂame temperature for a given fuel
over a range of unburnt temperatures and equivalence ratios
chemkinToFoam Converts CHEMKIN 3 thermodynamics and reaction data ﬁles
into OpenFOAM format
equilibriumCO Calculates the equilibrium level of carbon monoxide
equilibriumFlameT Calculates the equilibrium ﬂame temperature for a given fuel
and pressure for a range of unburnt gas temperatures and
equivalence ratios; the eﬀects of dissociation on O2, H2O and
CO2 are included
mixtureAdiabaticFlameT Calculates the adiabatic ﬂame temperature for a given mix-
ture at a given temperature
Error estimation
estimateScalarError Estimates the error in the solution for a scalar transport equa-
tion in the standard form
icoErrorEstimate Estimates error for the incompressible laminar CFD applica-
tion icoFoam
icoMomentError Estimates error for the incompressible laminar CFD applica-
tion icoFoam
momentScalarError Estimates the error in the solution for a scalar transport equa-
tion in the standard form
Miscellaneous utilities
foamDebugSwitches Write out all library debug switches
foamInfoExec Interrogates a case and prints information to screen
Continued on next page
Open∇FOAM-1.5
3.7 Standard libraries U-91
Continued from previous page
Table 3.6: Standard library utilities.
3.7 Standard libraries
The libraries with the OpenFOAM distribution are in the $FOAM LIB/$WM OPTIONS
directory, reached quickly by typing lib at the command line. Again, the names are
preﬁxed by lib and reasonably descriptive, e.g.incompressibleTransportModels contains
the library of incompressible transport models. For ease of presentation, the libraries are
separated into two types:
General libraries those that provide general classes and associated functions listed in
Table 3.7;
Model libraries those that specify models used in computational continuum mechanics,
listed in Table 3.8, Table 3.9 and Table 3.10.
Library of basic OpenFOAM tools — OpenFOAM
algorithms Algorithms
containers Container classes
db Database classes
dimensionSet dimensionSet class
dimensionedTypes dimensioned<Type> class and derivatives
ﬁelds Field classes
ﬁniteVolume Finite volume discretisation classes
global Global settings
interpolations Interpolation schemes
matrices Matrix classes
meshes Mesh classes
primitives Primitive classes
Library of CFD tools — cfdTools
adjustPhi Adjusts boundary ﬂuxes
bound Bounds scalar ﬁelds
compressible Compressible ﬂow CFD tools
incompressible Incompressible ﬂow CFD tools
wallDist Calculations relating to wall boundaries
Post-processing libraries
incompressiblePostProcessingTools for post-processing incompressible ﬂow data
sampling Tools for sampling ﬁeld data at prescribed locations in a do-
main
Solution and mesh manipulation libraries
cellDecompFiniteElement Cell decomposed ﬁnite element scheme
dynamicMesh For solving systems with moving meshes
Continued on next page
Open∇FOAM-1.5
U-92 Applications and libraries
Continued from previous page
edgeMesh For handling edge-based mesh descriptions
errorEstimation Error estimation tools
faceDecompFiniteElementFace decomposed ﬁnite element scheme
ODE Solvers for ordinary diﬀerential equations
shapeMeshTools Tools for handling a mesh whose cells are deﬁned by a set of
standard shapes
meshTools Tools for handling a OpenFOAM mesh
triSurface For handling standard triangulated surface-based mesh de-
scriptions
Lagrangian particle tracking libraries
dieselSpray Diesel spray tracking solution scheme
lagrangian Basic Lagrangian, or particle-tracking, solution scheme
Public domain libraries
mico-2.3.13 Implementation of the Common Object Request Broker Ar-
chitecture (CORBA)
mpich-1.2.4 Portable message-passing interface for parallel processing
openmpi-1.2.6 Portable message-passing interface for parallel processing
zlib-1.2.3 General purpose data compression
Miscellaneous libraries
engine Tools for engine calculations
Gstream 2D graphics stream
randomProcesses Tools for analysing and generating random processes
Table 3.7: Shared object libraries for general use.
Basic thermophysical models — basicThermophysicalModels
hThermo General thermophysical model calculation based on en-
thalpy h
pureMixture General thermophysical model calculation for passive gas
mixtures
Combustion models — combustionThermophysicalModels
hMixtureThermo Calculates enthalpy for combustion mixture
hhuMixtureThermo Calculates enthalpy for unburnt gas and combustion mix-
ture
homogeneousMixture Combustion mixture based on normalised fuel mass frac-
tion b
inhomogeneousMixture Combustion mixture based on b and total fuel mass fraction
ft
veryInhomogeneousMixture Combustion mixture based on b, ft and unburnt fuel mass
fraction fu
dieselMixture Combustion mixture based on ft and fu
Continued on next page
Open∇FOAM-1.5
3.7 Standard libraries U-93
Continued from previous page
multiComponentMixture Combustion mixture based on multiple components [**]
chemkinMixture Combustion mixture using CHEMKIN thermodynamics and
reaction schemes database ﬁles
Laminar ﬂame speed models — laminarFlameSpeedModels
constLaminarFlameSpeed Constant laminar ﬂame speed
guldersLaminarFlameSpeed G¨ulder’s laminar ﬂame speed model
Thermophysical properties of liquids — liquids
nHeptane Thermophysical properties of nHeptane
nOctane Thermophysical properties of nOctane
nDecane Thermophysical properties of nDecane
nDodecane Thermophysical properties of nDodecane
isoOctane Thermophysical properties of isoOctane
diMethylEther Thermophysical properties of diMethylEther
diEthylEther Thermophysical properties of diEthylEther
water Thermophysical properties of water
Thermophysical properties of gaseous species — specie
perfectGas Perfect gas equation of state
hConstThermo Constant speciﬁc heat cp model with evaluation of enthalpy
h and entropy s
janafThermo cp evaluated by a function with coeﬃcients from JANAF
thermodynamic tables, from which h, s are evaluated
specieThermo Thermophysical properties of species, derived from cp, h
and/or s
constTransport Constant transport properties
sutherlandTransport Sutherland’s formula for temperature-dependent transport
properties
Functions/tables of thermophysical properties — thermophysicalFunctions
NSRDSfunctions National Standard Reference Data System (NSRDS) -
American Institute of Chemical Engineers (AICHE) data
compilation tables
APIfunctions American Petroleum Institute (API) function for vapour
mass diﬀusivity
Probability density functions — pdf
RosinRammler Rosin-Rammler distribution
normal Normal distribution
uniform Uniform distribution
exponential Exponential distribution
general General distribution
Chemistry model — chemistryModel
chemistryModel Chemical reaction model
chemistrySolver Chemical reaction solver
Continued on next page
Open∇FOAM-1.5
U-94 Applications and libraries
Continued from previous page
Table 3.8: Libraries of thermophysical models.
RAS turbulence models for incompressible ﬂuids — incompressibleRASModels
laminar Dummy turbulence model for laminar ﬂow
kEpsilon Standard k − ε model with wall functions
RNGkEpsilon RNG k − ε model with wall functions
NonlinearKEShih Non-linear Shih k − ε model with wall functions
LienCubicKE Lien cubic k − ε model with wall functions
QZeta q − ζ model
LaunderSharmaKE Launder-Sharma low-Re k − ε model
LamBremhorstKE Lam-Bremhorst low-Re k − ε model
LienCubicKELowRE Lien cubic low-Re k − ε model
LienLeschzinerLowRE Lien-Leschziner low-Re k − ε model
LRR Launder-Reece-Rodi RSTM with wall functions
LaunderGibsonRSTM Launder-Gibson RSTM with wall-reﬂection terms and wall
functions
SpalartAllmaras Spalart-Allmaras 1-eqn mixing-length model for external
ﬂows
RAS turbulence models for compressible ﬂuids — compressibleRASModels
laminar Dummy turbulence model for laminar ﬂow
kEpsilon Standard k − ε model with wall functions
RNGkEpsilon RNG k − ε model with wall functions
LaunderSharmaKE Launder-Sharma low-Re k − ε model
LRR Launder-Reece-Rodi RSTM with wall functions
LaunderGibsonRSTM Launder-Gibson RSTM with wall-reﬂection terms and wall
functions
Large-eddy simulation (LES) ﬁlters — LESﬁlters
laplaceFilter Laplace ﬁlters
simpleFilter Simple ﬁlter
anisotropicFilter Anisotropic ﬁlter
Large-eddy simulation deltas — LESdeltas
PrandtlDelta Prandtl delta
cubeRootVolDelta Cube root of cell volume delta
smoothDelta Smoothing of delta
Incompressible LES turbulence models — incompressibleLESModels
Smagorinsky Smagorinsky model
Smagorinsky2 Smagorinsky model with 3-D ﬁlter
dynSmagorinsky Dynamic Smagorinsky
scaleSimilarity Scale similarity model
mixedSmagorinsky Mixed Smagorinsky/scale similarity model
dynMixedSmagorinsky Dynamic mixed Smagorinsky/scale similarity model
oneEqEddy k-equation eddy-viscosity model
dynOneEqEddy Dynamic k-equation eddy-viscosity model
locDynOneEqEddy Localised dynamic k-equation eddy-viscosity model
Continued on next page
Open∇FOAM-1.5
3.7 Standard libraries U-95
Continued from previous page
spectEddyVisc Spectral eddy viscosity model
LRDDiﬀStress LRR diﬀerential stress model
DeardorﬀDiﬀStress Deardorﬀ diﬀerential stress model
SpalartAllmaras Spalart-Allmaras model
Compressible LES turbulence models — compressibleLESModels
Smagorinsky Smagorinsky model
oneEqEddy k-equation eddy-viscosity model
dynOneEqEddy Dynamic k-equation eddy-viscosity model
lowReOneEqEddy Low-Re k-equation eddy-viscosity model
DeardorﬀDiﬀStress Deardorﬀ diﬀerential stress model
Table 3.9: Libraries of RAS and LES turbulence models.
Transport models for incompressible ﬂuids — incompressibleTransportModels
Newtonian Linear viscous ﬂuid model
CrossPowerLaw Cross Power law nonlinear viscous model
BirdCarreau Bird-Carreau nonlinear viscous model
Table 3.10: Shared object libraries of transport models.
Open∇FOAM-1.5
U-96 Applications and libraries
Open∇FOAM-1.5
Chapter 4
OpenFOAM cases
This chapter deals with the ﬁle structure and organisation of OpenFOAM cases. Nor-
mally, a user would assign a name to a case, e.g. the tutorial case of ﬂow in a cav-
ity is simply named cavity. This name becomes the name of a directory in which all
the case ﬁles and subdirectories are stored. The case directories themselves can be
located anywhere but we recommend they are within a run subdirectory of the user’s
project directory, i.e.$HOME/OpenFOAM/${USER}-1.5 as described at the beginning of
chapter 2. One advantage of this is that the $FOAM RUN environment variable is set
to $HOME/OpenFOAM/${USER}-1.5/run by default; the user can quickly move to that
directory by executing a preset alias, run, at the command line.
The tutorial cases that accompany the OpenFOAM distribution provide useful exam-
ples of the case directory structures. The tutorials are located in the $FOAM TUTORIALS
directory, reached quickly by executing the tut alias at the command line. Users can view
tutorial examples at their leisure while reading this chapter.
4.1 File structure of OpenFOAM cases
The basic directory structure for a OpenFOAM case, that contains the minimum set of
ﬁles required to run an application, is shown in Figure 4.1 and described as follows:
<case>
system
controlDict
fvSchemes
polyMesh
points
cells
faces
. . . Properties
boundary
constant
time directories
fvSolution
see section 4.3
see section 4.4
see section 4.5
see section 5.1.2
see section 4.2.8
see chapter 7
Figure 4.1: Case directory structure
U-98 OpenFOAM cases
A constant directory that contains a full description of the case mesh in a subdirec-
tory polyMesh and ﬁles specifying physical properties for the application concerned,
e.g.transportProperties.
A system directory for setting parameters associated with the solution procedure itself.
It contains at least the following 3 ﬁles: controlDict where run control parameters are
set including start/end time, time step and parameters for data output; fvSchemes
where discretisation schemes used in the solution may be selected at run-time; and,
fvSolution where the equation solvers, tolerances and other algorithm controls are
set for the run.
The ‘time’ directories containing individual ﬁles of data for particular ﬁelds. The
data can be: either, initial values and boundary conditions that the user must
specify to deﬁne the problem; or, results written to ﬁle by OpenFOAM. Note that
the OpenFOAM ﬁelds must always be initialised, even when the solution does not
strictly require it, as in steady-state problems. The name of each time directory is
based on the simulated time at which the data is written and is described fully in
section 4.3. It is suﬃcient to say now that since we usually start our simulations
at time t = 0, the initial conditions are usually stored in a directory named 0 or
0.000000e+00, depending on the name format speciﬁed. For example, in the cavity
tutorial, the velocity ﬁeld U and pressure ﬁeld p are initialised from ﬁles 0/U and
0/p respectively.
4.2 Basic input/output ﬁle format
OpenFOAM needs to read a range of data structures such as strings, scalars, vectors,
tensors, lists and ﬁelds. The input/output (I/O) format of ﬁles is designed to be extremely
ﬂexible to enable the user to modify the I/O in OpenFOAM applications as easily as
possible. The I/O follows a simple set of rules that make the ﬁles extremely easy to
understand, in contrast to many software packages whose ﬁle format may not only be
diﬃcult to understand intuitively but also not be published anywhere. The description
of the OpenFOAM ﬁle format is described in the following sections.
4.2.1 General syntax rules
The format follows the following some general principles of C++ source code.
• Files have free form, with no particular meaning assigned to any column and no
need to indicate continuation across lines.
• Lines have no particular meaning except to a // comment delimiter which makes
OpenFOAM ignore any text that follows it until the end of line.
• A comment over multiple lines is done by enclosing the text between /* and */
delimiters.
4.2.2 Dictionaries
OpenFOAM uses dictionaries as the most common means of specifying data. A dictionary
is an entity that contains as set data entries that can be retrieved by the I/O by means
of keywords. The keyword entries follow the general format
Open∇FOAM-1.5
4.2 Basic input/output ﬁle format U-99
<keyword> <dataEntry1> ... <dataEntryN>;
Most entries are single data entries of the form:
<keyword> <dataEntry>;
Most OpenFOAM data ﬁles are themselves dictionaries containing a set of keyword en-
tries. Dictionaries provide the means for organising entries into logical categories and can
be speciﬁed hierarchically so that any dictionary can itself contain one or more dictionary
entries. The format for a dictionary is to specify the dictionary name followed the the
entries enclosed in curly braces {} as follows
<dictionaryName>
{
... keyword entries ...
}
4.2.3 The data ﬁle header
All data ﬁles that are read and written by OpenFOAM begin with a dictionary named
FoamFile containing a standard set of keyword entries, listed in Table 4.1. The table
Keyword Description Entry
version I/O format version 2.0
format Data format ascii / binary
location Path to the ﬁle, in "..." (optional)
class OpenFOAM class constructed from the
data ﬁle concerned
typically dictionary or a
ﬁeld, e.g.volVectorField
object Filename e.g.controlDict
Table 4.1: Header keywords entries for data ﬁles.
provides brief descriptions of each entry, which is probably suﬃcient for most entries with
the notable exception of class. The class entry is the name of the C++ class in the
OpenFOAM library that will be constructed from the data in the ﬁle. Without knowledge
of the underlying code which calls the ﬁle to be read, and knowledge of the OpenFOAM
classes, the user will probably be unable to surmise the class entry correctly. However,
most data ﬁles with simple keyword entries are read into an internal dictionary class and
therefore the class entry is dictionary in those cases.
The following example shows the use of keywords to provide data for a case using the
types of entry described so far. The extract, from an fvSolution dictionary ﬁle, contains
2 dictionaries, solvers and PISO. The solvers dictionary contains multiple data entries for
solver and tolerances for each of the pressure and velocity equations, represented by the
p and U keywords respectively; the PISO dictionary contains algorithm controls.
17 solvers
18 {
19 p PCG
20 {
21 preconditioner DIC;
22 tolerance 1e-06;
23 relTol 0;
Open∇FOAM-1.5
U-100 OpenFOAM cases
24 };
25
26 U PBiCG
27 {
28 preconditioner DILU;
29 tolerance 1e-05;
30 relTol 0;
31 };
32 }
33
34 PISO
35 {
36 nCorrectors 2;
37 nNonOrthogonalCorrectors 0;
38 pRefCell 0;
39 pRefValue 0;
40 }
41
42 // ************************************************************************* //
4.2.4 Lists
OpenFOAM applications contain lists, e.g. a list of vertex coordinates for a mesh de-
scription. Lists are commonly found in I/O and have a format of their own in which the
entries are contained within round braces ( ). There is also a choice of format preceeding
the round braces:
simple the keyword is followed immediately by round braces
<listName>
(
... entries ...
);
numbered the keyword is followed by the number of elements <n> in the list
<listName>
<n>
(
... entries ...
);
token identiﬁer the keyword is followed by a class name identiﬁer Label<Type> where
<Type> states what the list contains, e.g. for a list of scalar elements is
<listName>
List<scalar>
<n> // optional
(
... entries ...
);
Note that <scalar> in List<scalar> is not a generic name but the actual text that
should be entered.
The simple format is a convenient way of writing a list. The other formats allow
the code to read the data faster since the size of the list can be allocated to memory
in advance of reading the data. The simple format is therefore preferred for short lists,
where read time is minimal, and the other formats are preferred for long lists.
Open∇FOAM-1.5
4.2 Basic input/output ﬁle format U-101
4.2.5 Scalars, vectors and tensors
A scalar is a single number represented as such in a data ﬁle. A vector is a VectorSpace
of rank 1 and dimension 3, and since the number of elements is always ﬁxed to 3, the
simple List format is used. Therefore a vector (1.0, 1.1, 1.2) is written:
(1.0 1.1 1.2)
In OpenFOAM, a tensor is a VectorSpace of rank 2 and dimension 3 and therefore the
data entries are always ﬁxed to 9 real numbers. Therefore the identity tensor, described
in section 1.3.7 of the Programmer’s Guide, can be written:
(
1 0 0
0 1 0
0 0 1
)
This example demonstrates the way in which OpenFOAM ignores the line return is so
that the entry can be written over multiple lines. It is treated no diﬀerently to listing the
numbers on a single line:
( 1 0 0 0 1 0 0 0 1 )
4.2.6 Dimensional units
In continuum mechanics, properties are represented in some chosen units, e.g. mass in
kilograms (kg), volume in cubic metres (m3
), pressure in Pascals (kg m s−2
). Algebraic
operations must be performed on these properties using consistent units of measurement;
in particular, addition, subtraction and equality are only physically meaningful for prop-
erties of the same dimensional units. As a safeguard against implementing a meaningless
operation, OpenFOAM attaches dimensions to ﬁeld data and physical properties and
performs dimension checking on any tensor operation.
The I/O format for a dimensionSet is 7 scalars delimited by square brackets, e.g.
[0 2 -1 0 0 0 0]
No. Property SI unit USCS unit
1 Mass kilogram (kg) pound-mass (lbm)
2 Length metre (m) foot (ft)
3 Time — — — — second (s) — — — —
4 Temperature Kelvin (K) degree Rankine (◦
R)
5 Quantity kilogram-mole (kgmol) pound-mole (lbmol)
6 Current — — — — ampere (A) — — — —
7 Luminous intensity — — — — candela (cd) — — — —
Table 4.2: Base units for SI and USCS
where each of the values corresponds to the power of each of the base units of measure-
ment listed in Table 4.2. The table gives the base units for the Syst`eme International
(SI) and the United States Customary System (USCS) but OpenFOAM can be used
Open∇FOAM-1.5
U-102 OpenFOAM cases
with any system of units. All that is required is that the input data is correct for the
chosen set of units. It is particularly important to recognise that OpenFOAM requires
some dimensioned physical constants, e.g. the Universal Gas Constant R, for certain cal-
culations, e.g. thermophysical modelling. These dimensioned constants are speciﬁed in
a DimensionedConstant sub-dictionary of main controlDict ﬁle of the OpenFOAM instal-
lation ($WM PROJECT DIR/etc/controlDict). By default these constants are set in SI
units. Those wishing to use the USCS or any other system of units should modify these
constants to their chosen set of units accordingly.
4.2.7 Dimensioned types
Physical properties are typically speciﬁed with their associated dimensions. These entries
have the format that the following example of a dimensionedScalar demonstrates:
nu nu [0 2 -1 0 0 0 0] 1;
The ﬁrst nu is the keyword; the second nu is the word name stored in class word, usually
chosen to be the same as the keyword; the next entry is the dimensionSet and the ﬁnal
entry is the scalar value.
4.2.8 Fields
Much of the I/O data in OpenFOAM are tensor ﬁelds, e.g. velocity, pressure data, that
are read from and written into the time directories. OpenFOAM writes ﬁeld data using
keyword entries as described in Table 4.3.
Keyword Description Example
dimensions Dimensions of ﬁeld [1 1 -2 0 0 0 0]
internalField Value of internal ﬁeld uniform (1 0 0)
boundaryField Boundary ﬁeld see ﬁle listing in section 4.2.8
Table 4.3: Main keywords used in ﬁeld dictionaries.
The data begins with an entry for its dimensions. Following that, is the internalField,
described in one of the following ways.
Uniform ﬁeld a single value is assigned to all elements within the ﬁeld, taking the form:
internalField uniform <entry>;
Nonuniform ﬁeld each ﬁeld element is assigned a unique value from a list, taking the
following form where the token identiﬁer form of list is recommended:
internalField nonuniform <List>;
The boundaryField is a dictionary containing a set of entries whose names correspond
to each of the names of the boundary patches listed in the boundary ﬁle in the polyMesh
directory. Each patch entry is itself a dictionary containing a list of keyword entries.
The compulsory entry, type, describes the patch ﬁeld condition speciﬁed for the ﬁeld.
The remaining entries correspond to the type of patch ﬁeld condition selected and can
Open∇FOAM-1.5
4.2 Basic input/output ﬁle format U-103
typically include ﬁeld data specifying initial conditions on patch faces. A selection of
patch ﬁeld conditions available in OpenFOAM are listed in Table 5.3 and Table 5.4 with
a description and the data that must be speciﬁed with it. Example ﬁeld dictionary entries
for velocity U are shown below:
17 dimensions [0 1 -1 0 0 0 0];
18
19 internalField uniform (0 0 0);
20
21 boundaryField
22 {
23 movingWall
24 {
25 type fixedValue;
26 value uniform (1 0 0);
27 }
28
29 fixedWalls
30 {
31 type fixedValue;
32 value uniform (0 0 0);
33 }
34
35 frontAndBack
36 {
37 type empty;
38 }
39 }
40
41 // ************************************************************************* //
4.2.9 Directives and macro substitutions
There is additional ﬁle syntax that oﬀers great ﬂexibility for the setting up of OpenFOAM
case ﬁles, namely directives and macro substitutions. Directives are commands that can
be contained within case ﬁles that begin with the hash (#) symbol. Macro substitutions
begin with the dollar ($) symbol.
At present there are 2 directive commands available in OpenFOAM:
#include "<fileName>" reads the ﬁle of name <ﬁleName>;
#inputMode has two options: merge, which merges keyword entries in successive dictio-
naries, so that a keyword entry speciﬁed in one place will be overridden by a later
speciﬁcation of the same keyword entry; overwrite, which overwrites the contents
of an entire dictionary; generally, use merge.
For example, let us say a user wishes to set an initial value of pressure once to be used
as the internal ﬁeld and initial value at a boundary. We could create a ﬁle, e.g. named
initialConditions, which contains the following entries:
pressure 1e+05;
#inputMode merge
In order to use this pressure for both the internal and initial boundary ﬁelds, the user
would simply include the following macro substitutions in the pressure ﬁeld ﬁle p:
#include "initialConditions"
internalField $pressure
boundaryField
{
patch1
{
Open∇FOAM-1.5
U-104 OpenFOAM cases
type fixedValue;
value $pressure;
}
}
This is a fairly trivial example that simply demonstrates how this functionality works.
However, the functionality can be used in many, more powerful ways particularly as a
means of generalising case data to suit the user’s needs. For example, if a user has a set
of cases that require the same RAS turbulence model settings, a single ﬁle can be created
with those settings which is simply included in the RASProperties ﬁle of each case. Macro
substitutions can extend well beyond a singe value so that, for example, sets of boundary
conditions can be predeﬁned and called by a single macro. The extent to which such
functionality can be used is almost endless.
4.3 Time and data input/output control
The OpenFOAM solvers begin all runs by setting up a database. The database controls
I/O and, since output of data is usually requested at intervals of time during the run, time
is an inextricable part of the database. The controlDict dictionary sets input parameters
essential for the creation of the database. The keyword entries in controlDict are listed in
Table 4.4. Only the time control and writeInterval entries are truly compulsory, with
the database taking default values indicated by † in Table 4.4 for any of the optional
entries that are omitted.
Time control
startFrom Controls the start time of the simulation.
- firstTime Earliest time step from the set of time directories.
- startTime Time speciﬁed by the startTime keyword entry.
- latestTime Most recent time step from the set of time directories.
startTime Start time for the simulation with startFrom startTime;
stopAt Controls the end time of the simulation.
- endTime Time speciﬁed by the endTime keyword entry.
- writeNow Stops simulation on completion of current time step and writes
data.
- noWriteNow Stops simulation on completion of current time step and does not
write out data.
- nextWrite Stops simulation on completion of next scheduled write time, spec-
iﬁed by writeControl.
endTime End time for the simulation when stopAt endTime; is speciﬁed.
deltaT Time step of the simulation.
Data writing
writeControl Controls the timing of write output to ﬁle.
- timeStep† Writes data every writeInterval time steps.
- runTime Writes data every writeInterval seconds of simulated time.
Continued on next page
Open∇FOAM-1.5
4.3 Time and data input/output control U-105
Continued from previous page
- adjustableRunTime Writes data every writeInterval seconds of simulated time,
adjusting the time steps to coincide with the writeInterval if
necessary — used in cases with automatic time step adjustment.
- cpuTime Writes data every writeInterval seconds of CPU time.
- clockTime Writes data out every writeInterval seconds of real time.
writeInterval Scalar used in conjunction with writeControl described above.
purgeWrite Integer representing a limit on the number of time directories that
are stored by overwriting time directories on a cyclic basis. Exam-
ple of t0 = 5s, ∆t = 1s and purgeWrite 2;: data written into 2
directories, 6 and 7, before returning to write the data at 8 s in 6,
data at 9 s into 7, etc.
To disable the time directory limit, specify purgeWrite 0;†
For steady-state solutions, results from previous iterations can be
continuously overwritten by specifying purgeWrite 1;
writeFormat Speciﬁes the format of the data ﬁles.
- ascii† ASCII format, written to writePrecision signiﬁcant ﬁgures.
- binary Binary format.
writePrecision Integer used in conjunction with writeFormat described above, 6†
by default
writeCompression Speciﬁes the compression of the data ﬁles.
- uncompressed No compression.†
- compressed gzip compression.
timeFormat Choice of format of the naming of the time directories.
- fixed ±m.dddddd where the number of ds is set by timePrecision.
- scientific ±m.dddddde±xx where the number of ds is set by timePrecision.
- general† Speciﬁes scientific format if the exponent is less than -4 or
greater than or equal to that speciﬁed by timePrecision.
timePrecision Integer used in conjunction with timeFormat described above, 6†
by default
graphFormat Format for graph data written by an application.
- raw† Raw ASCII format in columns.
- gnuplot Data in gnuplot format.
- xmgr Data in Grace/xmgr format.
- jplot Data in jPlot format.
Data reading
runTimeModifiable yes†/no switch for whether dictionaries, e.g.controlDict, are re-
read by OpenFOAM at the beginning of each time step.
Continued on next page
Open∇FOAM-1.5
U-106 OpenFOAM cases
Continued from previous page
Run-time loadable functionality
libs List of additional libraries (on $LD LIBRARY PATH) to be loaded
at run-time, e.g.( "libUser1.so" "libUser2.so" )
functions List of functions, e.g.probes to be loaded at run-time; see examples
in $FOAM TUTORIALS
† denotes default entry if associated keyword is omitted.
Table 4.4: Keyword entries in the controlDict dictionary.
Example entries from a controlDict dictionary are given below:
17 application icoFoam;
18
19 startFrom startTime;
20
21 startTime 0;
22
23 stopAt endTime;
24
25 endTime 0.5;
26
27 deltaT 0.005;
28
29 writeControl timeStep;
30
31 writeInterval 20;
32
33 purgeWrite 0;
34
35 writeFormat ascii;
36
37 writePrecision 6;
38
39 writeCompression uncompressed;
40
41 timeFormat general;
42
43 timePrecision 6;
44
45 runTimeModifiable yes;
46
47 // ************************************************************************* //
4.4 Numerical schemes
The fvSchemes dictionary in the system directory sets the numerical schemes for terms,
such as derivatives in equations, that appear in applications being run. This section
describes how to specify the schemes in the fvSchemes dictionary; a description of the
numerics of the schemes is in section 2.4 of the Programmer’s Guide.
The terms that must typically be assigned a numerical scheme in fvSchemes range from
derivatives, e.g. gradient ∇, and interpolations of values from one set of points to another.
The aim in OpenFOAM is to oﬀer an unrestricted choice to the user. For example, while
linear interpolation is eﬀective in many cases, OpenFOAM oﬀers complete freedom to
choose from a wide selection of interpolation schemes for all interpolation terms.
The derivative terms further exemplify this freedom of choice. The user ﬁrst has a
choice of discretisation practice where standard Gaussian ﬁnite volume integration is the
common choice. Gaussian integration is based on summing values on cell faces, which
must be interpolated from cell centres. The user again has a completely free choice
of interpolation scheme, with certain schemes being speciﬁcally designed for particular
derivative terms, especially the convection divergence ∇ • terms.
Open∇FOAM-1.5
4.4 Numerical schemes U-107
The set of terms, for which numerical schemes must be speciﬁed, are subdivided within
the fvSchemes dictionary into the categories listed in Table 4.5. Each keyword in Table 4.5
is the name of a sub-dictionary which contains terms of a particular type, e.g.gradSchemes
contains all the gradient derivative terms such as grad(p) (which represents ∇p). Further
examples can be seen in the extract from an fvSchemes dictionary below:
Keyword Category of mathematical terms
interpolationSchemes Point-to-point interpolations of values
snGradSchemes Component of gradient normal to a cell face
gradSchemes Gradient ∇
divSchemes Divergence ∇ •
laplacianSchemes Laplacian ∇2
timeScheme First and second time derivatives ∂/∂t, ∂2
/∂2
t
fluxRequired Fields which require the generation of a ﬂux
Table 4.5: Main keywords used in fvSchemes.
17 ddtSchemes
18 {
19 default Euler;
20 }
21
22 gradSchemes
23 {
24 default Gauss linear;
25 grad(p) Gauss linear;
26 }
27
28 divSchemes
29 {
30 default none;
31 div(phi,U) Gauss linear;
32 }
33
34 laplacianSchemes
35 {
36 default none;
37 laplacian(nu,U) Gauss linear corrected;
38 laplacian((1|A(U)),p) Gauss linear corrected;
39 }
40
41 interpolationSchemes
42 {
43 default linear;
44 interpolate(HbyA) linear;
45 }
46
47 snGradSchemes
48 {
49 default corrected;
50 }
51
52 fluxRequired
53 {
54 default no;
55 p;
56 }
57
58 // ************************************************************************* //
The example shows that the fvSchemes dictionary contains the following:
• 6 . . . Schemes subdictionaries containing keyword entries for each term speciﬁed
within including: a default entry; other entries whose names correspond to a word
identiﬁer for the particular term speciﬁed, e.g.grad(p) for ∇p
• a ﬂuxRequired sub-dictionary containing ﬁelds for which the ﬂux is generated in the
application, e.g.p in the example.
Open∇FOAM-1.5
U-108 OpenFOAM cases
If a default scheme is speciﬁed in a particular . . . Schemes sub-dictionary, it is assigned
to all of the terms to which the sub-dictionary refers, e.g. specifying a default in grad-
Schemes sets the scheme for all gradient terms in the application, e.g. ∇p, ∇U. When
a default is speciﬁed, it is not necessary to specify each speciﬁc term itself in that sub-
dictionary, i.e. the entries for grad(p), grad(U) in this example. However, if any of these
terms are included, the speciﬁed scheme overrides the default scheme for that term.
Alternatively the user may insist on no default scheme by the none entry. In this
instance the user is obliged to specify all terms in that sub-dictionary individually. Setting
default to none may appear superﬂuous since default can be overridden. However,
specifying none forces the user to specify all terms individually which can be useful to
remind the user which terms are actually present in the application.
The following sections describe the choice of schemes for each of the categories of
terms in Table 4.5.
4.4.1 Interpolation schemes
The interpolationSchemes sub-dictionary contains terms that are interpolations of val-
ues typically from cell centres to face centres. A selection of interpolation schemes in
OpenFOAM are listed in Table 4.6, being divided into 4 categories: 1 category of gen-
eral schemes; and, 3 categories of schemes used primarily in conjunction with Gaussian
discretisation of convection (divergence) terms in ﬂuid ﬂow, described in section 4.4.5.
It is highly unlikely that the user would adopt any of the convection-speciﬁc schemes
for general ﬁeld interpolations in the interpolationSchemes sub-dictionary, but, as valid
interpolation schemes, they are described here rather than in section 4.4.5. Note that
additional schemes such as UMIST are available in OpenFOAM but only those schemes
that are generally recommended are listed in Table 4.6.
A general scheme is simply speciﬁed by quoting the keyword and entry, e.g. a linear
scheme is speciﬁed as default by:
default linear;
The convection-speciﬁc schemes calculate the interpolation based on the ﬂux of the
ﬂow velocity. The speciﬁcation of these schemes requires the name of the ﬂux ﬁeld
on which the interpolation is based; in most OpenFOAM applications this is phi, the
name commonly adopted for the surfaceScalarField velocity ﬂux φ. The 3 categories of
convection-speciﬁc schemes are referred to in this text as: general convection; normalised
variable (NV); and, total variation diminishing (TVD). With the exception of the blended
scheme, the general convection and TVD schemes are speciﬁed by the scheme and ﬂux,
e.g. an upwind scheme based on a ﬂux phi is speciﬁed as default by:
default upwind phi;
Some TVD/NVD schemes require a coeﬃcient ψ, 0 ≤ ψ ≤ 1 where ψ = 1 corresponds
to TVD conformance, usually giving best convergence and ψ = 0 corresponds to best
accuracy. Running with ψ = 1 is generally recommended. A limitedLinear scheme
based on a ﬂux phi with ψ = 1.0 is speciﬁed as default by:
default limitedLinear 1.0 phi;
Open∇FOAM-1.5
4.4 Numerical schemes U-109
4.4.1.1 Schemes for strictly bounded scalar ﬁelds
There are enhanced versions of some of the limited schemes for scalars that need to be
strictly bounded. To bound between user-speciﬁed limits, the scheme name should be
preprended by the word limited and followed by the lower and upper limits respectively.
For example, to bound the vanLeer scheme strictly between -2 and 3, the user would
specify:
default limitedVanLeer -2.0 3.0;
There are specialised versions of these schemes for scalar ﬁelds that are commonly bounded
between 0 and 1. These are selected by adding 01 to the name of the scheme. For example,
to bound the vanLeer scheme strictly between 0 and 1, the user would specify:
default vanLeer01;
Strictly bounded versions are available for the following schemes: limitedLinear, vanLeer,
Gamma, limitedCubic, MUSCL and SuperBee.
4.4.1.2 Schemes for vector ﬁelds
There are improved versions of some of the limited schemes for vector ﬁelds in which
the limited is formulated to take into account the direction of the ﬁeld. These schemes
are selected by adding V to the name of the general scheme, e.g.limitedLinearV for
limitedLinear. ‘V’ versions are available for the following schemes: limitedLinearV,
vanLeerV, GammaV, limitedCubicV and SFCDV.
Centred schemes
linear Linear interpolation (central diﬀerencing)
cubicCorrection Cubic scheme
midPoint Linear interpolation with symmetric weighting
Upwinded convection schemes
upwind Upwind diﬀerencing
linearUpwind Linear upwind diﬀerencing
skewLinear Linear with skewness correction
QUICK Quadratic upwind diﬀerencing
TVD schemes
limitedLinear limited linear diﬀerencing
vanLeer van Leer limiter
MUSCL MUSCL limiter
limitedCubic Cubic limiter
NVD schemes
SFCD Self-ﬁltered central diﬀerencing
Gamma ψ Gamma diﬀerencing
Table 4.6: Interpolation schemes.
Open∇FOAM-1.5
U-110 OpenFOAM cases
4.4.2 Surface normal gradient schemes
The snGradSchemes sub-dictionary contains surface normal gradient terms. A surface
normal gradient is evaluated at a cell face; it is the component, normal to the face, of the
gradient of values at the centres of the 2 cells that the face connects. A surface normal
gradient may be speciﬁed in its own right and is also required to evaluate a Laplacian
term using Gaussian integration.
The available schemes are listed in Table 4.7 and are speciﬁed by simply quoting the
keyword and entry, with the exception of limited which requires a coeﬃcient ψ, 0 ≤ ψ ≤
1 where
ψ =



0 corresponds to uncorrected,
0.333 non-orthogonal correction ≤ 0.5 × orthogonal part,
0.5 non-orthogonal correction ≤ orthogonal part,
1 corresponds to corrected.
(4.1)
A limited scheme with ψ = 0.5 is therefore speciﬁed as default by:
default limited 0.5;
Scheme Description
corrected Explicit non-orthogonal correction
uncorrected No non-orthogonal correction
limited ψ Limited non-orthogonal correction
bounded Bounded correction for positive scalars
fourth Fourth order
Table 4.7: Surface normal gradient schemes.
4.4.3 Gradient schemes
The gradSchemes sub-dictionary contains gradient terms. The discretisation scheme for
each term can be selected from those listed in Table 4.8.
Discretisation scheme Description
Gauss <interpolationScheme> Second order, Gaussian integration
leastSquares Second order, least squares
fourth Fourth order, least squares
limited <gradScheme> Limited version of one of the above schemes
Table 4.8: Discretisation schemes available in gradSchemes.
The discretisation scheme is suﬃcient to specify the scheme completely in the cases
of leastSquares and fourth, e.g.
grad(p) leastSquares;
Open∇FOAM-1.5
4.4 Numerical schemes U-111
The Gauss keyword speciﬁes the standard ﬁnite volume discretisation of Gaussian
integration which requires the interpolation of values from cell centres to face centres.
Therefore, the Gauss entry must be followed by the choice of interpolation scheme from
Table 4.6. It would be extremely unusual to select anything other than general interpo-
lation schemes and in most cases the linear scheme is an eﬀective choice, e.g.
grad(p) Gauss linear;
Limited versions of any of the 3 base gradient schemes — Gauss, leastSquares and
fourth — can be selected by preceding the discretisation scheme by limited, e.g. a
limited Gauss scheme
grad(p) limited Gauss linear;
4.4.4 Laplacian schemes
The laplacianSchemes sub-dictionary contains Laplacian terms. Let us discuss the syntax
of the entry in reference to a typical Laplacian term found in ﬂuid dynamics, ∇ • (ν∇U),
given the word identiﬁer laplacian(nu,U). The Gauss scheme is the only choice of dis-
cretisation and requires a selection of both an interpolation scheme for the diﬀusion
coeﬃcient, i.e. ν in our example, and a surface normal gradient scheme, i.e. ∇U. To
summarise, the entries required are:
Gauss <interpolationScheme> <snGradScheme>
The interpolation scheme is selected from Table 4.6, the typical choices being from the
general schemes and, in most cases, linear. The surface normal gradient scheme is
selected from Table 4.7; the choice of scheme determines numerical behaviour as described
in Table 4.9. A typical entry for our example Laplacian term would be:
laplacian(nu,U) Gauss linear corrected;
Scheme Numerical behaviour
corrected Unbounded, second order, conservative
uncorrected Bounded, ﬁrst order, non-conservative
limited ψ Blend of corrected and uncorrected
bounded First order for bounded scalars
fourth Unbounded, fourth order, conservative
Table 4.9: Behaviour of surface normal schemes used in laplacianSchemes.
4.4.5 Divergence schemes
The divSchemes sub-dictionary contains divergence terms. Let us discuss the syntax of
the entry in reference to a typical convection term found in ﬂuid dynamics ∇ • (ρUU),
which in OpenFOAM applications is commonly given the identiﬁer div(phi,U), where
phi refers to the ﬂux φ = ρU.
The Gauss scheme is only choice of discretisation and requires a selection of the
interpolation scheme for the dependent ﬁeld, i.e. U in our example. To summarise, the
entries required are:
Open∇FOAM-1.5
U-112 OpenFOAM cases
Gauss <interpolationScheme>
The interpolation scheme is selected from the full range of schemes in Table 4.6, both
general and convection-speciﬁc. The choice critically determines numerical behaviour as
described in Table 4.10. The syntax here for specifying convection-speciﬁc interpolation
schemes does not include the ﬂux as it is already known for the particular term, i.e. for
div(phi,U), we know the ﬂux is phi so specifying it in the interpolation scheme would
only invite an inconsistency. Speciﬁcation of upwind interpolation in our example would
therefore be:
div(phi,U) Gauss upwind;
Scheme Numerical behaviour
linear Second order, unbounded
skewLinear Second order, (more) unbounded, skewness correction
cubicCorrected Fourth order, unbounded
upwind First order, bounded
linearUpwind First/second order, bounded
QUICK First/second order, bounded
TVD schemes First/second order, bounded
SFCD Second order, bounded
NVD schemes First/second order, bounded
Table 4.10: Behaviour of interpolation schemes used in divSchemes.
4.4.6 Time schemes
The ﬁrst time derivative (∂/∂t) terms are speciﬁed in the ddtSchemes sub-dictionary. The
discretisation scheme for each term can be selected from those listed in Table 4.11.
There is an oﬀ-centering coeﬃcient ψ with the CrankNicholson scheme that blends
it with the Euler scheme. A coeﬃcient of ψ = 1 corresponds to pure CrankNicholson
and and ψ = 0 corresponds to pure Euler. The blending coeﬃcient can help to improve
stability in cases where pure CrankNicholson are unstable.
Scheme Description
Euler First order, bounded, implicit
CrankNicholson ψ Second order, bounded, implicit
backward Second order, implicit
steadyState Does not solve for time derivatives
Table 4.11: Discretisation schemes available in ddtSchemes.
When specifying a time scheme it must be noted that an application designed for
transient problems will not necessarily run as steady-state and visa versa. For example
the solution will not converge if steadyState is speciﬁed when running icoFoam, the
transient, laminar incompressible ﬂow code; rather, simpleFoam should be used for steady-
state, incompressible ﬂow.
Any second time derivative (∂2
/∂t2
) terms are speciﬁed in the d2dt2Schemes sub-
dictionary. Only the Euler scheme is available for d2dt2Schemes.
Open∇FOAM-1.5
4.5 Solution and algorithm control U-113
4.4.7 Flux calculation
The ﬂuxRequired sub-dictionary lists the ﬁelds for which the ﬂux is generated in the
application. For example, in many ﬂuid dynamics applications the ﬂux is generated after
solving a pressure equation, in which case the ﬂuxRequired sub-dictionary would simply
be entered as follows, p being the word identiﬁer for pressure:
fluxRequired
{
p;
}
4.5 Solution and algorithm control
The equation solvers, tolerances and algorithms are controlled from the fvSolution dic-
tionary in the system directory. Below is an example set of entries from the fvSolution
dictionary required for the icoFoam solver.
17 solvers
18 {
19 p PCG
20 {
21 preconditioner DIC;
22 tolerance 1e-06;
23 relTol 0;
24 };
25
26 U PBiCG
27 {
28 preconditioner DILU;
29 tolerance 1e-05;
30 relTol 0;
31 };
32 }
33
34 PISO
35 {
36 nCorrectors 2;
37 nNonOrthogonalCorrectors 0;
38 pRefCell 0;
39 pRefValue 0;
40 }
41
42 // ************************************************************************* //
fvSolution contains a set of subdictionaries that are speciﬁc to the solver being run. How-
ever, there is a small set of standard subdictionaries that cover most of those used by
the standard solvers. These subdictionaries include solvers, relaxationFactors, PISO and
SIMPLE which are described in the remainder of this section.
4.5.1 Linear solver control
The ﬁrst sub-dictionary in our example, and one that appears in all solver applications,
is solvers. It speciﬁes each linear-solver that is used for each discretised equation; it
is emphasised that the term linear-solver refers to the method of number-crunching to
solve the set of linear equations, as opposed to application solver which describes the set
of equations and algorithms to solve a particular problem. The term ‘linear-solver’ is
abbreviated to ‘solver’ in much of the following discussion; we hope the context of the
term avoids any ambiguity.
The syntax for each entry within solvers begins with a keyword that is the word
relating to the variable being solved in the particular equation. For example, icoFoam
solves equations for velocity U and pressure p, hence the entries for U and p. The variable
Open∇FOAM-1.5
U-114 OpenFOAM cases
name is followed by the solver name and a dictionary containing the parameters that the
solver uses. The solvers available in OpenFOAM are listed in Table 4.12. The parameters,
including tolerance, relTol, preconditioner, etc. are described in following sections.
Solver Keyword
Preconditioned (bi-)conjugate gradient PCG/PBiCG†
Solver using a smoother smoothSolver
Generalised geometric-algebraic multi-grid GAMG
†PCG for symmetric matrices, PBiCG for asymmetric
Table 4.12: Linear solvers.
The solvers distinguish between symmetric matrices and asymmetric matrices. The
symmetry of the matrix depends on the structure of the equation being solved and, while
the user may be able to determine this, it is not essential since OpenFOAM will produce
an error message to advise the user if an inappropriate solver has been selected, e.g.
--> FOAM FATAL IO ERROR : Unknown asymmetric matrix solver PCG
Valid asymmetric matrix solvers are :
3
(
PBiCG
smoothSolver
GAMG
)
4.5.1.1 Solution tolerances
The sparse matrix solvers are iterative, i.e. they are based on reducing the equation
residual over a succession of solutions. The residual is ostensibly a measure of the error
in the solution so that the smaller it is, the more accurate the solution. More precisely,
the residual is evaluated by substituting the current solution into the equation and taking
the magnitude of the diﬀerence between the left and right hand sides; it is also normalised
in to make it independent of the scale of problem being analysed.
Before solving an equation for a particular ﬁeld, the initial residual is evaluated based
on the current values of the ﬁeld. After each solver iteration the residual is re-evaluated.
The solver stops if either of the following conditions are reached:
• the residual falls below the solver tolerance, tolerance;
• the ratio of current to initial residuals falls below the solver relative tolerance,
relTol;
The solver tolerance should represents the level at which the residual is small enough
that the solution can be deemed suﬃciently accurate. The solver relative tolerance limits
the relative improvement from initial to ﬁnal solution. It is quite common to set the
solver relative tolerance to 0 to force the solution to converge to the solver tolerance. The
tolerances, tolerance and relTol must be speciﬁed in the dictionaries for all solvers.
4.5.1.2 Preconditioned conjugate gradient solvers
There are a range of options for preconditioning of matrices in the conjugate gradient
solvers, represented by the preconditioner keyword in the solver dictionary. The pre-
conditioners are listed in Table 4.13.
Open∇FOAM-1.5
4.5 Solution and algorithm control U-115
Preconditioner Keyword
Diagonal incomplete-Cholesky (symmetric) DIC
Faster diagonal incomplete-Cholesky (DIC with caching) FDIC
Diagonal incomplete-LU (asymmetric) DILU
Diagonal diagonal
Geometric-algebraic multi-grid GAMG
No preconditioning none
Table 4.13: Preconditioner options.
4.5.1.3 Smooth solvers
The solvers that use a smoother require the smoother to be speciﬁed. The smoother op-
tions are listed in Table 4.14. Generally GaussSeidel is the most reliable option, but for
bad matrices DIC can oﬀer better convergence. In some cases, additional post-smoothing
using GaussSeidel is further beneﬁcial, i.e. the method denoted as DICGaussSeidel
Smoother Keyword
Gauss-Seidel GaussSeidel
Diagonal incomplete-Cholesky (symmetric) DIC
Diagonal incomplete-Cholesky with Gauss-Seidel (symmetric) DICGaussSeidel
Table 4.14: Smoother options.
The user must also pecify the number of sweeps, by the nSweeps keyword, before the
residual is recalculated, following the tolerance parameters.
4.5.1.4 Geometric-algebraic multi-grid solvers
The generalised method of geometric-algebraic multi-grid (GAMG) uses the principle of:
generating a quick solution on a mesh with a small number of cells; mapping this solution
onto a ﬁner mesh; using it as an initial guess to obtain an accurate solution on the ﬁne
mesh. GAMG is faster than standard methods when the increase in speed by solving ﬁrst
on coarser meshes outweighs the additional costs of mesh reﬁnement and mapping of ﬁeld
data. In practice, GAMG starts with the mesh speciﬁed by the user and coarsens/reﬁnes
the mesh in stages. The user is only required to specify an approximate mesh size at the
most coarse level in terms of the number of cells nCoarsestCells.
The agglomeration of cells is performed by the algorithm speciﬁed by the agglomerator
keyword. Presently we recommend the faceAreaPair method. It is worth noting there is
an MGridGen option that requires an additional entry specifying the shared object library
for MGridGen:
geometricGamgAgglomerationLibs ("libMGridGenGamgAgglomeration.so");
In the experience of OpenCFD, the MGridGen method oﬀers no obvious beneﬁt over the
faceAreaPair method. For all methods, agglomeration can be optionally cached by the
cacheAgglomeration switch.
Smoothing is speciﬁed by the smoother as described in section 4.5.1.3. The number
of sweeps used by the smoother at diﬀerent levels of mesh density are speciﬁed by the
nPreSweeps, nPostSweeps and nFinestSweeps keywords. The nPreSweeps entry is used
Open∇FOAM-1.5
U-116 OpenFOAM cases
as the algorithm is coarsening the mesh, nPostSweeps is used as the algorithm is reﬁning,
and nFinestSweeps is used when the solution is at its ﬁnest level.
The mergeLevels keyword controls the speed at which coarsening or reﬁnement levels
is performed. It is often best to do so only at one level at a time, i.e. set mergeLevels
1. In some cases, particularly for simple meshes, the solution can be safely speeded up
by coarsening/reﬁning two levels at a time, i.e. setting mergeLevels 2.
4.5.2 Solution under-relaxation
A second sub-dictionary of fvSolution that is often used in OpenFOAM is relaxationFactors
which controls under-relaxation, a technique used for improving stability of a computa-
tion, particularly in solving steady-state problems. Under-relaxation works by limiting
the amount which a variable changes from one iteration to the next, either by modifying
the solution matrix and source prior to solving for a ﬁeld or by modifying the ﬁeld di-
rectly. An under-relaxation factor α, 0 < α ≤ 1 speciﬁes the amount of under-relaxation,
ranging from none at all for α = 1 and increasing in strength as α → 0. The limiting case
where α = 0 represents a solution which does not change at all with successive iterations.
An optimum choice of α is one that is small enough to ensure stable computation but
large enough to move the iterative process forward quickly; values of α as high as 0.9
can ensure stability in some cases and anything much below, say, 0.2 are prohibitively
restrictive in slowing the iterative process.
The user can specify the relaxation factor for a particular ﬁeld by specifying ﬁrst the
word associated with the ﬁeld, then the factor. The user can view the relaxation factors
used in a tutorial example of simpleFoam for incompressible, laminar, steady-state ﬂows.
17 solvers
18 {
19 p PCG
20 {
21 preconditioner DIC;
22 tolerance 1e-06;
23 relTol 0.01;
24 };
25 U PBiCG
26 {
27 preconditioner DILU;
28 tolerance 1e-05;
29 relTol 0.1;
30 };
31 k PBiCG
32 {
33 preconditioner DILU;
34 tolerance 1e-05;
35 relTol 0.1;
36 };
37 epsilon PBiCG
38 {
39 preconditioner DILU;
40 tolerance 1e-05;
41 relTol 0.1;
42 };
43 R PBiCG
44 {
45 preconditioner DILU;
46 tolerance 1e-05;
47 relTol 0.1;
48 };
49 nuTilda PBiCG
50 {
51 preconditioner DILU;
52 tolerance 1e-05;
53 relTol 0.1;
54 };
55 }
56
57 SIMPLE
58 {
59 nNonOrthogonalCorrectors 0;
60 }
Open∇FOAM-1.5
4.5 Solution and algorithm control U-117
61
62 relaxationFactors
63 {
64 p 0.3;
65 U 0.7;
66 k 0.7;
67 epsilon 0.7;
68 R 0.7;
69 nuTilda 0.7;
70 }
71
72 // ************************************************************************* //
4.5.3 PISO and SIMPLE algorithms
Most ﬂuid dynamics solver applications in OpenFOAM use the pressure-implicit split-
operator (PISO) or semi-implicit method for pressure-linked equations (SIMPLE) algo-
rithms. These algorithms are iterative procedures for solving equations for velocity and
pressure, PISO being used for transient problems and SIMPLE for steady-state.
Both algorithms are based on evaluating some initial solutions and then correcting
them. SIMPLE only makes 1 correction whereas PISO requires more than 1, but typically
not more than 4. The user must therefore specify the number of correctors in the PISO
dictionary by the nCorrectors keyword as shown in the example on page U-113.
An additional correction to account for mesh non-orthogonality is available in both
SIMPLE and PISO in the standard OpenFOAM solver applications. A mesh is orthogonal
if, for each face within it, the face normal is parallel to the vector between the centres of
the cells that the face connects, e.g. a mesh of hexahedral cells whose faces are aligned
with a Cartesian coordinate system. The number of non-orthogonal correctors is speciﬁed
by the nNonOrthogonalCorrectors keyword as shown in the examples above and on
page U-113. The number of non-orthogonal correctors should correspond to the mesh for
the case being solved, i.e. 0 for an orthogonal mesh and increasing with the degree of
non-orthogonality up to, say, 20 for the most non-orthogonal meshes.
4.5.3.1 Pressure referencing
In a closed incompressible system, pressure is relative: it is the pressure range that matters
not the absolute values. In these cases, the solver sets a reference level of pRefValue in
cell pRefCell where p is the name of the pressure solution variable. Where the pressure
is pd, the names are pdRefValue and pdRefCell respectively. These entries are generally
stored in the PISO/SIMPLE sub-dictionary and are used by those solvers that require
them when the case demands it. If ommitted, the solver will not run, but give a message
to alert the user to the problem.
4.5.4 Other parameters
The fvSolutions dictionaries in the majority of standard OpenFOAM solver applications
contain no other entries than those described so far in this section. However, in general
the fvSolution dictionary may contain any parameters to control the solvers, algorithms,
or in fact anything. For a given solver, the user can look at the source code to ﬁnd the
parameters required. Ultimately, if any parameter or sub-dictionary is missing when an
solver is run, it will terminate, printing a detailed error message. The user can then add
missing parameters accordingly.
Open∇FOAM-1.5
U-118 OpenFOAM cases
Open∇FOAM-1.5
Chapter 5
Mesh generation and conversion
This chapter describes all topics relating to the creation of meshes in OpenFOAM:
section 5.1 gives an overview of the ways a mesh may be described in OpenFOAM;
section 5.3 covers the blockMesh utility for generating simple meshes of blocks of hex-
ahedral cells; section 5.4 covers the snappyHexMesh utility for generating complex meshes
of hexahedral and split-hexahedral cells automatically from triangulated surface geome-
tries; section 5.5 describes the options available for conversion of a mesh that has been
generated by a third-party product into a format that OpenFOAM can read.
5.1 Mesh description
This section provides a speciﬁcation of the way the OpenFOAM C++ classes handle a
mesh. The mesh is an integral part of the numerical solution and must satisfy certain
criteria to ensure a valid, and hence accurate, solution. During any run, OpenFOAM
checks that the mesh satisﬁes a fairly stringent set of validity constraints and will cease
running if the constraints are not satisﬁed. The consequence is that a user may experience
some frustration in ‘correcting’ a large mesh generated by third-party mesh generators
before OpenFOAM will run using it. This is unfortunate but we make no apology for
OpenFOAM simply adopting good practice to ensure the mesh is valid; otherwise, the
solution is ﬂawed before the run has even begun.
By default OpenFOAM deﬁnes a mesh of arbitrary polyhedral cells in 3-D, bounded
by arbitrary polygonal faces, i.e. the cells can have an unlimited number of faces where,
for each face, there is no limit on the number of edges nor any restriction on its alignment.
A mesh with this general structure is known in OpenFOAM as a polyMesh. It is described
in further detail in section 2.3 of the Programmer’s Guide, but it is suﬃcient to mention
here that this type of mesh oﬀers great freedom in mesh generation and manipulation
in particular when the geometry of the domain is complex or changes over time. The
price of absolute mesh generality is, however, that it can be diﬃcult to convert meshes
generated using conventional tools. The OpenFOAM library therefore provides cellShape
tools to manage conventional mesh formats based on sets of pre-deﬁned cell shapes.
5.1.1 Mesh speciﬁcation and validity constraints
Before describing the OpenFOAM mesh format, polyMesh, and the cellShape tools, we
will ﬁrst set out the validity constraints used in OpenFOAM. The conditions that a mesh
must satisfy are:
U-120 Mesh generation and conversion
5.1.1.1 Points
A point is a location in 3-D space, deﬁned by a vector in units of metres (m). The points
are compiled into a list and each point is referred to by a label, which represents its
position in the list, starting from zero. The point list cannot contain two diﬀerent points
at an exactly identical position nor any point that is not part at least one face.
5.1.1.2 Faces
A face is an ordered list of points, where a point is referred to by its label. The ordering
of point labels in a face is such that each two neighbouring points are connected by an
edge, i.e. you follow points as you travel around the circumference of the face. Faces are
compiled into a list and each face is referred to by its label, representing its position in
the list. The direction of the face normal vector is deﬁned by the right-hand rule, i.e.
looking towards a face, if the numbering of the points follows an anti-clockwise path, the
normal vector points towards you, as shown in Figure 5.1.
4
3
0
2
1
Sf
Figure 5.1: Face area vector from point numbering on the face
There are two types of face:
Internal faces Those faces that connect two cells (and it can never be more than two).
For each internal face, the ordering of the point labels is such that the face normal
points into the cell with the larger label, i.e. for cells 2 and 5, the normal points
into 5;
Boundary faces Those belonging to one cell since they coincide with the boundary
of the domain. A boundary face is therefore addressed by one cell(only) and a
boundary patch. The ordering of the point labels is such that the face normal
points outside of the computational domain.
Faces are generally expected to be convex; at the very least the face centre needs to
be inside the face. Faces are allowed to be warped, i.e. not all points of the face need to
be coplanar.
5.1.1.3 Cells
A cell is a list of faces in arbitrary order. Cells must have the properties listed below.
Contiguous The cells must completely cover the computational domain and are must
not overlap one another.
Open∇FOAM-1.5
5.1 Mesh description U-121
Convex Every cell must be convex and its cell centre inside the cell.
Closed Every cell must be closed, both geometrically and topologically where:
• geometrical closedness requires that when all face area vectors are oriented to
point outwards of the cell, their sum should equal the zero vector to machine
accuracy;
• topological closedness requires that all the edges in a cell are used by exactly
two faces of the cell in question.
Orthogonality For all internal faces of the mesh, we deﬁne the centre-to-centre vector
as that connecting the centres of the 2 cells that it adjoins oriented from the the
centre of the cell with smaller label to the centre of the cell with larger label. The
orthogonality constraint requires that for each internal face, the angle between the
face area vector, oriented as described above, and the centre-to-centre vector must
always be less than 90◦
.
5.1.1.4 Boundary
A boundary is a list of patches, each of which is associated with a boundary condition.
A patch is a list of face labels which clearly must contain only boundary faces and no
internal faces. The boundary is required to be closed, i.e. the sum all boundary face area
vectors equates to zero to machine tolerance.
5.1.2 The polyMesh description
The constant directory contains a full description of the case polyMesh in a subdirectory
polyMesh. The polyMesh description is based around faces and, as already discussed,
internal cells connect 2 cells and boundary faces address a cell and a boundary patch.
Each face is therefore assigned an ‘owner’ cell and ‘neighbour’ cell so that the connectivity
across a given face can simply be described by the owner and neighbour cell labels. In
the case of boundaries, the connected cell is the owner and the neighbour is assigned the
label ‘-1’. With this in mind, the I/O speciﬁcation consists of the following ﬁles:
points a list of vectors describing the cell vertices, where the ﬁrst vector in the list repre-
sents vertex 0, the second vector represents vertex 1, etc.;
faces a list of faces, each face being a list of indices to vertices in the points list, where
again, the ﬁrst entry in the list represents face 0, etc.;
owner a list of owner cell labels, the index of entry relating directly to the index of the
face, so that the ﬁrst entry in the list is the owner label for face 0, the second entry
is the owner label for face 1, etc;
neighbour a list of neighbour cell labels;
boundary a list of patches, containing a dictionary entry for each patch, declared using
the patch name, e.g.
movingWall
{
type patch;
nFaces 20;
startFace 760;
Open∇FOAM-1.5
U-122 Mesh generation and conversion
}
The startFace is the index into the face list of the ﬁrst face in the patch, and
nFaces is the number of faces in the patch.
Note that if the user wishes to know how many cells are in their domain, there is a
note in the FoamFile header of the owner ﬁle that contains an entry for nCells.
5.1.3 The cellShape tools
We shall describe the alternative cellShape tools that may be used particularly when
converting some standard (simpler) mesh formats for the use with OpenFOAM library.
The vast majority of mesh generators and post-processing systems support only a
fraction of the possible polyhedral cell shapes in existence. They deﬁne a mesh in terms
of a limited set of 3D cell geometries, referred to as cell shapes. The OpenFOAM library
contains deﬁnitions of these standard shapes, to enable a conversion of such a mesh into
the polyMesh format described in the previous section.
The cellShape models supported by OpenFOAM are shown in Table 5.1. The shape is
deﬁned by the ordering of point labels in accordance with the numbering scheme contained
in the shape model. The ordering schemes for points, faces and edges are shown in
Table 5.1. The numbering of the points must not be such that the shape becomes twisted
or degenerate into other geometries, i.e. the same point label cannot be used more that
once is a single shape. Moreover it is unnecessary to use duplicate points in OpenFOAM
since the available shapes in OpenFOAM cover the full set of degenerate hexahedra.
The cell description consists of two parts: the name of a cell model and the ordered
list of labels. Thus, using the following list of points
8
(
(0 0 0)
(1 0 0)
(1 1 0)
(0 1 0)
(0 0 0.5)
(1 0 0.5)
(1 1 0.5)
(0 1 0.5)
)
A hexahedral cell would be written as:
(hex 8(0 1 2 3 4 5 6 7))
Here the hexahedral cell shape is declared using the keyword hex. Other shapes are
described by the keywords listed in Table 5.1.
5.1.4 1- and 2-dimensional and axi-symmetric problems
OpenFOAM is designed as a code for 3-dimensional space and deﬁnes all meshes as
such. However, 1- and 2- dimensional and axi-symmetric problems can be simulated
in OpenFOAM by generating a mesh in 3 dimensions and applying special boundary
conditions on any patch in the plane(s) normal to the direction(s) of interest. More
speciﬁcally, 1- and 2- dimensional problems use the empty patch type and axi-symmetric
problems use the wedge type. The use of both are described in section 5.2.2 and the
generation of wedge geometries for axi-symmetric problems is discussed in section 5.3.3.
Open∇FOAM-1.5
5.2 Boundaries U-123
Cell type Keyword Vertex numbering Face numbering Edge numbering
Hexahedron hex
2
7
3
10
4
6
5
0 1
2
3
5
4
0
1
2
3
4
5
6
7
8 9
1011
Wedge wedge
2
10
3 4
56
0
1
2
35
4
0
1
2
3
5
6
7
8
9
10
4
Prism prism
2
10
3 4
5
0
1
3
4
2
0
1
2
3
4
5
6 7
8
Pyramid pyr
2
10
4
3
0
2
34
1
0
1
2
3
4 5
67
Tetrahedron tet 0 1
2
3
1
2
3
0
0
1
2
3
4
5
Tet-wedge tetWedge
2
10
3 4
0
1
3
2
0
1
2
3
4
5
6
Table 5.1: Vertex, face and edge numbering for cellShapes.
Open∇FOAM-1.5
U-124 Mesh generation and conversion
5.2 Boundaries
In this section we discuss the way in which boundaries are treated in OpenFOAM. The
subject of boundaries is a little involved because their role in modelling is not simply that
of a geometric entity but an integral part of the solution and numerics through boundary
conditions or inter-boundary ‘connections’. A discussion of boundaries sits uncomfortably
between a discussion on meshes, ﬁelds, discretisation, computational processing etc. Its
placement in this Chapter on meshes is a choice of convenience.
We ﬁrst need to consider that, for the purpose of applying boundary conditions, a
boundary is generally broken up into a set of patches. One patch may include one or
more enclosed areas of the boundary surface which do not necessarily need to be physically
connected.
There are four attributes associated with a patch that are described below in their
natural hierarchy and Figure 5.2 shows the names of diﬀerent patch types introduced
at each level of the hierarchy. The hierarchy described below is very similar, but not
identical, to the class hierarchy used in the OpenFOAM library.
Base type The type of patch described purely in terms of geometry or a data ‘commu-
nication link’.
Primitive type The base numerical patch condition assigned to a ﬁeld variable on the
patch.
Derived type A complex patch condition, derived from the primitive type, assigned to
a ﬁeld variable on the patch.
Derived type
ﬁxedGradient
ﬁxedValue
Primitive type
calculated
mixed
directionMixed
zeroGradient
symmetry
empty
wedge
cyclicBase type
processor
patch
wall
e.g.inletOutlet
Figure 5.2: Patch attributes
5.2.1 Speciﬁcation of patch types in OpenFOAM
The patch types are speciﬁed in the mesh and ﬁeld ﬁles of a OpenFOAM case. More
precisely:
• the base type is speciﬁed under the type keyword for each patch in the boundary
ﬁle, located in the constant/polyMesh directory;
Open∇FOAM-1.5
5.2 Boundaries U-125
• the numerical patch type, be it a primitive or derived type, is speciﬁed under the
type keyword for each patch in a ﬁeld ﬁle.
An example boundary ﬁle is shown below for a sonicFoam case, followed by a pressure
ﬁeld ﬁle, p, for the same case:
17 6
18 (
19 inlet
20 {
21 type patch;
22 nFaces 50;
23 startFace 10325;
24 }
25
26 outlet
27 {
28 type patch;
29 nFaces 40;
30 startFace 10375;
31 }
32
33 bottom
34 {
35 type symmetryPlane;
36 nFaces 25;
37 startFace 10415;
38 }
39
40 top
41 {
42 type symmetryPlane;
43 nFaces 125;
44 startFace 10440;
45 }
46
47 obstacle
48 {
49 type patch;
50 nFaces 110;
51 startFace 10565;
52 }
53
54 defaultFaces
55 {
56 type empty;
57 nFaces 10500;
58 startFace 10675;
59 }
60 )
61
62 // ************************************************************************* //
17 dimensions [1 -1 -2 0 0 0 0];
18
19 internalField uniform 1;
20
21 boundaryField
22 {
23 inlet
24 {
25 type fixedValue;
26 value uniform 1;
27 }
28
29 outlet
30 {
31 type waveTransmissive;
32 field p;
33 phi phi;
34 rho rho;
35 psi psi;
36 gamma 1.4;
37 fieldInf 1;
38 lInf 3;
39 value uniform 1;
40 }
41
42 bottom
43 {
44 type symmetryPlane;
45 }
46
47 top
Open∇FOAM-1.5
U-126 Mesh generation and conversion
48 {
49 type symmetryPlane;
50 }
51
52 obstacle
53 {
54 type zeroGradient;
55 }
56
57 defaultFaces
58 {
59 type empty;
60 }
61 }
62
63 // ************************************************************************* //
The type in the boundary ﬁle is patch for all patches except those that patches that have
some geometrical constraint applied to them, i.e. the symmetryPlane and empty patches.
The p ﬁle includes primitive types applied to the inlet and bottom faces, and a more
complex derived type applied to the outlet. Comparison of the two ﬁles shows that the
base and numerical types are consistent where the base type is not a simple patch, i.e.
for the symmetryPlane and empty patches.
5.2.2 Base types
The base and geometric types are described below; the keywords used for specifying these
types in OpenFOAM are summarised in Table 5.2.
wedge aligned along
coordinate plane
5◦ Axis of symmetry
wedge patch 1
wedge patch 2
Figure 5.3: Axi-symmetric geometry using the wedge patch type.
patch The basic patch type for a patch condition that contains no geometric or topological
information about the mesh (with the exception of wall), e.g. an inlet or an outlet.
wall There are instances where a patch that coincides with a wall needs to be identiﬁable
as such, particularly where specialist modelling is applied at wall boundaries. A
good example is wall turbulence modelling where a wall must be speciﬁed with a
wall patch type, so that the distance from the wall of the cell centres next to the
wall are stored as part of the patch.
symmetryPlane For a symmetry plane.
Open∇FOAM-1.5
5.3 Mesh generation with the blockMesh utility U-127
Selection Key Description
patch generic patch
symmetryPlane plane of symmetry
empty front and back planes of 2D geometry
wedge wedge front and back
cyclic cyclic plane
wall wall (used for wall functions in turbulent ﬂows)
processor inter-processor boundary
Table 5.2: Basic patch types.
empty While OpenFOAM always generates geometries in 3 dimensions, it can be in-
structed to solve in 2 (or 1) dimensions by specifying a special empty condition on
each patch whose plane is normal to the 3rd (and 2nd) dimension for which no
solution is required.
wedge For 2 dimensional axi-symmetric cases, e.g. a cylinder, the geometry is speciﬁed as
a wedge of 5◦
angle and 1 cell thick running along the plane of symmetry, straddling
one of the coordinate planes, as shown in Figure 5.3. The axi-symmetric wedge
planes must be speciﬁed as separate patches of wedge type. The details of generating
wedge-shaped geometries using blockMesh are described in section 5.3.3.
cyclic Enables two patches to be treated as if they are physically connected; used for
repeated geometries, e.g. heat exchanger tube bundles. A single cyclic patch splits
the faces in its faceList into two, and links the two sets of faces as shown in Figure 5.4.
Each face-face pair must be of the same area but the faces do not need to be of the
same orientation.
processor If a code is being run in parallel, on a number of processors, then the mesh
must be divided up so that each processor computes on roughly the same number
of cells. The boundaries between the diﬀerent parts of the mesh are called processor
boundaries.
5.2.3 Primitive types
The primitive types are listed in Table 5.3.
5.2.4 Derived types
The derived types are listed in Table 5.4.
5.3 Mesh generation with the blockMesh utility
This section describes the mesh generation utility, blockMesh, supplied with OpenFOAM.
The blockMesh utility creates parametric meshes with grading and curved edges.
The mesh is generated from a dictionary ﬁle named blockMeshDict located in the
constant/polyMesh directory of a case. blockMesh reads this dictionary, generates the
mesh and writes out the mesh data to points and faces, cells and boundary ﬁles in the
same directory.
Open∇FOAM-1.5
U-128 Mesh generation and conversion
2
3
1
1
2
3
faceList
4
5
6
4
5
6
cyclic
Repeated geometry
computational links
Figure 5.4: Repeated geometry using the cyclic patch type.
Type Description of condition for patch ﬁeld φ Data to specify
ﬁxedValue Value of φ is speciﬁed value
ﬁxedGradient Normal gradient of φ is speciﬁed gradient
zeroGradient Normal gradient of φ is zero —
calculated Boundary ﬁeld φ derived from other ﬁelds —
mixed Mixed ﬁxedValue/ ﬁxedGradient condition depend-
ing on the value in valueFraction
refValue,
refGradient,
valueFraction,
value
directionMixed A mixed condition normal to the patch with a
ﬁxedGradient condition tangential to the patch
refValue,
refGradient,
valueFraction,
value
Table 5.3: Primitive patch ﬁeld types.
Open∇FOAM-1.5
5.3MeshgenerationwiththeblockMeshutilityU-129
Types derived from ﬁxedValue Data to specify
movingWallVelocity Replaces the normal of the patch value so the ﬂux across the patch is zero value
pressureInletVelocity When p is known at inlet, U is evaluated from the ﬂux, normal to the patch value
pressureDirectedInletVelocityWhen p is known at inlet, U is calculated from the ﬂux in the inletDirection value,
inletDirection
surfaceNormalFixedValue Speciﬁes a vector boundary condition, normal to the patch, by its magnitude; +ve
for vectors pointing out of the domain
value
totalPressure Total pressure p0 = p + 1
2
ρ|U|2
is ﬁxed; when U changes, p is adjusted accordingly p0
turbulentInlet Calculates a ﬂuctuating variable based on a scale of a mean value referenceField,
fluctuationScale
Types derived from ﬁxedGradient/zeroGradient
ﬂuxCorrectedVelocity Calculates normal component of U at inlet from ﬂux value
wallBuoyantPressure Sets ﬁxedGradient pressure based on the atmospheric pressure gradient —
Types derived from mixed
inletOutlet Switches U and p between ﬁxedValue and zeroGradient depending on direction of U inletValue, value
outletInlet Switches U and p between ﬁxedValue and zeroGradient depending on direction of U outletValue,
value
pressureInletOutletVelocity Combination of pressureInletVelocity and inletOutlet value
pressureDirected-
InletOutletVelocity
Combination of pressureDirectedInletVelocity and inletOutlet value,
inletDirection
pressureTransmissive Transmits supersonic pressure waves to surrounding pressure p∞ pInf
supersonicFreeStream Transmits oblique shocks to surroundings at p∞, T∞, U∞ pInf, TInf, UInf
Other types
slip zeroGradient if φ is a scalar; if φ is a vector, normal component is ﬁxedValue zero,
tangential components are zeroGradient
—
partialSlip Mixed zeroGradient/ slip condition depending on the valueFraction; = 1 for slip valueFraction
Note: p is pressure, U is velocity
Table 5.4: Derived patch ﬁeld types.
Open∇FOAM-1.5
U-130 Mesh generation and conversion
The principle behind blockMesh is to decompose the domain geometry into a set of 1
or more three dimensional, hexahedral blocks. Edges of the blocks can be straight lines,
arcs or splines. The mesh is ostensibly speciﬁed as a number of cells in each direction of
the block, suﬃcient information for blockMesh to generate the mesh data.
Each block of the geometry is deﬁned by 8 vertices, one at each corner of a hexahedron.
The vertices are written in a list so that each vertex can be accessed using its label,
remembering that OpenFOAM always uses the C++ convention that the ﬁrst element of
the list has label ‘0’. An example block is shown in Figure 5.5 with each vertex numbered
according to the list. The edge connecting vertices 1 and 5 is curved to remind the reader
that curved edges can be speciﬁed in blockMesh.
It is possible to generate blocks with less than 8 vertices by collapsing one or more
pairs of vertices on top of each other, as described in section 5.3.3.
Each block has a local coordinate system (x1, x2, x3) that must be right-handed. A
right-handed set of axes is deﬁned such that to an observer looking down the Oz axis,
with O nearest them, the arc from a point on the Ox axis to a point on the Oy axis is in
a clockwise sense.
The local coordinate system is deﬁned by the order in which the vertices are presented
in the block deﬁnition according to:
• the axis origin is the ﬁrst entry in the block deﬁnition, vertex 0 in our example;
• the x1 direction is described by moving from vertex 0 to vertex 1;
• the x2 direction is described by moving from vertex 1 to vertex 2;
• vertices 0, 1, 2, 3 deﬁne the plane x3 = 0;
• vertex 4 is found by moving from vertex 0 in the x3 direction;
• vertices 5,6 and 7 are similarly found by moving in the x3 direction from vertices
1,2 and 3 respectively.
3
9
1
2
x2
x3
x10
3
4
5
7 6
0
2
1
4 5
6
7
10
8
11
Figure 5.5: A single block
Open∇FOAM-1.5
5.3 Mesh generation with the blockMesh utility U-131
Keyword Description Example/selection
convertToMeters Scaling factor for the vertex
coordinates
0.001 scales to mm
vertices List of vertex coordinates (0 0 0)
edges Used to describe arc or
spline edges
arc 1 4 (0.939 0.342 -0.5)
block Ordered list of vertex labels
and mesh size
hex (0 1 2 3 4 5 6 7)
(10 10 1)
simpleGrading (1.0 1.0 1.0)
patches List of patches symmetryPlane base
( (0 1 2 3) )
Table 5.5: Keywords used in blockMeshDict.
5.3.1 Writing a blockMeshDict ﬁle
The blockMeshDict ﬁle is a dictionary using keywords described in Table 5.5. The convertToMeters
keyword speciﬁes a scaling factor by which all vertex coordinates in the mesh description
are multiplied. For example,
convertToMeters 0.001;
means that all coordinates are multiplied by 0.001, i.e. the values quoted in the blockMesh-
Dict ﬁle are in mm.
5.3.1.1 The vertices
The vertices of the blocks of the mesh are given next as a standard list named vertices,
e.g. for our example block in Figure 5.5, the vertices are:
vertices
(
( 0 0 0 ) // vertex number 0
( 1 0 0.1) // vertex number 1
( 1.1 1 0.1) // vertex number 2
( 0 1 0.1) // vertex number 3
(-0.1 -0.1 1 ) // vertex number 4
( 1.3 0 1.2) // vertex number 5
( 1.4 1.1 1.3) // vertex number 6
( 0 1 1.1) // vertex number 7
);
5.3.1.2 The edges
Each edge joining 2 vertex points is assumed to be straight by default. However any edge
may be speciﬁed to be curved by entries in a list named edges. The list is optional; if
the geometry contains no curved edges, it may be omitted.
Each entry for a curved edge begins with a keyword specifying the type of curve from
those listed in Table 5.6.
The keyword is then followed by the labels of the 2 vertices that the edge connects.
Following that, interpolation points must be speciﬁed through which the edge passes.
Open∇FOAM-1.5
U-132 Mesh generation and conversion
Keyword selection Description Additional entries
arc Circular arc Single interpolation point
simpleSpline Spline curve List of interpolation points
polyLine Set of lines List of interpolation points
polySpline Set of splines List of interpolation points
line Straight line —
Table 5.6: Edge types available in the blockMeshDict dictionary.
For a arc, a single interpolation point is required, which the circular arc will intersect.
For simpleSpline, polyLine and polySpline, a list of interpolation points is required.
The line edge is directly equivalent to the option executed by default, and requires no
interpolation points. Note that there is no need to use the line edge but it is included
for completeness. For our example block in Figure 5.5 we specify an arc edge connecting
vertices 1 and 5 as follows through the interpolation point (1.1, 0.0, 0.5):
edges
(
arc 1 5 (1.1 0.0 0.5)
);
5.3.1.3 The blocks
The block deﬁnitions are contained in a list named blocks. Each block deﬁnition is a
compound entry consisting of a list of vertex labels whose order is described in section 5.3,
a vector giving the number of cells required in each direction, the type and list of cell
expansion ratio in each direction.
Then the blocks are deﬁned as follows:
blocks
(
hex (0 1 2 3 4 5 6 7) // vertex numbers
(10 10 10) // numbers of cells in each direction
simpleGrading (1 2 3) // cell expansion ratios
);
The deﬁnition of each block is as follows:
Vertex numbering The ﬁrst entry is the is the shape identiﬁer of the block, as deﬁned
in the .OpenFOAM-1.5/cellModels ﬁle. The shape is always hex since the blocks are
always hexahedra. There follows a list of vertex numbers, ordered in the manner
described on page U-130.
Number of cells The second entry gives the number of cells in each of the x1 x2 and
x3 directions for that block.
Cell expansion ratios The third entry gives the cell expansion ratios for each direction
in the block. The expansion ratio enables the mesh to be graded, or reﬁned, in
speciﬁed directions. The ratio is that of the width of the end cell δe along one edge
of a block to the width of the start cell δs along that edge, as shown in Figure 5.6.
Each of the following keywords specify one of two types of grading speciﬁcation
available in blockMesh.
Open∇FOAM-1.5
5.3 Mesh generation with the blockMesh utility U-133
simpleGrading The simple description speciﬁes uniform expansions in the local x1,
x2 and x3 directions respectively with only 3 expansion ratios, e.g.
simpleGrading (1 2 3)
edgeGrading The full cell expansion description gives a ratio for each edge of the
block, numbered according to the scheme shown in Figure 5.5 with the arrows
representing the direction ‘from ﬁrst cell. . . to last cell’ e.g. something like
edgeGrading (1 1 1 1 2 2 2 2 3 3 3 3)
This means the ratio of cell widths along edges 0-3 is 1, along edges 4-7 is 2
and along 8-11 is 3 and is directly equivalent to the simpleGrading example
given above.
δs
Expansion ratio =
δe
δs
δe
Expansion direction
Figure 5.6: Mesh grading along a block edge
5.3.1.4 The patches
The patches of the mesh are given in a list named patches. Each patch in the list is a
compound entry containing:
• the patch type, either a generic patch on which some boundary conditions are
applied or a particular geometric condition, as listed in Table 5.2 and described in
section 5.2.2;
• a list of block faces that make up the patch and whose name is the choice of the
the user, although we recommend something that conveniently identiﬁes the patch,
e.g. quoteTextinlet; the name is used as an identiﬁer for for for setting boundary
conditions in the ﬁeld data ﬁles.
blockMesh collects faces from any boundary patch that is omitted from the patches
list and assigns them to a default patch named defaultFaces of type empty. This means
that for a 2 dimensional geometry, the user has the option to omit block faces lying in
the 2D plane, knowing that they will be collected into an empty patch as required.
Returning to the example block in Figure 5.5, if it has an inlet on the left face, an
output on the right face and the four other faces are walls then the patches could be
deﬁned as follows:
patches // keyword
(
patch // patch type for patch 0
inlet // patch name
(
(0 4 7 3) // block face in this patch
) // end of 0th patch definition
patch // patch type for patch 1
outlet // arbitrary patch name
Open∇FOAM-1.5
U-134 Mesh generation and conversion
(
(1 2 6 5)
)
wall
walls
(
(0 1 5 4)
(0 3 2 1)
(3 7 6 2)
(4 5 6 7)
)
);
Each block face is deﬁned by a list of 4 vertex numbers. The order in which the vertices
are given must be such that, looking from inside the block and starting with any vertex,
the face must be traversed in a clockwise direction to deﬁne the other vertices.
5.3.2 Multiple blocks
A mesh can be created using more than 1 block. In such circumstances, the mesh is
created as has been described in the preceeding text; the only additional issue is the
connection between blocks, in which there are two distinct possibilities:
face matching the set of faces that comprise a patch from one block are exactly collo-
cated with a set of faces patch that comprise a patch from another block;
face merging a group of faces from a patch from one block are connected to another
group of faces from a patch from another block, to create a new set of internal faces
connecting the two blocks.
To connect two blocks with face matching, the two patches that form the connection
should simply be ignored from the patches list. blockMesh then identiﬁes that the faces
do not form an external boundary and combines each collocated pair into a single internal
faces that connects cells from the two blocks.
The alternative, face merging, requires that the block patches to be merged are ﬁrst
deﬁned in the patches list. Each pair of patches whose faces are to be merged must then
be included in an optional list named mergePatchPairs. The format of mergePatchPairs
is:
mergePatchPairs
(
( <masterPatch> <slavePatch> ) // merge patch pair 0
( <masterPatch> <slavePatch> ) // merge patch pair 1
...
)
The pairs of patches are interpreted such that the ﬁrst patch becomes the master and
the second becomes the slave. The rules for merging are as follows:
• the faces of the master patch remain as originally deﬁned, with all vertices in their
original location;
Open∇FOAM-1.5
5.3 Mesh generation with the blockMesh utility U-135
• the faces of the slave patch are projected onto the master patch where there is some
separation between slave and master patch;
• the location of any vertex of a slave face might be adjusted by blockMesh to eliminate
any face edge that is shorter than a minimum tolerance;
• if patches overlap as shown in Figure 5.7, each face that does not merge remains as
an external face of the original patch, on which boundary conditions must then be
applied;
• if all the faces of a patch are merged, then the patch itself will contain no faces and
is removed.
patch 1
patch 2
region of internal connecting faces
region of external boundary faces
Figure 5.7: Merging overlapping patches
The consequence is that the original geometry of the slave patch will not necessarily be
completely preserved during merging. Therefore in a case, say, where a cylindrical block
is being connected to a larger block, it would be wise to the assign the master patch to the
cylinder, so that its cylindrical shape is correctly preserved. There are some additional
recommendations to ensure successful merge procedures:
• in 2 dimensional geometries, the size of the cells in the third dimension, i.e. out of
the 2D plane, should be similar to the width/height of cells in the 2D plane;
• it is inadvisable to merge a patch twice, i.e. include it twice in mergePatchPairs;
• where a patch to be merged shares a common edge with another patch to be merged,
both should be declared as a master patch.
5.3.3 Creating blocks with fewer than 8 vertices
It is possible to collapse one or more pair(s) of vertices onto each other in order to create
a block with fewer than 8 vertices. The most common example of collapsing vertices is
when creating a 6-sided wedge shaped block for 2-dimensional axi-symmetric cases that
use the wedge patch type described in section 5.2.2. The process is best illustrated by
using a simpliﬁed version of our example block shown in Figure 5.8. Let us say we wished
Open∇FOAM-1.5
U-136 Mesh generation and conversion
to create a wedge shaped block by collapsing vertex 7 onto 4 and 6 onto 5. This is simply
done by exchanging the vertex number 7 by 4 and 6 by 5 respectively so that the block
numbering would become:
hex (0 1 2 3 4 5 5 4)
0
3
4
7 6
5
1
2
Figure 5.8: Creating a wedge shaped block with 6 vertices
The same applies to the patches with the main consideration that the block face
containing the collapsed vertices, previously (4 5 6 7) now becomes (4 5 5 4). This
is a block face of zero area which creates a patch with no faces in the polyMesh, as the
user can see in a boundary ﬁle for such a case. The patch should be speciﬁed as empty
in the blockMeshDict and the boundary condition for any ﬁelds should consequently be
empty also.
5.3.4 Running blockMesh
As described in section 3.3, the following can be executed at the command line to run
blockMesh for a case in the <case> directory located at the path <path>:
blockMesh <path> <case>
The blockMeshDict ﬁle must exist in subdirectory constant/polyMesh.
5.4 Mesh generation with the snappyHexMesh utility
This section describes the mesh generation utility, snappyHexMesh, supplied with Open-
FOAM. The snappyHexMesh utility generates 3-dimensional meshes containing hexahedra
(hex) and split-hexahedra (split-hex) automatically from triangulated surface geometries
in Stereolithography (STL) format. The mesh approximately conforms to the surface
by iteratively reﬁning a starting mesh and morphing the resulting split-hex mesh to the
surface. An optional phase will shrink back the resulting mesh and insert cell layers. The
speciﬁcation of mesh reﬁnement level is very ﬂexible and the surface handling is robust
with a pre-speciﬁed ﬁnal mesh quality. It runs in parallel with a load balancing step every
iteration.
Open∇FOAM-1.5
5.4 Mesh generation with the snappyHexMesh utility U-137
STL surface
Figure 5.9: Schematic 2D meshing problem for snappyHexMesh
5.4.1 The mesh generation process of snappyHexMesh
The process of generating a mesh using snappyHexMesh will be described using the
schematic in Figure 5.9. The objective is to mesh a rectangular shaped region (shaded
grey in the ﬁgure) surrounding an object described by and STL surface, e.g. typical for
an external aerodynamics simulation. Note that the schematic is 2-dimensional to make
it easier to understand, even though the snappyHexMesh is a 3D meshing tool.
In order to run snappyHexMesh, the user requires the following:
• surface data ﬁles in STL format, either binary or ASCII, located in a triSurface
sub-directory of the case directory;
• a background hex mesh which deﬁnes the extent of the computational domain
and a base level mesh density; typically generated using blockMesh, discussed in
section 5.4.2.
• a snappyHexMeshDict dictionary, with appropriate entries, located in the system
sub-directory of the case.
The snappyHexMeshDict dictionary includes: switches at the top level that control the
various stages of the meshing process; and, individual sub-directories for each process.
The entries are listed in Table 5.7.
All the geometry used by snappyHexMesh is speciﬁed in a geometry sub-dictionary
in the snappyHexMeshDict dictionary. The geometry can be speciﬁed through an STL
surface or bounding geometry entities in OpenFOAM. An example is given below:
geometry
{
sphere.stl // STL filename
{
type triSurfaceMesh;
regions
{
secondSolid // Named region in the STL file
{
name mySecondPatch; // User-defined patch name
} // otherwise given sphere.stl_secondSolid
}
}
box1x1x1 // User defined region name
{
type searchableBox; // region defined by bounding box
min (1.5 1 -0.5);
Open∇FOAM-1.5
U-138 Mesh generation and conversion
Keyword Description Example
castellatedMesh Create the castellated mesh? true
snap Do the surface snapping stage? true
doLayers Add surface layers? true
mergeTolerance Merge tolerance as fraction of bounding box
of initial mesh
1e-06
debug Controls writing of intermediate meshes and
screen printing
— Write ﬁnal mesh only 0
— Write intermediate meshes 1
— Write volScalarField with cellLevel for
post-processing
2
— Write current intersections as .obj ﬁles 4
geometry Sub-dictionary of all surface geometry used
castellatedMeshControls Sub-dictionary of controls for castellated mesh
snapControls Sub-dictionary of controls for surface snapping
addLayersControls Sub-dictionary of controls for layer addition
meshQualityControls Sub-dictionary of controls for mesh quality
Table 5.7: Keywords at the top level of snappyHexMeshDict.
max (3.5 2 0.5);
}
sphere2 // User defined region name
{
type searchableSphere; // region defined by bounding sphere
centre (1.5 1.5 1.5);
radius 1.03;
}
};
5.4.2 Creating the background hex mesh
Before snappyHexMesh is executed the user must create a background mesh of hexahedral
cells that ﬁlls the entire region within by the external boundary as shown in Figure 5.10.
This can be done simply using blockMesh. The following criteria must be observed when
Figure 5.10: Initial mesh generation in snappyHexMesh meshing process
creating the background mesh:
Open∇FOAM-1.5
5.4 Mesh generation with the snappyHexMesh utility U-139
• the mesh must consist purely of hexes;
• the cell aspect ratio should be approximately 1, at least near surfaces at which
the subsequent snapping procedure is applied, otherwise the convergence of the
snapping procedure is slow, possibly to the point of failure;
• there must be at least one intersection of a cell edge with the STL surface, i.e. a
mesh of one cell will not work.
5.4.3 Cell splitting at feature edges and surfaces
Cell splitting is performed according to the speciﬁcation supplied by the user in the
castellatedMeshControls sub-dictionary in the snappyHexMeshDict. The entries for castel-
latedMeshControls are presented in Table 5.8.
Keyword Description Example
locationInMesh Location vector inside the region to be meshed (5 0 0)
N.B. vector must not coincide with a cell face either before
or during reﬁnement
maxLocalCells Max number of cells per processor during re-
ﬁnement
1e-06
maxGlobalCells Overall cell limit during reﬁnement (i.e. before
removal)
2e-06
minRefinementCells If ≥ number of cells to be reﬁned, surface re-
ﬁnement stops
0
nCellsBetweenLevels Number of buﬀer layers of cells between dif-
ferent levels of reﬁnement
1
resolveFeatureAngle Applies maximum level of reﬁnement to cells
that can see intersections whose angle exceeds
this
30
features List of features for reﬁnement
refinementSurfaces Dictionary of surfaces for reﬁnement
refinementRegions Dictionary of regions for reﬁnement
Table 5.8: Keywords in the castellatedMeshControls sub-dictionary of snappyHexMeshDict.
The splitting process begins with cells being selected according to speciﬁed edge fea-
tures ﬁrst within the domain as illustrated in Figure 5.11. The features list in the
castellatedMeshControls sub-dictionary permits dictionary entries containing a name of an
edgeMesh ﬁle and the level of reﬁnement, e.g.:
features
(
{
file "someLine.eMesh"; // file containing edge mesh
level 2; // level of refinement
}
);
Following feature reﬁnement, cells are selected for splitting in the locality of speciﬁed
surfaces as illustrated in Figure 5.12. The refinementSurfaces dictionary in castel-
latedMeshControls requires dictionary entries for each STL surface and a default level
speciﬁcation of the minimum and maximum reﬁnement in the form (<min> <max>).
Open∇FOAM-1.5
U-140 Mesh generation and conversion
Figure 5.11: Cell splitting by feature edge in snappyHexMesh meshing process
Figure 5.12: Cell splitting by surface in snappyHexMesh meshing process
The minimum level is applied generally across the surface; the maximum level is ap-
plied to cells that can see intersections that form an angle in excess of that speciﬁed by
resolveFeatureAngle.
The reﬁnement can optionally be overridden on one or more speciﬁc region of an STL
surface. The region entries are collected in a regions sub-dictionary. The keyword for
each region entry is the name of the region itself and the reﬁnement level is contained
within a further sub-dictionary. An example is given below:
refinementSurfaces
{
sphere.stl
{
level (2 2); // default (min max) refinement for whole surface
regions
{
secondSolid
{
level (3 3); // optional refinement for secondSolid region
}
}
}
}
5.4.4 Cell removal
Once the feature and surface splitting is complete a process of cell removal begins. Cell
removal requires one or more regions enclosed entirely by a bounding surface within the
Open∇FOAM-1.5
5.4 Mesh generation with the snappyHexMesh utility U-141
domain. The region in which cells are retained are simply identiﬁed by a location vector
within that region, speciﬁed by the locationInMesh keyword in castellatedMeshControls.
Cells are retained if, approximately speaking, 50% or more of their volume lies within the
region. The remaining cells are removed accordingly as illustrated in Figure 5.13.
Figure 5.13: Cell removal in snappyHexMesh meshing process
5.4.5 Cell splitting in speciﬁed regions
Those cells that lie within one or more speciﬁed volume regions can be further split as il-
lustrated in Figure 5.14 by a rectangular region shown by dark shading. The refinement-
Figure 5.14: Cell splitting by region in snappyHexMesh meshing process
Regions sub-dictionary in castellatedMeshControls contains entries for reﬁnement of the
volume regions speciﬁed in the geometry sub-dictionary. A reﬁnement mode is applied to
each region which can be:
• inside reﬁnes inside the volume region;
• outside reﬁnes outside the volume region
• distance reﬁnes according to distance to the surface; and can accommodate diﬀer-
ent levels at multiple distances with the levels keyword.
Open∇FOAM-1.5
U-142 Mesh generation and conversion
For the refinementRegions, the reﬁnement level is speciﬁed by the levels list of entries
with the format(<distance> <level>). In the case of inside and outside reﬁnement,
the <distance> is not required so is ignored (but it must be speciﬁed). Examples are
shown below:
refinementRegions
{
box1x1x1
{
mode inside;
levels ((1.0 4)); // refinement level 4 (1.0 entry ignored)
}
sphere.stl
{ // refinement level 5 within 1.0 m
mode distance; // refinement level 3 within 2.0 m
levels ((1.0 5) (2.0 3)); // levels must be ordered nearest first
}
}
5.4.6 Snapping to surfaces
The next stage of the meshing process involves moving cell vertex points onto surface
geometry to remove the jagged castellated surface from the mesh. The process is:
1. displace the vertices in the castellated boundary onto the STL surface;
2. solve for relaxation of the internal mesh with the latest displaced boundary vertices;
3. ﬁnd the vertices that cause mesh quality parameters to be violated;
4. reduce the displacement of those vertices from their initial value (at 1) and repeat
from 2 until mesh quality is satisﬁed.
The method uses the settings in the snapControls sub-dictionary in snappyHexMeshDict,
listed in Table 5.9. An example is illustrated in the schematic in Figure 5.15 (albeit with
Keyword Description Example
nSmoothPatch Number of patch smoothing iterations before
ﬁnding correspondence to surface
3
tolerance Ratio of distance for points to be attracted
by surface feature point or edge, to local
maximum edge length
4.0
nSolveIter Number of mesh displacement relaxation it-
erations
30
nRelaxIter Maximum number of snapping relaxation it-
erations
5
Table 5.9: Keywords in the snapControls dictionary of snappyHexMeshDict.
mesh motion that looks slightly unrealistic).
5.4.7 Mesh layers
The mesh output from the snapping stage may be suitable for the purpose, although it
can produce some irregular cells along boundary surfaces. There is an optional stage of
the meshing process which introduces additional layers of hexahedral cells aligned to the
boundary surface as illustrated by the dark shaded cells in Figure 5.16.
Open∇FOAM-1.5
5.4 Mesh generation with the snappyHexMesh utility U-143
Figure 5.15: Surface snapping in snappyHexMesh meshing process
Figure 5.16: Layer addition in snappyHexMesh meshing process
The process of mesh layer addition involves shrinking the existing mesh from the
boundary and inserting layers of cells, broadly as follows:
1. the mesh is projected back from the surface by a speciﬁed thickness in the direction
normal to the surface;
2. solve for relaxation of the internal mesh with the latest projected boundary vertices;
3. check if validation criteria are satisﬁed otherwise reduce the projected thickness and
return to 2; if validation cannot be satisﬁed for any thickness, do not insert layers;
4. if the validation criteria can be satisﬁed, insert mesh layers;
5. the mesh is checked again; if the checks fail, layers are removed and we return to 2.
The layer addition procedure uses the settings in the addLayersControls sub-dictionary
in snappyHexMeshDict; entries are listed in Table 5.10. The layers sub-dictionary con-
tains entries for each patch on which the layers are to be applied and the number of
surface layers required. The patch name is used because the layers addition relates to the
existing mesh, not the surface geometry; hence applied to a patch, not a surface region.
An example layers entry is as follows:
layers
{
sphere.stl_firstSolid
Open∇FOAM-1.5
U-144 Mesh generation and conversion
Keyword Description Example
layers Dictionary of layers
expansionRatio Expansion factor for layer mesh 1.0
finalLayerRatio Thickness of layer furthest from the wall relative
to undistorted cell size outside layer
0.3
minThickness Minimum thickness of cell layer relative to undis-
torted cell size outside layer
0.25
nGrow Number of layers of connected faces that are not
grown if points get not extruded; helps conver-
gence of layer addition close to features
1
featureAngle Angle above which surface is not extruded 60
nRelaxIter Maximum number of snapping relaxation itera-
tions
5
nSmoothSurfaceNormals Number of smoothing iterations of surface nor-
mals
1
nSmoothNormals Number of smoothing iterations of interior mesh
movement direction
3
nSmoothThickness Smooth layer thickness over surface patches 10
maxFaceThicknessRatio Stop layer growth on highly warped cells 0.5
maxThicknessTo-
MedialRatio
Reduce layer growth where ratio thickness to me-
dial distance is large
0.3
minMedianAxisAngle Angle used to pick up medial axis points 130
nBufferCellsNoExtrude Create buﬀer region for new layer terminations 0
Table 5.10: Keywords in the addLayersControls sub-dictionary of snappyHexMeshDict.
{
nSurfaceLayers 1;
}
maxY
{
nSurfaceLayers 1;
}
}
5.4.8 Mesh quality controls
The mesh quality is controlled by the entries in the meshQualityControls sub-dictionary
in snappyHexMeshDict; entries are listed in Table 5.11.
5.5 Mesh conversion
The user can generate meshes using other packages and convert them into the format
that OpenFOAM uses. The mesh conversion codes have the naming convention available
mesh converters are:
ﬂuentMeshToFoam reads a Fluent.msh mesh ﬁle, working for both 2-D and 3-D cases;
starToFoam reads STAR-CDPROSTAR mesh ﬁles.
gambitToFoam reads a GAMBIT.neu neutral ﬁle;
Open∇FOAM-1.5
5.5 Mesh conversion U-145
Keyword Description Example
maxNonOrtho Maximum non-orthogonality allowed; 180 dis-
ables
65
maxBoundarySkewness Max boundary face skewness allowed; <0 dis-
ables
20
maxInternalSkewness Max internal face skewness allowed; <0 disables 4
maxConcave Max concaveness allowed; 180 disables 80
minFlatness Ratio of minimum projected area to actual area;
-1 disables
0.5
minVol Minimum pyramid volume; large negative num-
ber, e.g.-1e30 disables
1e-13
minArea Minimum face area; <0 disables -1
minTwist Minimum face twist; <-1 disables 0.05
minDeterminant Minimum normalised cell determinant; 1 = hex;
≤ 0 illegal cell
0.001
minFaceWeight 0→0.5 0.05
minVolRatio 0→1.0 0.01
minTriangleTwist >0 for Fluent compatability -1
nSmoothScale Number of error distribution iterations 4
errorReduction Amount to scale back displacement at error
points
0.75
Table 5.11: Keywords in the meshQualityControls sub-dictionary of snappyHexMeshDict.
ideasToFoam reads an I-DEAS mesh written in ANSYS.ans format;
cfxToFoam reads a CFX mesh written in .geo format;
5.5.1 ﬂuentMeshToFoam
Fluent writes mesh data to a single ﬁle with a .msh extension. The ﬁle must be written
in ASCII format, which is not the default option in Fluent. It is possible to convert
single-stream Fluent meshes, including the 2 dimensional geometries. In OpenFOAM, 2
dimensional geometries are currently treated by deﬁning a mesh in 3 dimensions, where
the front and back plane are deﬁned as the empty boundary patch type. When reading
a 2 dimensional Fluent mesh, the converter automatically extrudes the mesh in the third
direction and adds the empty patch, naming it frontAndBackPlanes.
The following features should also be observed.
• The OpenFOAM converter will attempt to capture the Fluent boundary condition
deﬁnition as much as possible; however, since there is no clear, direct correspondence
between the OpenFOAM and Fluent boundary conditions, the user should check the
boundary conditions before running a case.
• Creation of axi-symmetric meshes from a 2 dimensional mesh is currently not sup-
ported but can be implemented on request.
• Multiple material meshes are not permitted. If multiple ﬂuid materials exist, they
will be converted into a single OpenFOAM mesh; if a solid region is detected, the
converter will attempt to ﬁlter it out.
Open∇FOAM-1.5
U-146 Mesh generation and conversion
• Fluent allows the user to deﬁne a patch which is internal to the mesh, i.e. consists
of the faces with cells on both sides. Such patches are not allowed in OpenFOAM
and the converter will attempt to ﬁlter them out.
• There is currently no support for embedded interfaces and reﬁnement trees.
The procedure of converting a Fluent.msh ﬁle is ﬁrst to create a new OpenFOAM case
by creating the necessary directories/ﬁles: the case directory containing a controlDict ﬁle
in a system subdirectory. Then at a command prompt the user should execute:
fluentMeshToFoam <meshFile>
where <meshFile> is the name of the .msh ﬁle, including the full or relative path.
5.5.2 starToFoam
This section describes how to convert a mesh generated on the STAR-CD code into a form
that can be read by OpenFOAM mesh classes. The mesh can be generated by any of the
packages supplied with STAR-CD, i.e.PROSTAR, SAMM, ProAM and their derivatives.
The converter accepts any single-stream mesh including integral and arbitrary couple
matching and all cell types are supported. The features that the converter does not
support are:
• multi-stream mesh speciﬁcation;
• baﬄes, i.e. zero-thickness walls inserted into the domain;
• partial boundaries, where an uncovered part of a couple match is considered to be
a boundary face;
• sliding interfaces.
For multi-stream meshes, mesh conversion can be achieved by writing each individual
stream as a separate mesh and reassemble them in OpenFOAM.
OpenFOAM adopts a policy of only accepting input meshes that conform to the
fairly stringent validity criteria speciﬁed in section 5.1. It will simply not run using
invalid meshes and cannot convert a mesh that is itself invalid. The following sections
describe steps that must be taken when generating a mesh using a mesh generating
package supplied with STAR-CD to ensure that it can be converted to OpenFOAM format.
To avoid repetition in the remainder of the section, the mesh generation tools supplied
with STAR-CD will be referred to by the collective name STAR-CD.
5.5.2.1 General advice on conversion
We strongly recommend that the user run the STAR-CD mesh checking tools before
attempting a starToFoam conversion and, after conversion, the checkMesh utility should
be run on the newly converted mesh. Alternatively, starToFoam may itself issue warnings
containing PROSTAR commands that will enable the user to take a closer look at cells with
problems. Problematic cells and matches should be checked and ﬁxed before attempting
to use the mesh with OpenFOAM. Remember that an invalid mesh will not run with
OpenFOAM, but it may run in another environment that does not impose the validity
criteria.
Some problems of tolerance matching can be overcome by the use of a matching
tolerance in the converter. However, there is a limit to its eﬀectiveness and an apparent
need to increase the matching tolerance from its default level indicates that the original
mesh suﬀers from inaccuracies.
Open∇FOAM-1.5
5.5 Mesh conversion U-147
5.5.2.2 Eliminating extraneous data
When mesh generation in is completed, remove any extraneous vertices and compress the
cells boundary and vertex numbering, assuming that ﬂuid cells have been created and all
other cells are discarded. This is done with the following PROSTAR commands:
CSET NEWS FLUID
CSET INVE
The CSET should be empty. If this is not the case, examine the cells in CSET and adjust
the model. If the cells are genuinely not desired, they can be removed using the PROSTAR
command:
CDEL CSET
Similarly, vertices will need to be discarded as well:
CSET NEWS FLUID
VSET NEWS CSET
VSET INVE
Before discarding these unwanted vertices, the unwanted boundary faces have to be col-
lected before purging:
CSET NEWS FLUID
VSET NEWS CSET
BSET NEWS VSET ALL
BSET INVE
If the BSET is not empty, the unwanted boundary faces can be deleted using:
BDEL BSET
At this time, the model should contain only the ﬂuid cells and the supporting vertices,
as well as the deﬁned boundary faces. All boundary faces should be fully supported by the
vertices of the cells, if this is not the case, carry on cleaning the geometry until everything
is clean.
5.5.2.3 Removing default boundary conditions
By default, STAR-CD assigns wall boundaries to any boundary faces not explicitly associ-
ated with a boundary region. The remaining boundary faces are collected into a default
boundary region, with the assigned boundary type 0. OpenFOAM deliberately does not
have a concept of a default boundary condition for undeﬁned boundary faces since it
invites human error, e.g. there is no means of checking that we meant to give all the
unassociated faces the default condition.
Therefore all boundaries for each OpenFOAM mesh must be speciﬁed for a mesh to
be successfully converted. The default boundary needs to be transformed into a real
one using the procedure described below:
1. Plot the geometry with Wire Surface option.
Open∇FOAM-1.5
U-148 Mesh generation and conversion
2. Deﬁne an extra boundary region with the same parameters as the default region
0 and add all visible faces into the new region, say 10, by selecting a zone option
in the boundary tool and drawing a polygon around the entire screen draw of the
model. This can be done by issuing the following commands in PROSTAR:
RDEF 10 WALL
BZON 10 ALL
3. We shall remove all previously deﬁned boundary types from the set. Go through
the boundary regions:
BSET NEWS REGI 1
BSET NEWS REGI 2
... 3, 4, ...
Collect the vertices associated with the boundary set and then the boundary faces
associated with the vertices (there will be twice as many of them as in the original
set).
BSET NEWS REGI 1
VSET NEWS BSET
BSET NEWS VSET ALL
BSET DELE REGI 1
REPL
This should give the faces of boundary Region 10 which have been deﬁned on top
of boundary Region 1. Delete them with BDEL BSET. Repeat these for all regions.
5.5.2.4 Renumbering the model
Renumber and check the model using the commands:
CSET NEW FLUID
CCOM CSET
VSET NEWS CSET
VSET INVE (Should be empty!)
VSET INVE
VCOM VSET
BSET NEWS VSET ALL
BSET INVE (Should be empty also!)
BSET INVE
BCOM BSET
CHECK ALL
GEOM
Internal PROSTAR checking is performed by the last two commands, which may reveal
some other unforeseeable error(s). Also, take note of the scaling factor because PROSTAR
only applies the factor for STAR-CD and not the geometry. If the factor is not 1, use the
scalePoints utility in OpenFOAM.
Open∇FOAM-1.5
5.5 Mesh conversion U-149
5.5.2.5 Writing out the mesh data
Once the mesh is completed, place all the integral matches of the model into the couple
type 1. All other types will be used to indicate arbitrary matches.
CPSET NEWS TYPE INTEGRAL
CPMOD CPSET 1
The components of the computational grid must then be written to their own ﬁles. This
is done using PROSTAR for boundaries by issuing the command
BWRITE
by default, this writes to a .23 ﬁle (versions prior to 3.0) or a .bnd ﬁle (versions 3.0 and
higher). For cells, the command
CWRITE
outputs the cells to a .14 or .cel ﬁle and for vertices, the command
VWRITE
outputs to ﬁle a .15 or .vrt ﬁle. The current default setting writes the ﬁles in ASCII
format. If couples are present, an additional couple ﬁle with the extension .cpl needs to
be written out by typing:
CPWRITE
After outputting to the three ﬁles, exit PROSTAR or close the ﬁles. Look through
the panels and take note of all STAR-CD sub-models, material and ﬂuid properties used
– the material properties and mathematical model will need to be set up by creating and
editing OpenFOAM dictionary ﬁles.
The procedure of converting the PROSTAR ﬁles is ﬁrst to create a new OpenFOAM
case by creating the necessary directories. The PROSTAR ﬁles must be stored within the
same directory and the user must change the ﬁle extensions: from .23, .14 and .15 (below
STAR-CD version 3.0), or .pcs, .cls and .vtx (STAR-CD version 3.0 and above); to .bnd,
.cel and .vrt respectively.
5.5.2.6 Problems with the .vrt ﬁle
The .vrt ﬁle is written in columns of data of speciﬁed width, rather than free format. A
typical line of data might be as follows, giving a vertex number followed by the coordi-
nates:
19422 -0.105988957 -0.413711881E-02 0.000000000E+00
If the ordinates are written in scientiﬁc notation and are negative, there may be no space
between values, e.g.:
19423 -0.953953117E-01-0.338810333E-02 0.000000000E+00
Open∇FOAM-1.5
U-150 Mesh generation and conversion
The starToFoam converter reads the data using spaces to delimit the ordinate values and
will therefore object when reading the previous example. Therefore, OpenFOAM includes
a simple script, foamCorrectVrt to insert a space between values where necessary, i.e. it
would convert the previous example to:
19423 -0.953953117E-01 -0.338810333E-02 0.000000000E+00
The foamCorrectVrt script should therefore be executed if necessary before running the
starToFoam converter, by typing:
foamCorrectVrt <file>.vrt
5.5.2.7 Converting the mesh to OpenFOAM format
The translator utility starToFoam can now be run to create the boundaries, cells and
points ﬁles necessary for a OpenFOAM run:
starToFoam <meshFilePrefix>
where <meshFilePreﬁx> is the name of the the preﬁx of the mesh ﬁles, including the
full or relative path. After the utility has ﬁnished running, OpenFOAM boundary types
should be speciﬁed by editing the boundary ﬁle by hand.
5.5.3 gambitToFoam
GAMBIT writes mesh data to a single ﬁle with a .neu extension. The procedure of con-
verting a GAMBIT.neu ﬁle is ﬁrst to create a new OpenFOAM case, then at a command
prompt, the user should execute:
gambitToFoam <meshFile>
where <meshFile> is the name of the .neu ﬁle, including the full or relative path.
The GAMBIT ﬁle format does not provide information about type of the boundary
patch, e.g. wall, symmetry plane, cyclic. Therefore all the patches have been created as
type patch. Please reset after mesh conversion as necessary.
5.5.4 ideasToFoam
OpenFOAM can convert a mesh generated by I-DEAS but written out in ANSYS format
as a .ans ﬁle. The procedure of converting the .ans ﬁle is ﬁrst to create a new OpenFOAM
case, then at a command prompt, the user should execute:
ideasToFoam <meshFile>
where <meshFile> is the name of the .ans ﬁle, including the full or relative path.
Open∇FOAM-1.5
5.6 Mapping ﬁelds between diﬀerent geometries U-151
5.5.5 cfxToFoam
CFX writes mesh data to a single ﬁle with a .geo extension. The mesh format in CFX is
block-structured, i.e. the mesh is speciﬁed as a set of blocks with glueing information and
the vertex locations. OpenFOAM will convert the mesh and capture the CFX boundary
condition as best as possible. The 3 dimensional ‘patch’ deﬁnition in CFX, containing
information about the porous, solid regions etc. is ignored with all regions being converted
into a single OpenFOAM mesh. CFX supports the concept of a ‘default’ patch, where
each external face without a deﬁned boundary condition is treated as a wall. These faces
are collected by the converter and put into a defaultFaces patch in the OpenFOAM
mesh and given the type wall; of course, the patch type can be subsequently changed.
Like, OpenFOAM 2 dimensional geometries in CFX are created as 3 dimensional
meshes of 1 cell thickness [**]. If a user wishes to run a 2 dimensional case on a mesh
created by CFX, the boundary condition on the front and back planes should be set to
empty; the user should ensure that the boundary conditions on all other faces in the
plane of the calculation are set correctly. Currently there is no facility for creating an
axi-symmetric geometry from a 2 dimensional CFX mesh.
The procedure of converting a CFX.geo ﬁle is ﬁrst to create a new OpenFOAM case,
then at a command prompt, the user should execute:
cfxToFoam <meshFile>
where <meshFile> is the name of the .geo ﬁle, including the full or relative path.
5.6 Mapping ﬁelds between diﬀerent geometries
The mapFields utility maps one or more ﬁelds relating to a given geometry onto the
corresponding ﬁelds for another geometry. It is completely generalised in so much as
there does not need to be any similarity between the geometries to which the ﬁelds relate.
However, for cases where the geometries are consistent, mapFields can be executed with
a special option that simpliﬁes the mapping process.
For our discussion of mapFields we need to deﬁne a few terms. First, we say that
the data is mapped from the source to the target. The ﬁelds are deemed consistent if
the geometry and boundary types, or conditions, of both source and target ﬁelds are
identical. The ﬁeld data that mapFields maps are those ﬁelds within the time directory
speciﬁed by startFrom/startTime in the controlDict of the target case. The data is read
from the equivalent time directory of the source case and mapped onto the equivalent
time directory of the target case.
5.6.1 Mapping consistent ﬁelds
A mapping of consistent ﬁelds is simply performed by executing mapFields on the (target)
case using the -consistent command line option as follows:
mapFields <source dir> -consistent
5.6.2 Mapping inconsistent ﬁelds
When the ﬁelds are not consistent, as shown in Figure 5.17, mapFields requires a map-
FieldsDict dictionary in the system directory of the target case. The following rules apply
to the mapping:
Open∇FOAM-1.5
U-152 Mesh generation and conversion
• the ﬁeld data is mapped from source to target wherever possible, i.e. in our example
all the ﬁeld data within the target geometry is mapped from the source, except those
in the shaded region which remain unaltered;
• the patch ﬁeld data is left unaltered unless speciﬁed otherwise in the mapFieldsDict
dictionary.
The mapFieldsDict dictionary contain two lists that specify mapping of patch data. The
ﬁrst list is patchMap that speciﬁes mapping of data between pairs of source and target
patches that are geometrically coincident, as shown in Figure 5.17. The list contains
each pair of names of source and target patch. The second list is cuttingPatches that
contains names of target patches whose values are to be mapped from the source internal
ﬁeld through which the target patch cuts. In the situation where the target patch only
cuts through part of the source internal ﬁeld, e.g. bottom left target patch in our example,
those values within the internal ﬁeld are mapped and those outside remain unchanged.
An example mapFieldsDict dictionary is shown below:
Internal target patches:
can be mapped using cuttingPatches
Target ﬁeld geometry
Source ﬁeld geometry
can be mapped using patchMap
Coincident patches:
Figure 5.17: Mapping inconsistent ﬁelds
17 patchMap
18 (
19 lid movingWall
20 );
21
22 cuttingPatches
23 (
24 fixedWalls
25 );
26
27 // ************************************************************************* //
mapFields <source dir>
Open∇FOAM-1.5
5.6 Mapping ﬁelds between diﬀerent geometries U-153
5.6.3 Mapping parallel cases
If either or both of the source and target cases are decomposed for running in parallel,
additional options must be supplied when executing mapFields:
-parallelSource if the source case is decomposed for parallel running;
-parallelTarget if the target case is decomposed for parallel running.
Open∇FOAM-1.5
U-154 Mesh generation and conversion
Open∇FOAM-1.5
Chapter 6
Post-processing
This chapter describes options for post-processing with OpenFOAM. OpenFOAM is sup-
plied with a post-processing utility paraFoam that uses ParaView, an open source visuali-
sation application described in section 6.1.
Other methods of post-processing using third party products are oﬀered, including
EnSight, AVS/Express and the post-processing supplied with Fluent.
6.1 paraFoam
The main post-processing tool provided with OpenFOAM is the a reader module to run
with ParaView, an open-source, visualization application. The module is compiled into
2 libraries, PV3FoamReader and vtkPV3Foam using version 3.3-dev of ParaView supplied
with the OpenFOAM release (PVFoamReader and vtkFoam in ParaView version 2.x). It
is recommended that this version of ParaView is used, although it is possible that the
latest binary release of the software will run adequately. Further details about ParaView
can be found at http://www.paraview.org and further documentation is available at
http://www.kitware.com/products/paraviewguide.html.
ParaView uses the Visualisation Toolkit (VTK) as its data processing and rendering
engine and can therefore read any data in VTK format. OpenFOAM includes the foam-
ToVTK utility to convert data from its native format to VTK format, which means that
any VTK-based graphics tools can be used to post-process OpenFOAM cases. This pro-
vides an alternative means for using ParaView with OpenFOAM. For users who wish
to experiment with advanced, parallel visualisation, there is also the free VisIt software,
available at http://www.llnl.gov/visit.
In summary, we recommend the reader module for ParaView as the primary post-
processing tool for OpenFOAM. Alternatively OpenFOAM data can be converted into
VTK format to be read by ParaView or any other VTK -based graphics tools.
6.1.1 Overview of paraFoam
paraFoam is strictly a script that launches ParaView using the reader module supplied
with OpenFOAM. It is executed like any of the OpenFOAM utilities either by the single
command from within the case directory or with the -case option with the case path as
an argument, e.g.:
paraFoam -case <caseDir>
ParaView is launched and opens the window shown in Figure 6.1. The case is controlled
from the left panel, which contains the following:
U-156 Post-processing
Figure 6.1: The paraFoam window
Pipeline Browser lists the modules opened in ParaView, where the selected modules are
highlighted in blue and the graphics for the given module can be enabled/disabled
by clicking the eye button alongside;
Properties panel contains the input selections for the case, such as times, regions and
ﬁelds;
Display panel controls the visual representation of the selected module, e.g. colours;
Information panel gives case statistics such as mesh geometry and size.
ParaView operates a tree-based structure in which data can be ﬁltered from the top-
level case module to create sets of sub-modules. For example, a contour plot of, say,
pressure could be a sub-module of the case module which contains all the pressure data.
The strength of ParaView is that the user can create a number of sub-modules and display
whichever ones they feel to create the desired image or animation. For example, they
may add some solid geometry, mesh and velocity vectors, to a contour plot of pressure,
switching any of the items on and oﬀ as necessary.
The general operation of the system is based on the user making a selection and then
clicking the green Apply button in the Properties panel. The additional buttons are: the
Reset button which used to reset the GUI if necessary; and, the Delete button that will
delete the active module.
6.1.2 The Properties panel
The Properties panel for the case module contains the settings for time step, regions and
ﬁelds. The controls are described in Figure 6.2. It is particularly worth noting that
Open∇FOAM-1.5
6.1 paraFoam U-157
The user can select internalMesh
region and/or individual patches
read into the case module
The user can select the ﬁelds
Figure 6.2: The Properties panel for the case module
in the current reader module, data in all time directories are loaded into ParaView (in
the reader module for ParaView 2.x, a set of check boxes controlled the time that were
displayed). In the current reader module, the buttons in the Current Time Controls
and VCR Controls toolbars select the time data to be displayed, as shown is section 6.1.4.
As with any operation in paraFoam, the user must click Apply after making any changes
to any selections. The Apply button is highlighted in green to alert the user if changes have
been made but not accepted. This method of operation has the advantage of allowing the
user to make a number of selections before accepting them, which is particularly useful
in large cases where data processing is best kept to a minimum.
There are occasions when the case data changes on ﬁle and ParaView needs to load the
changes, e.g. when ﬁeld data is written into new time directories. To load the changes,
the user should check the Update GUI button at the top of the Properties panel and then
apply the changes.
6.1.3 The Display panel
The Display panel contains the settings for visualising the data for a given case module.
The following points are particularly important:
• the data range may not be automatically updated to the max/min limits of a ﬁeld,
so the user should take care to select Rescale to Data Range at appropriate intervals,
in particular after loading the initial case module;
• clicking the Edit Color Map button, brings up a window in which there are two
panels:
Open∇FOAM-1.5
U-158 Post-processing
Outline, surface, wireframe or points
Data interpolation method
Change image opacity
e.g. to make transluscent
View case data
Colour geometry/entity by. . .
Set colour map range/appearance
Geometry manipulation tools
Figure 6.3: The Display panel
1. The Color Scale panel in which the colours within the scale can be chosen. The
standard blue to red colour scale for CFD can be selected by clicking Choose
Preset and selecting Blue to Red Rainbox HSV.
2. The Color Legend panel has a toggle switch for a colour bar legend and contains
settings for the layout of the legend, e.g. font.
• the underlying mesh can be represented by selecting Wireframe in the Represent-
ation menu of the Style panel;
• the geometry, e.g. a mesh (if Wireframe is selected), can be visualised as a single
colour by selecting Solid Color from the Color By menu and specifying the colour
in the Set Solid Color window;
Open∇FOAM-1.5
6.1 paraFoam U-159
• the image can be made translucent by editing the value in the Opacity text box (1
= solid, 0 = invisible) in the Style panel.
6.1.4 The button toolbars
ParaView duplicates functionality from pull-down menus at the top of the main window
and the major panels, within the toolbars below the main pull-down menus. The displayed
toolbars can be selected from Toolbars in the main View menu. The default layout with
all toolbars is shown in Figure 6.4 with each toolbar labelled. The function of many of
the buttons is clear from their icon and, with tooltips enabled in the Help menu, the user
is given a concise description of the function of any button.
Selection Controls VCR Controls
Common Filters Camera Controls
Centre Axes Controls
Undo/Redo ControlsMain controls Current Time Controls
Active Variable Controls | Representation
Figure 6.4: Toolbars in ParaView
6.1.5 Manipulating the view
This section describes operations for setting and manipulating the view of objects in
paraFoam.
6.1.5.1 View settings
The View Settings are selected from the Edit menu, which opens a Render View Options
window with a table of 3 items: General, Lights and Annotation. The General panel includes
the following items which are often worth setting at startup:
• the background colour, where white is often a preferred choice for printed material;
• Use parallel projection which is the usual choice for CFD, especially for 2D cases;
The Lights panel contains detailed lighting controls within the Light Kit panel. A
separate Headlight panel controls the direct lighting of the image. Checking the Headlight
button with white light colour of strength 1 seems to help produce images with strong
bright colours, e.g. with an isosurface.
The Annotation panel includes options for including annotations in the image. The
Orientation Axes feature controls an axes icon in the image window, e.g. to set the colour
of the axes labels x, y and z.
6.1.5.2 General settings
The general Settings are selected from the Edit menu, which opens a general Options
window with General and Render View menu items.
The General panel controls some default behaviour of ParaView. In particular, there
is an Auto Accept button that enables ParaView to accept changes automatically without
Open∇FOAM-1.5
U-160 Post-processing
clicking the green Apply button in the Properties window. For larger cases, this option is
generally not recommended: the user does not generally want the image to be re-rendered
between each of a number of changes he/she selects, but be able to apply a number of
changes to be re-rendered in their entirety once.
The Render View panel contains 3 sub-items: General, Camera and Server. The General
panel includes the level of detail (LOD) which controls the rendering of the image while it
is being manipulated, e.g. translated, resized, rotated; lowering the levels set by the sliders,
allows cases with large numbers of cells to be re-rendered quickly during manipulation.
The Camera panel includes control settings for 3D and 2D movements. This presents
the user with a map of rotation, translate and zoom controls using the mouse in combi-
nation with Shift- and Control-keys. The map can be edited to suit by the user.
6.1.6 Contour plots
A contour plot is created by selecting Contour from the Filter menu at the top menu
bar. The ﬁlter acts on a given module so that, if the module is the 3D case module itself,
the contours will be a set of 2D surfaces that represent a constant value, i.e. isosurfaces.
The Properties panel for contours contains an Isosurfaces list that the user can edit, most
conveniently by the New Range window. The chosen scalar ﬁeld is selected from a pull
down menu.
6.1.6.1 Introducing a cutting plane
Very often a user will wish to create a contour plot across a plane rather than producing
isosurfaces. To do so, the user must ﬁrst use the Slice ﬁlter to create the cutting plane,
on which the contours can be plotted. The Slice ﬁlter allows the user to specify a cutting
Plane, Box or Sphere in the Slice Type menu by a center and normal/radius respectively.
The user can manipulate the cutting plane like any other using the mouse.
The user can then run the Contour ﬁlter on the cut plane to generate contour lines.
6.1.7 Vector plots
Vector plots are created using the Glyph ﬁlter. The ﬁlter reads the ﬁeld selected in
Vectors and oﬀers a range of Glyph Types for which the Arrow provides a clear vector
plot images. Each glyph has a selection of graphical controls in a panel which the user
can manipulate to best eﬀect.
The remainder of the Properties panel contains mainly the Scale Mode menu for the
glyphs. The most common options are Scale Mode are: Vector, where the glyph length
is proportional to the vector magnitude; and, Off where each glyph is the same length.
The Set Scale Factor parameter controls the base length of the glyphs.
6.1.7.1 Plotting at cell centres
Vectors are by default plotted on cell vertices but, very often, we wish to plot data at cell
centres. This is done by ﬁrst applying the Cell Centers ﬁlter to the case module, and
then applying the Glyph ﬁlter to the resulting cell centre data.
6.1.8 Streamlines
Streamlines are created by ﬁrst creating tracer lines using the Stream Tracer ﬁlter. The
tracer Seed panel speciﬁes a distribution of tracer points over a Line Source or Point
Open∇FOAM-1.5
6.1 paraFoam U-161
Cloud. The user can view the tracer source, e.g. the line, but it is displayed in white, so
they may need to change the background colour in order to see it.
The distance the tracer travels and the length of steps the tracer takes are speciﬁed in
the text boxes in the main Stream Tracer panel. The process of achieving desired tracer
lines is largely one of trial and error in which the tracer lines obviously appear smoother
as the step length is reduced but with the penalty of a longer calculation time.
Once the tracer lines have been created, the Tubes ﬁlter can be applied to the Tracer
module to produce high quality images. The tubes follow each tracer line and are not
strictly cylindrical but have a ﬁxed number of sides and given radius. When the number
of sides is set above, say, 10, the tubes do however appear cylindrical, but again this adds
a computational cost.
6.1.9 Image output
The simplest way to output an image to ﬁle from ParaView is to select Save Screenshot
from the File menu. On selection, a window appears in which the user can select the
resolution for the image to save. There is a button that, when clicked, locks the aspect
ratio, so if the user changes the resolution in one direction, the resolution is adjusted in
the other direction automatically. After selecting the pixel resolution, the image can be
saved. To achieve high quality output, the user might try setting the pixel resolution to
1000 or more in the x-direction so that when the image is scaled to a typical size of a
ﬁgure in an A4 or US letter document, perhaps in a PDF document, the resolution is
sharp.
6.1.10 Animation output
To create an animation, the user should ﬁrst select Save Animation from the File menu.
A dialogue window appears in which the user can specify a number of things including
the image resolution. The user should specify the resolution as required. The other
noteworthy setting is number of frames per timestep. While this would intuitively be
set to 1, it can be set to a larger number in order to introduce more frames into the
animation artiﬁcially. This technique can be particularly useful to produce a slower
animation because some movie players have limited speed control, particularly over mpeg
movies.
On clicking the Save Animation button, another window appears in which the user spec-
iﬁes a ﬁle name root and ﬁle format for a set of images. On clicking OK, the set of ﬁles will
be saved according to the naming convention “<fileRoot> <imageNo>.<fileExt>”,
e.g. the third image of a series with the ﬁle root “animation”, saved in jpg format would
be named “animation 0002.jpg” (<imageNo> starts at 0000).
Once the set of images are saved the user can convert them into a movie using their
software of choice. The convert utility in the ImageMagick package can do this from the
command line, e.g. by
convert animation*jpg movie.mpg
When creating an mpg movie it can be worth increasing the default quality setting, e.g.
with -quality 90%, to reduce the graininess that can occur with the default setting.
Open∇FOAM-1.5
U-162 Post-processing
6.2 Post-processing with Fluent
It is possible to use Fluent as a post-processor for the cases run in OpenFOAM. Two con-
verters are supplied for the purpose: foamMeshToFluent which converts the OpenFOAM
mesh into Fluent format and writes it out as a .msh ﬁle; and, foamDataToFluent con-
verts the OpenFOAM results data into a .dat ﬁle readable by Fluent. foamMeshToFluent
is executed in the usual manner. The resulting mesh is written out in a ﬂuentInterface
subdirectory of the case directory, i.e.<caseName>/ﬂuentInterface/<caseName>.msh
foamDataToFluent converts the OpenFOAM data results into the Fluent format. The
conversion is controlled by two ﬁles. First, the controlDict dictionary speciﬁes startTime,
giving the set of results to be converted. If you want to convert the latest result,
startFrom can be set to latestTime. The second ﬁle which speciﬁes the translation
is the foamDataToFluentDict dictionary, located in the constant directory. An example
foamDataToFluentDict dictionary is given below:
1 /*--------------------------------*- C++ -*----------------------------------*\
2 | ========= | |
3 | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox |
4 | \\ / O peration | Version: 1.5 |
5 | \\ / A nd | Web: http://www.OpenFOAM.org |
6 | \\/ M anipulation | |
7 \*---------------------------------------------------------------------------*/
8 FoamFile
9 {
10 version 2.0;
11 format ascii;
12 class dictionary;
13 object foamDataToFluentDict;
14 }
15 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
16
17 p 1;
18
19 U 2;
20
21 T 3;
22
23 h 4;
24
25 k 5;
26
27 epsilon 6;
28
29 gamma 150;
30
31 // ************************************************************************* //
The dictionary contains entries of the form
<fieldName> <fluentUnitNumber>
The <fluentUnitNumber> is a label used by the Fluent post-processor that only recog-
nises a ﬁxed set of ﬁelds. The basic set of <fluentUnitNumber> numbers are quoted in
Table 6.1. The dictionary must contain all the entries the user requires to post-process,
e.g. in our example we have entries for pressure p and velocity U. The list of default entries
described in Table 6.1. The user can run foamDataToFluent like any utility.
To view the results using Fluent, go to the ﬂuentInterface subdirectory of the case
directory and start a 3 dimensional version of Fluent with
fluent 3d
The mesh and data ﬁles can be loaded in and the results visualised. The mesh is read
by selecting Read Case from the File menu. Support items should be selected to read
certain data types, e.g. to read turbulence data for k and epsilon, the user would select
Open∇FOAM-1.5
6.3 Post-processing with Fieldview U-163
Fluent name Unit number Common OpenFOAM name
PRESSURE 1 p
MOMENTUM 2 U
TEMPERATURE 3 T
ENTHALPY 4 h
TKE 5 k
TED 6 epsilon
SPECIES 7 —
G 8 —
XF RF DATA VOF 150 gamma
TOTAL PRESSURE 192 —
TOTAL TEMPERATURE 193 —
Table 6.1: Fluent unit numbers for post-processing.
k-epsilon from the Define->Models->Viscous menu. The data can then be read by
selecting Read Data from the File menu.
A note of caution: users MUST NOT try to use an original Fluent mesh ﬁle that has
been converted to OpenFOAM format in conjunction with the OpenFOAM solution that
has been converted to Fluent format since the alignment of zone numbering cannot be
guaranteed.
6.3 Post-processing with Fieldview
OpenFOAM oﬀers the capability for post-processing OpenFOAM cases with Fieldview.
The method involves running a post-processing utility foamToFieldview to convert case
data from OpenFOAM to Fieldview.uns ﬁle format. For a given case, foamToFieldview is
executed like any normal application. foamToFieldview creates a directory named Fieldview
in the case directory, deleting any existing Fieldview directory in the process. By default
the converter reads the data in all time directories and writes into a set of ﬁles of the
form <case> nn.uns, where nn is an incremental counter starting from 1 for the ﬁrst time
directory, 2 for the second and so on. The user may specify the conversion of a single time
directory with the option -time <time>, where <time> is a time in general, scientiﬁc
or ﬁxed format.
Fieldview provides certain functions that require information about boundary condi-
tions, e.g. drawing streamlines that uses information about wall boundaries. The con-
verter tries, wherever possible, to include this information in the converted ﬁles by default.
The user can disable the inclusion of this information by using the -noWall option in the
execution command.
The data ﬁles for Fieldview have the .uns extension as mentioned already. If the original
OpenFOAM case includes a dot ‘.’, Fieldview may have problems interpreting a set of data
ﬁles as a single case with multiple time steps.
6.4 Post-processing with EnSight
OpenFOAM oﬀers the capability for post-processing OpenFOAM cases with EnSight,
with a choice of 2 options:
• converting the OpenFOAM data to EnSight format with the foamToEnsight utility;
Open∇FOAM-1.5
U-164 Post-processing
• reading the OpenFOAM data directly into EnSight using the ensight74FoamExec
module.
6.4.1 Converting data to EnSight format
The foamToEnsight utility converts data from OpenFOAM to EnSight ﬁle format. For a
given case, foamToEnsight is executed like any normal application. foamToEnsight creates
a directory named Ensight in the case directory, deleting any existing Ensight directory in
the process. The converter reads the data in all time directories and writes into a case
ﬁle and a set of data ﬁles. The case ﬁle is named EnSight Case and contains details of
the data ﬁle names. Each data ﬁle has a name of the form EnSight nn.ext, where nn is an
incremental counter starting from 1 for the ﬁrst time directory, 2 for the second and so
on and ext is a ﬁle extension of the name of the ﬁeld that the data refers to, as described
in the case ﬁle, e.g.T for temperature, mesh for the mesh. Once converted, the data can
be read into EnSight by the normal means:
1. from the EnSight GUI, the user should select Data (Reader) from the File menu;
2. the appropriate EnSight Case ﬁle should be highlighted in the Files box;
3. the Format selector should be set to Case, the EnSight default setting;
4. the user should click (Set) Case and Okay.
6.4.2 The ensight74FoamExec reader module
EnSight provides the capability of using a user-deﬁned module to read data from a format
other than the standard EnSight format. OpenFOAM includes its own reader module
ensight74FoamExec that is compiled into a library named libuserd-foam. It is this library
that EnSight needs to use which means that it must be able to locate it on the ﬁling
system as described in the following section.
6.4.2.1 Conﬁguration of EnSight for the reader module
In order to run the EnSight reader, it is necessary to set some environment variables cor-
rectly. The settings are made in the bashrc (or cshrc) ﬁle in the $WM PROJECT DIR/etc/-
apps/ensightFoam directory. The environment variables associated with EnSight are pre-
ﬁxed by $CEI or $ENSIGHT7 and listed in Table 6.2. With a standard user setup, only
$CEI HOME may need to be set manually, to the path of the EnSight installation.
Environment variable Description and options
$CEI HOME Path where EnSight is installed, eg /usr/local/ensight, added
to the system path by default
$CEI ARCH Machine architecture, from a choice of names cor-
responding to the machine directory names in
$CEI HOME/ensight74/machines; default settings include
linux 2.4 and sgi 6.5 n32
$ENSIGHT7 READER Path that EnSight searches for the user deﬁned libuserd-foam
reader library, set by default to $FOAM LIBBIN
$ENSIGHT7 INPUT Set by default to dummy
Table 6.2: Environment variable settings for EnSight.
Open∇FOAM-1.5
6.5 Sampling data U-165
6.4.2.2 Using the reader module
The principal diﬃculty in using the EnSight reader lies in the fact that EnSight expects
that a case to be deﬁned by the contents of a particular ﬁle, rather than a directory as it
is in OpenFOAM. Therefore in following the instructions for the using the reader below,
the user should pay particular attention to the details of case selection, since EnSight does
not permit selection of a directory name.
1. from the EnSight GUI, the user should select Data (Reader) from the File menu;
2. The user should now be able to select the OpenFOAM from the Format menu; if not,
there is a problem with the conﬁguration described above.
3. The user should ﬁnd their case directory from the File Selection window, highlight
one of top 2 entries in the Directories box ending in /. or /.. and click (Set)
Geometry.
4. The path ﬁeld should now contain an entry for the case. The (Set) Geometry text
box should contain a ‘/’.
5. The user may now click Okay and EnSight will begin reading the data.
6. When the data is read, a new Data Part Loader window will appear, asking which
part(s) are to be read. The user should select Load all.
7. When the mesh is displayed in the EnSight window the user should close the Data
Part Loader window, since some features of EnSight will not work with this window
open.
6.5 Sampling data
OpenFOAM provides the sample utility to sample ﬁeld data, either through a 1D line
for plotting on graphs or a 2D plane for displaying as isosurface images. The sampling
locations are speciﬁed for a case through a sampleDict dictionary in the case system
directory. The data can be written in a range of formats including well-known graphing
packages such as Grace/xmgr, gnuplot and jPlot.
The sampleDict dictionary can be generated by copying an example sampleDict from
the sample source code directory at $FOAM UTILITIES/postProcessing/sampling/sample.
The plateHole tutorial case in the $FOAM TUTORIALS/solidDisplacementFoam directory
also contains an example for 1D line sampling:
17 interpolationScheme cellPoint;
18
19 setFormat raw;
20
21 sets
22 (
23 leftPatch
24 {
25 type uniform;
26 axis y;
27 start (0 0.5 0.25);
28 end (0 2 0.25);
29 nPoints 100;
30 }
31 );
32
33 surfaces
34 ();
35
36 fields
37 (
Open∇FOAM-1.5
U-166 Post-processing
38 sigmaxx
39 );
40
41 // ************************************************************************* //
Keyword Options Description
interpolation-
Scheme
cell
cellPoint
cellPointFace
Cell-centre value assumed constant over cell
Linear weighted interpolation using cell values
Mixed linear weighted / cell-face interpolation
setFormat raw
gnuplot
xmgr
jplot
Raw ASCII data in columns
Data in gnuplot format
Data in Grace/xmgr format
Data in jPlot format
surfaceFormat null
foamFile
dx
vtk
raw
stl
Suppresses output
points, faces, values ﬁle
DX scalar or vector format
VTK ASCII format
xyz values for use with e.g.gnuplotsplot
ASCII STL; just surface, no values
fields List of ﬁelds to be sampled, e.g. for velocity U:
U Writes all components of U
U.component(0) Writes component 0, i.e. Ux
U.component(1) Writes component 1, i.e. Uy
mag(U) Writes magnitude, i.e. |U|
sets List of 1D sets subdictionaries — see Table 6.4
surfaces List of 2D surfaces subdictionaries — see Table 6.5 and Table 6.6
Table 6.3: keyword entries for sampleDict.
The dictionary contains the following entries:
interpolationScheme the scheme of data interpolation;
sets the locations within the domain that the ﬁelds are line-sampled (1D).
surfaces the locations within the domain that the ﬁelds are surface-sampled (2D).
setFormat the format of line data output;
surfaceFormat the format of surface data output;
fields the ﬁelds to be sampled;
The interpolationScheme includes cellPoint and cellPointFace options in which
each polyhedral cell is decomposed into tetrahedra and the sample values are interpolated
from values at the tetrahedra vertices. With cellPoint, the tetrahedra vertices include
the polyhedron cell centre and 3 face vertices. The vertex coincident with the cell centre
inherits the cell centre ﬁeld value and the other vertices take values interpolated from cell
centres. With cellPointFace, one of the tetrahedra vertices is also coincident with a
face centre, which inherits ﬁeld values by conventional interpolation schemes using values
at the centres of cells that the face intersects.
Open∇FOAM-1.5
6.5 Sampling data U-167
The setFormat entry for line sampling includes a raw data format and formats for
gnuplot, Grace/xmgr and jPlot graph drawing packages. The data are written into a sets
directory within the case directory. The directory is split into a set of time directories and
the data ﬁles are contained therein. Each data ﬁle is given a name containing the ﬁeld
name, the sample set name, and an extension relating to the output format, including
.xy for raw data, .agr for Grace/xmgr and .dat for jPlot. The gnuplot format has the data
in raw form with an additional commands ﬁle, with .gplt extension, for generating the
graph. Note that any existing sets directory is deleted when sample is run.
The surfaceFormat entry for surface sampling includes a raw data format and formats
for gnuplot, Grace/xmgr and jPlot graph drawing packages. The data are written into a
surfaces directory within the case directory. The directory is split into time directories
and ﬁles are written much as with line sampling.
The fields list contains the ﬁelds that the user wishes to sample. The sample utility
can parse the following restricted set of functions to enable the user to manipulate vector
and tensor ﬁelds, e.g. for U:
U.component(n) writes the nth component of the vector/tensor, n = 0, 1 . . .;
mag(U) writes the magnitude of the vector/tensor.
The sets list contains sub-dictionaries of locations where the data is to be sampled.
The sub-dictionary is named according to the name of the set and contains a set of entries,
also listed in Table 6.4, that describes the locations where the data is to be sampled. For
example, a uniform sampling provides a uniform distribution of nPoints sample locations
along a line speciﬁed by a start and end point. All sample sets are also given: a type;
and, means of specifying the length ordinate on a graph by the axis keyword.
Required entries
Sampling type Sample locations
name
axis
start
end
nPoints
pointsuniform Uniformly distributed points on a line • • • • •
face Intersection of speciﬁed line and cell faces • • • •
midPoint Midpoint between line-face intersections • • • •
midPointAndFace Combination of midPoint and face • • • •
curve Speciﬁed points, tracked along a curve • • •
cloud Speciﬁed points • • •
Entries Description Options
type Sampling type see list above
axis Output of sample location x x ordinate
y y ordinate
z z ordinate
xyz xyz coordinates
distance distance from point 0
start Start point of sample line e.g.(0.0 0.0 0.0)
end End point of sample line e.g.(0.0 2.0 0.0)
nPoints Number of sampling points e.g.200
points List of sampling points
Table 6.4: Entries within sets sub-dictionaries.
Open∇FOAM-1.5
U-168 Post-processing
Keyword Description Options
basePoint Point on plane e.g.(0 0 0)
normalVector Normal vector to plane e.g.(1 0 0)
interpolate Interpolate data? true/false
triangulate Triangulate surface? (optional) true/false
Table 6.5: Entries for a plane in surfaces sub-dictionaries.
Keyword Description Options
patchName Name of patch e.g.movingWall
interpolate Interpolate data? true/false
triangulate Triangulate surface? (optional) true/false
Table 6.6: Entries for a patch in surfaces sub-dictionaries.
The surfaces list contains sub-dictionaries of locations where the data is to be sam-
pled. The sub-dictionary is named according to the name of the surface and contains
a set of entries beginning with the type: either a plane, deﬁned by point and normal
direction, with additional sub-dictionary entries a speciﬁed in Table 6.5; or, a patch, coin-
ciding with an existing boundary patch, with additional sub-dictionary entries a speciﬁed
in Table 6.6.
6.6 Monitoring and managing jobs
This section is concerned primarily with successful running of OpenFOAM jobs and ex-
tends on the basic execution of solvers described in section 3.3. When a solver is executed,
it reports the status of equation solution to standard output, i.e. the screen, if the level
debug switch is set to 1 or 2 (default) in DebugSwitches in the $WM PROJECT DIR/etc/controlDict
ﬁle. An example from the beginning of the solution of the cavity tutorial is shown below
where it can be seen that, for each equation that is solved, a report line is written with
the solver name, the variable that is solved, its initial and ﬁnal residuals and number of
iterations.
Starting time loop
Time = 0.005
Max Courant Number = 0
BICCG: Solving for Ux, Initial residual = 1, Final residual = 2.96338e-06, No Iterations 8
ICCG: Solving for p, Initial residual = 1, Final residual = 4.9336e-07, No Iterations 35
time step continuity errors : sum local = 3.29376e-09, global = -6.41065e-20, cumulative = -6.41065e-20
ICCG: Solving for p, Initial residual = 0.47484, Final residual = 5.41068e-07, No Iterations 34
time step continuity errors : sum local = 6.60947e-09, global = -6.22619e-19, cumulative = -6.86725e-19
ExecutionTime = 0.14 s
Time = 0.01
Max Courant Number = 0.585722
BICCG: Solving for Ux, Initial residual = 0.148584, Final residual = 7.15711e-06, No Iterations 6
BICCG: Solving for Uy, Initial residual = 0.256618, Final residual = 8.94127e-06, No Iterations 6
ICCG: Solving for p, Initial residual = 0.37146, Final residual = 6.67464e-07, No Iterations 33
time step continuity errors : sum local = 6.34431e-09, global = 1.20603e-19, cumulative = -5.66122e-19
ICCG: Solving for p, Initial residual = 0.271556, Final residual = 3.69316e-07, No Iterations 33
time step continuity errors : sum local = 3.96176e-09, global = 6.9814e-20, cumulative = -4.96308e-19
ExecutionTime = 0.16 s
Open∇FOAM-1.5
6.6 Monitoring and managing jobs U-169
Time = 0.015
Max Courant Number = 0.758267
BICCG: Solving for Ux, Initial residual = 0.0448679, Final residual = 2.42301e-06, No Iterations 6
BICCG: Solving for Uy, Initial residual = 0.0782042, Final residual = 1.47009e-06, No Iterations 7
ICCG: Solving for p, Initial residual = 0.107474, Final residual = 4.8362e-07, No Iterations 32
time step continuity errors : sum local = 3.99028e-09, global = -5.69762e-19, cumulative = -1.06607e-18
ICCG: Solving for p, Initial residual = 0.0806771, Final residual = 9.47171e-07, No Iterations 31
time step continuity errors : sum local = 7.92176e-09, global = 1.07533e-19, cumulative = -9.58537e-19
ExecutionTime = 0.19 s
6.6.1 The foamJob script for running jobs
The user may be happy to monitor the residuals, iterations, Courant number etc. as
report data passes across the screen. Alternatively, the user can redirect the report to a
log ﬁle which will improve the speed of the computation. The foamJob script provides
useful options for this purpose with the following executing the speciﬁed <solver> as a
background process and redirecting the output to a ﬁle named log:
foamJob <solver>
For further options the user should execute foamJob -h. The user may monitor the log
ﬁle whenever they wish, using the UNIXtail command, typically with the -f ‘follow’ option
which appends the new data as the log ﬁle grows:
tail -f log
6.6.2 The foamLog script for monitoring jobs
There are limitations to monitoring a job by reading the log ﬁle, in particular it is diﬃcult
to extract trends over a long period of time. The foamLog script is therefore provided to
extract data of residuals, iterations, Courant number etc. from a log ﬁle and present it in
a set of ﬁles that can be plotted graphically. The script is executed by:
foamLog <logFile>
The ﬁles are stored in a subdirectory of the case directory named logs. Each ﬁle has
the name <var> <subIter> where <var> is the name of the variable speciﬁed in the log
ﬁle and <subIter> is the iteration number within the time step. Those variables that
are solved for, the initial residual takes the variable name <var> and ﬁnal residual takes
<var>FinalRes. By default, the ﬁles are presented in two-column format of time and the
extracted values.
For example, in the cavity tutorial we may wish to observe the initial residual of the
Ux equation to see whether the solution is converging to a steady-state. In that case, we
would plot the data from the logs/Ux 0 ﬁle as shown in Figure 6.5. It can be seen here
that the residual falls monotonically until it reaches the convergence tolerance of 10−5
.
foamLog generates ﬁles for everything it feasibly can from the log ﬁle. In the cavity
tutorial example, this includes:
• the Courant number, Courant 0;
• Ux equation initial and ﬁnal residuals, Ux 0 and UxFinalRes 0, and iterations,
UxIters 0 (and equivalent Uy data);
Open∇FOAM-1.5
U-170 Post-processing
Time [s]
Ux0
0.180.160.140.120.100.080.060.040.020.00
1e+00
1e-01
1e-02
1e-03
1e-04
1e-05
Figure 6.5: Initial residual of Ux in the cavity tutorial
• cumulative, global and local continuity errors after each of the 2 p equations,
contCumulative 0, contGlobal 0, contLocal 0 and contCumulative 1, contGlobal 1,
contLocal 1;
• residuals and iterations from the the 2 p equations p 0, pFinalRes 0, pIters 0 and
p 1, pFinalRes 1, pIters 1;
• and execution time, executionTime.
Open∇FOAM-1.5
Chapter 7
Models and physical properties
OpenFOAM includes a large range of solvers each designed for a speciﬁc class of problem.
The equations and algorithms diﬀer from one solver to another so that the selection of
a solver involves the user making some initial choices on the modelling for their partic-
ular case. The choice of solver typically involves scanning through their descriptions in
Table 3.5 to ﬁnd the one suitable for the case. It ultimately determines many of the pa-
rameters and physical properties required to deﬁne the case but leaves the user with some
modelling options that can be speciﬁed at runtime through the entries in dictionary ﬁles
in the constant directory of a case. This chapter deals with many of the more common
models and associated properties that may be speciﬁed at runtime.
7.1 Thermophysical models
Thermophysical models are concerned with the energy, heat and physical properties.
The thermophysicalProperties dictionary is read by any solver that uses the thermophys-
ical model library. A thermophysical model is constructed in OpenFOAM as a pressure-
temperature p − T system from which other properties are computed. There is one com-
pulsory dictionary entry called thermoType which speciﬁes the complete thermophysical
model that is used in the simulation. The thermophysical modelling starts with a layer
that deﬁnes the basic equation of state and then adds more layers of modelling that de-
rive properties from the previous layer(s). The naming of the thermoType reﬂects these
multiple layers of modelling as listed in Table 7.1.
Equation of State — equationOfState
perfectGas Perfect gas equation of state
Basic thermophysical properties — thermo
hConstThermo Constant speciﬁc heat cp model with evaluation of enthalpy
h and entropy s
janafThermo cp evaluated by a function with coeﬃcients from JANAF
thermodynamic tables, from which h, s are evaluated
Derived thermophysical properties — specieThermo
specieThermo Thermophysical properties of species, derived from cp, h
and/or s
Transport properties — transport
Continued on next page
U-172 Models and physical properties
Continued from previous page
constTransport Constant transport properties
sutherlandTransport Sutherland’s formula for temperature-dependent transport
properties
Mixture properties — mixture
pureMixture General thermophysical model calculation for passive gas
mixtures
homogeneousMixture Combustion mixture based on normalised fuel mass frac-
tion b
inhomogeneousMixture Combustion mixture based on b and total fuel mass fraction
ft
veryInhomogeneousMixture Combustion mixture based on b, ft and unburnt fuel mass
fraction fu
dieselMixture Combustion mixture based on ft and fu
multiComponentMixture Combustion mixture based on multiple components [**]
chemkinMixture Combustion mixture using CHEMKIN thermodynamics and
reaction schemes database ﬁles
Thermophysical model — thermoModel
hThermo General thermophysical model calculation based on en-
thalpy h
hMixtureThermo Calculates enthalpy for combustion mixture
hhuMixtureThermo Calculates enthalpy for unburnt gas and combustion mix-
ture
Table 7.1: Layers of thermophysical modelling.
The thermoType entry takes the form:
thermoModel<mixture<transport<specieThermo<thermo<equationOfState>>>>>
so that the following is an example entry for thermoType:
hThermo<pureMixture<constTransport<specieThermo<hConstThermo<perfectGas>>>>>
7.1.1 Thermophysical property data
The basic thermophysical properties are speciﬁed for each species from input data. The
data is speciﬁed using a compound entry with the following format for a specie accessed
through the keyword mixture:
mixture <specieCoeffs> <thermoCoeffs> <transportCoeffs>
The specie coeﬃcients <specieCoeffs> contains the entries listed in Table 7.2 in the
order that they are speciﬁed in input.
The thermodynamic coeﬃcients <thermoCoeffs> are ostensibly concerned with eval-
uating the speciﬁc heat cp from which other properties are derived. The current thermo
models are described as follows:
Open∇FOAM-1.5
7.1 Thermophysical models U-173
Description Entry
String name e.g.mixture
Number of moles of this specie nmoles
Molecular weight W (kg/kmol)
Table 7.2: Specie coeﬃcients.
hConstThermo assumes a constant cp and a heat of fusion Hf which is simply speciﬁed
by a two values cp Hf following the <specieCoeffs>.
janafThermo calculates cp as a function of temperature T from a set of coeﬃcients taken
from JANAF tables of thermodynamics. The ordered list of coeﬃcients is given in
Table 7.3. The function is valid between a lower and upper limit in temperature Tl
and Th respectively. Two sets of coeﬃcients are speciﬁed, the ﬁrst set for tempera-
tures above a common temperature Tc (and below Th, the second for temperatures
below Tc (and above Tl). The function relating cp to temperature is:
cp = R((((a4T + a3)T + a2)T + a1)T + a0) (7.1)
In addition, there are constants of integration, a5 and a6, both at high and low
temperature, used to evaluating h and s respectively.
Description Entry
Lower temperature limit Tl (K)
Upper temperature limit Th (K)
Common temperature Tc (K)
High temperature coeﬃcients a0 . . . a4
High temperature enthalpy oﬀset a5
High temperature entropy oﬀset a6
Low temperature coeﬃcients a0 . . . a4
Low temperature enthalpy oﬀset a5
Low temperature entropy oﬀset a6
Table 7.3: JANAF thermodynamics coeﬃcients.
The transport coeﬃcients <transportCoeffs> are used to to evaluate dynamic vis-
cosity µ, thermal conductivity κ and laminar thermal conductivity (for enthalpy equation)
α. The current transport models are described as follows:
constTransport assumes a constant µ and Prandtl number Pr = cpµ/κ which is simply
speciﬁed by a two values µ Pr following the <thermoCoeffs>.
sutherlandTransport calculates µ as a function of temperature T from a Sutherland coeﬃ-
cient As and Sutherland temperature Ts, speciﬁed by values following the <thermoCoeffs>;
µ is calculated according to:
µ =
As
√
T
1 + Ts/T
(7.2)
The following is an example entry for a specie named fuel modelled using sutherland-
Transport and janafThermo, with comments to explain the entries:
Open∇FOAM-1.5
U-174 Models and physical properties
fuel // keyword
fuel 1 44.0962 // specie
200 5000 1000 // -- janafThermo --
7.53414 0.0188722 -6.27185e-06 9.14756e-10 -4.78381e-14
-16467.5 -17.8923
0.933554 0.0264246 6.10597e-06 -2.19775e-08 9.51493e-12
-13958.5 19.2017 // -----------------
1.67212e-06 170.672; // sutherlandTransport
The following is an example entry for a specie named air modelled using constTransport
and hConstThermo, with comments to explain the entries:
mixture // keyword
air 1 28.9 // specie
1000 2.544e+06 // hConstThermo
1.8e-05 0.7; // constTransport
7.2 Turbulence models
The RASProperties dictionary is read by any solver that uses models Reynolds-averaged
stress (RAS) models for turbulence and the LESProperties dictionary is read by solvers
that use large-eddy simulation (LES) of turbulence. The entries required in the RASProp-
erties are listed in listed in Table 7.4and those for LESProperties dictionaries are listed in
Table 7.5.
RASModel Name of RAS turbulence model
turbulence Switch to turn turbulence modelling on/oﬀ
<RASModel>Coeffs Dictionary of coeﬃcients for the respective RASModel
wallFunctionCoeffs Dictionary of wall function coeﬃcients
Table 7.4: Keyword entries in the RASProperties dictionary.
LESmodel Name of LES model
delta Name of delta δ model
<LESmodel>Coeffs Dictionary of coeﬃcients for the respective LESmodel
<delta>Coeffs Dictionary of coeﬃcients for each delta model
kappa von K´arm´an’s constant κ
wallFunctionCoeffs Dictionary of wall function coeﬃcients
Table 7.5: Keyword entries in the LESProperties dictionary.
The incompressible and compressible RAS turbulence models, isochoric and aniso-
choric LES models and delta models are all named and described in Table 3.9. The user
may consult turbulenceProperties dictionary from a relevant example case to get a full list
of coeﬃcients required for each model and their default values. The required coeﬃcients
may diﬀer depending on whether the RAS models are incompressible or compressible
and whether the LES models are isochoric or anisochoric. For reference, these diﬀerent
Open∇FOAM-1.5
7.2 Turbulence models U-175
categories of RAS and LES models are represented in the RASProperties and LESProper-
ties dictionaries, respectively, of the following example cases in the $FOAM TUTORIALS
directory:
turbFoam/cavity Incompressible RAS turbulence models;
sonicTurbFoam/prism Compressible RAS turbulence models;
oodles/pitzDaily Isochoric LES turbulence models;
Xoodles/pitzDaily Anisochoric LES turbulence models;
Open∇FOAM-1.5
U-176 Models and physical properties
Open∇FOAM-1.5
Appendix A
FoamX case manager (obsolete in
v1.5)
OpenFOAM is distributed with the FoamX utility to manage the running of cases. FoamX
is a GUI that can manage cases over a distributed network, e.g. the Internet, although
most often it is used to manage cases on a local machine.
This chapter contains mainly reference material for FoamX, and while section A.3 and
section A.4 provide useful advice on the general use of FoamX, new users are ﬁrst directed
to the tutorials (chapter 2) to learn how to use FoamX.
The mechanism for running cases over a network is to have a host machine providing
services that can be called from a JAVA GUI on another machine. The interface between
the JAVA GUI and these services — a host browser, case browser and case server, written
in C++ — is MICO, an implementation the Common Object Request Broker Architecture
(CORBA). If the user simply wishes to manage cases on their local machine, the host
browser and JAVA GUI can both be launched from that machine. We shall refer to this
as normal mode in the following sections. Let us summarise the options below:
host browser run locally (normal mode) in this case the user can launch both the
host browser and GUI by executing runFoamX
runFoamX
host browser run remotely (remote mode) in this case the host browser is ﬁrst
launched on the host machine by runFoamXHB
runFoamXHB
and the GUI is launched locally by executing runFoamX which connects to the
running host browser
runFoamX
The processes involved in both these options are shown in Figure A.1. When runFoamX
is executed, it searches for a running host browser. If one is running, i.e. previously
launched with runFoamXHB, it will connect to it; otherwise it starts a host browser itself.
In section A.1, section A.2 and section A.3 the general operation of FoamX is described
with particular emphasis on how it can be operated over a network. Following that,
the running of OpenFOAM cases through the case server is described in section A.4.
Conﬁguration issues relating to FoamX are described in section A.5.
U-178 FoamX case manager (obsolete in v1.5)
if no host browser
is running
runFoamX
FoamXCaseBrowser
JAVA GUIFoamXHostBrowser
FoamXCaseServer
start name server
register processes
runFoamXHB
ns.ref
Figure A.1: Options for running FoamX.
MICO name server
Start nsd IOR in ns.ref
host machine
(a) Starting the nsd name server.
MICO name server
FoamXHostBrowser
registers
host machine
Start
FoamXHostBrowser
(b) Starting the FoamXHostBrowser.
Figure A.2: Running runFoamXHB.
A.1 The name server and host browser
To start the FoamX host browser on the host machine, the user should either run the
runFoamXHB script, or, in the case that the host browser is run locally (normal mode),
run runFoamX which itself launches runFoamXHB. runFoamXHB performs two functions
as shown in Figure A.2.
• The MICO name server — a process called nsd — is started by the host machine.
It uses the host name and a default port address that can be set manually by
the org.omg.CORBA.ORBInitialHost= and org.omg.CORBA.ORBInitialPort= en-
tries in the FoamXClient.cfg ﬁle of the .OpenFOAM-1.5/apps/FoamX directory. The
name server writes the host/port address in IOR form in the ns.ref ﬁle in the same
directory.
• The FoamXHostBrowser process is started on the host/port address where nsd was
started and registers itself under the name FoamXHostBrowser.
Therefore the execution of runFoamXHB, by typing at the command prompt
runFoamXHB
launches the name server and host browser which outputs to screen the following:
Starting NameServer with inet:<host>:<port>...
Starting FoamX Host Browser with inet:<host>:<port>...
Open∇FOAM-1.5
A.2 The JAVA GUI U-179
where <host>:<port> are set by default or are those speciﬁed in the FoamXClient.cfg
ﬁle. The FoamXHostBrowser prints the OpenFOAM logo strip to screen and details about
its execution status to indicate it is running correctly.
A.1.1 Notes for running the name server
• The contents of the ns.ref ﬁle can be ‘translated’ and viewed by typing
iordump < $FOAMX USER CONFIG/ns.ref
• An administration tool for MICO can be started by typing
nsadmin -ORBNamingAddr inet:<host>:<port>
where the inet:<host>:<port> entry can be found by viewing the ns.ref ﬁle. The
user should type help to view the options within the tool, which include ls to list
the registered services.
A.2 The JAVA GUI
Any remote machine, or the host machine itself, can connect to the name server using
a copy of the ns.ref ﬁle generated previously to provide the IOR. The remote machine
also needs the org.omg.CORBA.ORBInitialHost= entry to be set to the name of the host
machine in the FoamXClient.cfg ﬁle, with a corresponding entry in its /etc/hosts ﬁle as
described in section A.1.1.
To start the FoamXJAVA GUI on a remote machine as shown in Figure A.3 a), the user
should run the runFoamX script which should locate the name server already launched by
runFoamXHB. The user will be prompted on the command line to acknowledge that they
wish to connect to this server:
Found server reference $FOAMX USER CONFIG/ns.ref
Do you want to connect to this server ? (n)
A new name server will be created locally if the user decides not to connect to the existing
name server or if no name server exists, as in the case where runFoamXHB has not been
executed. This is why when running both host browser and GUI locally it is suﬃcient to
execute runFoamX without running runFoamXHB. Typing, at a command prompt
runFoamX
opens the JAVA browser window, as shown in Figure A.4. The browser is split into the
following regions:
Menu bar and buttons (top) containing the operations used in creation, construction
and running of a case;
Case panel (left) consisting of the case directory tree in the case browser and the con-
tents of the OpenFOAM cases in the case server;
Editing panel (right, blue) in which the editing of case entries is done;
Open∇FOAM-1.5
U-180 FoamX case manager (obsolete in v1.5)
Copy ns.ref
Start FoamX
connect
FoamXHostBrowser
MICO name server
host machine
(a) Connecting to the name server.
registers
MICO name server
FoamXHostBrowser
Start FoamXCaseBrowser
FoamXCaseBrowser
host machine
(b) Starting the FoamXCaseBrowser.
Figure A.3: Running runFoamX.
Progress history panel (bottom) a dialogue box which informs on certain actions
that have been performed.
By default the case panel will display the host machine on which the name server is
run. If the user wishes to access cases on other remote machines, they should
list the machines in hosts in the .OpenFOAM-1.5/controlDict ﬁle. The FoamX window
can be resized in the normal manner; the individual windows within it can also be resized
by clicking on the speckled bars separating the windows and dragging the cursor across
the screen.
There are three ways to pass commands to the browser:
• selecting an item and double-clicking, typically to open its contents;
• selecting an item and clicking the right mouse button brings up a menu of operations
which can be performed on that item;
• selecting an item from the menu bar and buttons can perform other operations.
Note that if the cursor is held over any menu button for one second a short description
of the button’s use appears in a small dialogue box below the base of the cursor.
A.3 The case browser
From the JAVA GUI, a case browser may be opened for a machine listed in the case panel
by: either double-clicking on the host icon; or, highlighting the host with a single-click and
Open∇FOAM-1.5
A.3 The case browser U-181
Editing panelMenu bar and buttonsCase panel
Progress history panel
Figure A.4: FoamX main browser window
selecting Open Case Browser ( ) from a the menu buttons or right mouse button. This
operation makes a call to the FoamXHostBrowser to open a FoamXCaseBrowser as shown
in Figure A.3 b). The FoamXCaseBrowser reads the ns.ref ﬁle to get a reference to the
name server and registers itself. The JAVA GUI can then look up the FoamXCaseBrowser
and make calls to it, e.g. to start up a FoamXCaseServer to start working on a case.
The FoamXCaseServer registers itself on the name server, and so the process continues of
registering services and making calls to them.
Note that a case browser may be opened automatically at launch of the JAVA GUI by
executing runFoamX with the host as an argument
runFoamX [host]
Starting the case browser on a host machine produces a directory tree list of root
path directories in which OpenFOAM cases are stored as shown in Figure A.5. The case
roots speciﬁed in the user’s .OpenFOAM-1.5/controlDict ﬁle; for information on adding or
removing case roots, please refer to section A.5.2.
For the remainder of the manual:
It will be assumed that any operation in FoamX, described in the text, is selected
either from the menu bar or button, or by a right button click on the mouse unless
otherwise stated.
The case browser oﬀers a range of functions as shown in Figure A.6. By selecting a
root directory icon, the user may open the directory, create a new case, import a case or
run some utilities; by highlighting a case name icon, the user may open, delete, clone or
unlock that case or run OpenFOAM utilities on the case.
Open∇FOAM-1.5
U-182 FoamX case manager (obsolete in v1.5)
Figure A.5: Case root directory tree.
(a) Case directory selection.
(b) Case name selection.
Figure A.6: Case browser functions.
A.3.1 Opening a root directory
The current set of cases within a case root directory can be viewed by selecting the the
Open Root function by placing the cursor over the root directory and clicking the right
mouse button to reveal the menu as shown in Figure A.6 a), or by a double-click on the
root directory icon. The directory opens to reveal a case tree for that root directory as
shown in Figure A.7.
A.3.2 Creating a new case
A new case is created by selecting the Create Case function ( ) either from the menu
buttons or by placing the cursor over the host icon or a case directory and clicking the right
mouse button as shown in Figure A.8. A small window appears with data entry boxes
for the Class, Case Name and Case Root as shown in Figure A.8. The Class provides a
scroll menu containing OpenFOAM solver names, such as icoFoam and turbFoam. FoamX
generates the necessary data entries in the case ﬁles required by the selected solver; hence,
it is essential to choose the correct solver. Case Name and Case Root are the directory
path and directory name respectively, in which the case data is stored according to the
Open∇FOAM-1.5
A.3 The case browser U-183
Figure A.7: Opening a case root.
Figure A.8: Creating a new case.
ﬁle structure described in section 4.1. Once the correct entries have been made, click OK.
A case server for the new case is opened allowing the user to edit case ﬁles, run solvers
and utilities, etc. as described in section A.4.
A.3.3 Opening an existing case
The Open Case function ( ) opens an existing case in a case server as shown in Figure A.9.
The case server allows the user to edit case ﬁles, run solvers and utilities, etc. as described
in section A.4.
Open menu with right mouse button
or menu bar buttonSelect case by clicking on it
Figure A.9: Opening an existing case.
A.3.4 Deleting an existing case
The user may highlight a case and select the Delete Case function ( ) to delete the
case directory from the hard disk. As shown in Figure A.10, the function prompts the
Open∇FOAM-1.5
U-184 FoamX case manager (obsolete in v1.5)
user with a window asking whether he/she wishes to delete the case which the user may
accept by clicking the Yes button or decline with the No button.
Figure A.10: Deleting an existing case.
A.3.5 Cloning an existing case
The Clone Case function ( ) creates a new case into which existing ﬁles from a selected
case are copied. As shown in Figure A.11, the user must ﬁrst highlight the case that is to
be cloned and select the Clone Case function. This opens a table in which the new case
name must be speciﬁed and the root path and the applicationClass may be changed
to something diﬀerent to those of the case being cloned. Finally the times entry allows
the user to choose the time directories that are copied during the clone operation. The
options are listed in Table A.1.
Option Description
firstTime Copies the earliest time directory
latestTime Copies the most recent time directory
allTime Copies all time directories
noTime Copies no time directories
Table A.1: Options for copying time directories in a Clone Case operation.
On entering the correct information and clicking the Close button, the user is prompted
to complete the clone operation. The new case can then be opened as described in
section A.3.3.
A.3.6 Unlocking an existing case
When a case is created or opened, a lock ﬁle is created to prevent the case being opened in
a separate server. When the case is closed, the lock ﬁle is removed to allow it to be opened
once more. In a few circumstances the lock ﬁle may not be deleted even though the case is
no longer being processed in a case server, e.g. if the host browser is killed while the case
is open in the case server. The Unlock Case function ( ) therefore provides the option
of deleting the lock ﬁle. As shown in Figure A.12, it presents a window warning the user
that the case may be being processed by another user. It is then the user’s responsibility
to ensure that it is not being processed elsewhere before accepting to delete the lock ﬁle.
Open∇FOAM-1.5
A.3 The case browser U-185
Figure A.11: Cloning an existing case.
Figure A.12: Unlocking an existing case.
A.3.7 The process editor
The Start Process Editor function ( ) opens an editor in which the user can monitor
all the OpenFOAM jobs that are ﬁnished and currently running. The editor is simply
a GUI that reads the ﬁles in the runningJobs and ﬁnishedJobs directories, located in
the $FOAM LIC DIR directory of the installation. It consists of a window as shown in
Figure A.13. Tags allow the user to move between a runningJobs table and a ﬁnishedJobs
table. The tables contain the details of jobs which are fairly self-explanatory. There are
buttons above and to the left of the runningJobs table that perform the tasks listed in
Table A.2. The user may select a job by clicking on it in the runningJobs table, which
activates the buttons above right of the table. These buttons allow the user to control
jobs as listed in Table A.2.
The ﬁnishedJobs table is an archive of information of jobs that were running in Open-
FOAM but were terminated for one reason or another. The user is free to store the entries
they ﬁnd useful and delete those that are not. There are 2 buttons for deleting entries in
the table: the purge button deletes ﬁnished jobs that are older than 7 days; the remove
button simply removes a selected entry from the table.
There are two check boxes at the bottom of the process editor window that govern
which jobs are listed in the runningJobs and ﬁnishedJobs tables as listed in Table A.2.
A.3.8 Running OpenFOAM utilities
The Foam Utilities function allows the user to run OpenFOAM utilities. This function
is also oﬀered in the case server and is more commonly used there; it is therefore described
in section A.4.
Open∇FOAM-1.5
U-186 FoamX case manager (obsolete in v1.5)
(a) Running jobs table.
(b) Finished jobs table.
Figure A.13: The process editor.
A.4 The case server
When a case is opened from the case browser, a case server starts up. A directory tree
appears in the case window as shown in Figure A.14. The user can move between the
new case and case browser windows using the tags at the base of the case window. The
directory tree contains 3 entries at the top level:
Dictionaries Contains the dictionaries for controlling the case and setting physical prop-
erties.
Fields Sets the initial and boundary values for the ﬁelds.
Mesh Reads/imports a mesh and sets the boundary conditions for the patches of the
mesh.
A.4.1 Importing an existing mesh
The case requires a mesh, either created using the blockMesh utility described in section 5.3
or using third-party software combined with the OpenFOAM mesh converters. A Open-
FOAM mesh is stored in the constant/polyMesh directory of the case as: either the ﬁles
that constitute a OpenFOAM mesh — boundary, cells etc.; or, as a blockMeshDict ﬁle that
blockMesh uses to create a OpenFOAM mesh; or, both. The user may import all these
ﬁles from an existing constant/polyMesh directory into their case using the Import Mesh
function as shown in Figure A.15.
Open∇FOAM-1.5
A.4 The case server U-187
Main buttons
read Re-reads the jobs in the runningJobs and ﬁnishedJobs directories
status Contacts host machines to update the status of jobs
purge Removes jobs that are no longer running
Running jobs buttons
Info Displays an information panel about the job
endNow Forces the job to stop at the end of the next time step
end Forces the job to stop next time step the job outputs ﬁeld data to ﬁle
kill Terminates the job immediately
suspend Suspends the job immediately
cont Restarts a suspended job
Check boxes
My Jobs Only shows the jobs of the current user
Compact Removes the jobs relating to FoamX from the list
Table A.2: Process editor buttons.
A.4.2 Reading a mesh
Once the mesh ﬁles exist in the constant/polyMesh directory, whether imported directly
or generated by blockMesh or one of the mesh converter utilities, they can be read into
the case server using the Read Mesh&Fields function. Should the reader wish to test
this function, they can open one of the tutorial examples and generate a mesh with the
blockMesh utility as described in section A.4.8.
A.4.3 Setting boundary patches
As shown in Figure A.16, once the Read Mesh&Fields function executed, the directory
tree displays a list of the boundary patches for the mesh. The user can then impose
physical boundary conditions onto a patch by highlighting the patch and selecting the
Define Boundary Type function. This brings up a patch description window inside the
editing panel. As Figure A.17 illustrates, the physical boundary type can be selected by
clicking on the . . . button to the right of the Boundary Type descriptor. This opens a
new window listing the physical boundary types available to the speciﬁc solver. The user
make a selection from the list and click OK, which closes the window and returns the
user to the patch description window. Beneath the physical boundary type descriptor is
a table listing the primitive variables that are present in the solver and their numerical
patch types, or boundary conditions, used in the solution. The user should select the
physical boundary types for all the patches noting that in 2D cases the front and back
patches, aligned in the 2D solution plane, should be assigned the empty type.
A.4.4 Setting the ﬁelds
Once all the physical patch types are speciﬁed, the Fields can be edited using the Edit
Field function, selected as usual by highlighting the ﬁeld and clicking the right mouse
button or by double-clicking on the ﬁeld icon. The Edit Field function brings up a ﬁeld
window in the editing panel as shown in Figure A.18. The table lists a series of data values
required for each ﬁeld as outlined in section 4.2.8: internalField, referenceLevel
and any values corresponding to one or more patches required from the physical type
Open∇FOAM-1.5
U-188 FoamX case manager (obsolete in v1.5)
Figure A.14: Case server window
Figure A.15: Importing a OpenFOAM mesh
speciﬁcation. Note that the patch list is updated to accommodate any changes to the
speciﬁcation of a physical patch type. The user can click on entries in the Value column
to change values. In Figure A.18 we demonstrate the setting of a uniform velocity of
(1, 0, 0) m/s on the patch named movingWall.
A.4.5 Editing the dictionaries
The user can edit the data in the Dictionaries. The dictionaries include controlDict, shown
in Figure A.19, fvSchemes, fvSolution, described in section 4.3, section 4.4 and section 4.5
respectively, and those for material properties. The dictionaries present the entry in
tabular form with the data entry in the right column. Clicking on the entry will allow the
user to edit the value directly or open a sub-dictionary whose values can be edited in the
same manner. Note that entries that are printed in grey, e.g. the applicationClass in
Figure A.19 are non-editable. Also note that some entries are selected from a Selection
Editor; in this case the selected entry is that which is highlighted in green.
Open∇FOAM-1.5
A.4 The case server U-189
Figure A.16: Reading a OpenFOAM mesh
Primitive ﬁelds
Numerical patch conditions
Patch description window
Physical patch type selection
Figure A.17: Selecting the physical boundary types
A.4.6 Saving data
The user can save any changes to the case by selecting the Save Case function ( ) from
the button bar. The dictionary, ﬁelds and mesh data will be saved.
A.4.7 Running solvers
The user can run the solver for which the case is written in one of two ways. To run
immediately in the foreground, the user should select the Start Calculation Now func-
tion ( ) from the button bar. The OpenFOAM solver is immediately launched without
prompting the user for more information.
Alternatively, the user can select the Start Calculation function ( ) from the
button bar. This brings up a Run Application window as shown in Figure A.20. The user
may select to run the case in the background by clicking the background button, before
pressing the Start Run button. For a case run in the background, the progress history is
written to a log ﬁle speciﬁed in the log text box, which can be viewed by pressing the
View Log button.
Open∇FOAM-1.5
U-190 FoamX case manager (obsolete in v1.5)
Figure A.18: Editing a ﬁeld and setting patch conditions
Figure A.19: Example dictionary window: controlDict
A.4.8 Running utilities
There are numerous utilities supplied with OpenFOAM that can be executed by high-
lighting the case name icon in the case server window and clicking the right mouse but-
ton which opens a hierarchy of menus containing the utilities, as shown in Figure A.21.
Selecting a utility, blockMesh in our example in Figure A.22, opens up a window in which
the user can edit the dictionary associated with the utility, if one exists. The mandatory
command line arguments are set by default for the case that is being edited. The user
can select optional arguments accordingly from the table.
A.4.9 Closing the case server
The user should click the Close Case button ( ) to close the case server window and
return the user to the case browser.
A.5 Conﬁguration to run FoamX
The FoamX user conﬁguration ﬁles are located in the user .OpenFOAM-1.5/apps/FoamX
directory, that may be copied to the user’s $HOME, maintaining the directory structure.
The ﬁles that can be conﬁgured, if the user so wishes, are:
Open∇FOAM-1.5
A.5 Conﬁguration to run FoamX U-191
Select to run job in backgroundClick to start the run
Figure A.20: Running a solver using the Start Calculation function
Figure A.21: Running a utility
FoamXClient.cfg contains settings for the networking and appearance of FoamX. In par-
ticular, the user may wish to set:
• the host/port address given by the org.omg.CORBA.ORBInitialHost= and
org.omg.CORBA.ORBInitialPort= entries.
• the default browser, by editing the FoamX.Browser= entry to netscape, mozilla,
konqueror or any other browser or executable that can be passed a URL;
• the default editor, by commenting out (#) the relevant entries for FoamX.Editor=
to leave the editor of choice from e.g.internal, nedit, xemacs.
FoamX.cfg contains settings for processControl that can be edited. In particular the
user should set the remoteShell to rsh or ssh, depending on whether they are
running remote or secure shell. The ﬁle also contains settings for timings associated
with the connection timing out and retries of commands which can be increased if
the user experiences problems.
The environment variables associated with FoamX compilation are preﬁxed by $FOAMX
and listed in Table A.3.
A.5.1 JAVA
The FoamX case browser uses JAVA 1.5 which may be installed as standard on the
machine, although perhaps not the required version. It is therefore supplied with the
Open∇FOAM-1.5
U-192 FoamX case manager (obsolete in v1.5)
Figure A.22: Opening the utility dictionary
Environment variable Description and options
$FOAMX PATH Path to FoamX installation, $FOAM UTIL/FoamX
$FOAMX SYSTEM CONFIG Path to FoamX system conﬁguration ﬁles,
$FOAMX PATH/conﬁg
$FOAMX USER CONFIG Path to FoamX user conﬁguration ﬁles,
$HOME/$FOAM DOT DIR/apps/FoamX
Table A.3: Environment variable settings for FoamX.
OpenFOAM release and the $JAVA HOME environment variable is speciﬁed by default in
$WM PROJECT DIR/.bashrc (or .cshrc) to the top level directory of the supplied JAVA re-
lease. The system administrator may choose to install JAVA 1.5 in an alternative location
setting $JAVA HOME accordingly.
A.5.2 Paths to case ﬁles
FoamX ﬁnds paths to the user’s case ﬁles from the caseRoots entries in the .OpenFOAM-
1.5/controlDict ﬁle. By default they are set as:
caseRoots
(
"."
"$FOAM RUN/tutorials/icoFoam"
"$FOAM RUN/tutorials/turbFoam"
...
);
where $FOAM RUN points by default to the directory $HOME/OpenFOAM/${USER}-
1.5/run. This means that by default the user can open cases in the tutorial directory
copied to their run directory and cases within the directory from which FoamX is launched.
If the user wished to set their own paths, they should do so in a local copy of controlDict
ﬁle in the $HOME/.OpenFOAM-1.5 directory.
Open∇FOAM-1.5
Appendix B
Miscellaneous reference information
This chapter is currently a repository of information that: we do not consider worthy of
inclusion in the main part of the User Guide because, for example, it is contains unneces-
sary detail or is outdated; we consider may be useful to a user in certain circumstances.
B.1 Running a decomposed case in parallel using
MPICH
This section describes how to run OpenFOAM cases in parallel using MPI/MPICH rather
than openMPI, as described in section 3.4.2.
The invocation of MPI/MPICH diﬀers whether or not the application that is being
executed has the same pathname on all processor nodes. The pathname to the executable
can diﬀer if:
• the processors do not all belong to the same UNIX/Linux architectures;
• there is no networked ﬁle system (NFS) access to the executable from all nodes and
therefore it is installed in a diﬀerent place on diﬀerent nodes.
B.1.1 Same executable pathname on all nodes
On a single machine in which the processor nodes are all local to the user, the following
command should be executed1
, noting that ` is a backwards quotation character, typically
found at the top left of the keyboard (not a ’):
mpirun -np <nProcs> `which <foamExec>`
<otherArgs> -parallel < /dev/null >& log &
where: <nProcs> is the number of processors; <foamExec> is the executable, e.g.icoFoam;
and, the output is redirected to a ﬁle named log. For example, if icoFoam is run on 3
nodes on the cavity tutorial in the $FOAM RUN/tutorials/icoFoam directory, then the
following command should be executed:
mpirun -np 3 `which icoFoam` $FOAM RUN/tutorials/icoFoam cavity
-parallel < /dev/null >& log &
1
This command executes mpirun in the background which does not work for SGI mpirun; SGI users
must therefore omit the ﬁnal & in this and later mpirun commands.
U-194 Miscellaneous reference information
When the processors that the user wishes to access are distributed across a cluster of
machines, the user should execute the command:
mpirun -machinefile <machinesFile> -np <nProcs> `which <foamExec>`
<otherArgs> -parallel < /dev/null >& log &
This is the same as before except that there is the <machinesFile> ﬁle that contains the
names of the nodes, one per line, with the ﬁrst one being the machine that the user is
currently logged onto. A <machinesFile> is a ﬁle read by MPICH and therefore requires
no header, only the names of the machines and number of processors to be used on each
machine. For example, to run one process on machine arp and two on noddy, the ﬁle
would be:
arp:1
noddy:2
Note: optimisation of the performance on a cluster of machines with shared memory may
require recompiling of the MPICH library. See the MPICH documentation on how to do
this.
B.1.2 Diﬀerent executable pathname on diﬀerent nodes
To run an executable with a diﬀerent pathname on diﬀerent nodes requires the same
version of OpenFOAM to be installed on all nodes and the ability to run using rsh. The
latter can be tested by trying to execute an application, e.g.icoFoam, on all nodes:
rsh <machineName> icoFoam <root> <case>
Diﬀerent pathnames of executables can be speciﬁed through a <p4pgFile> ﬁle containing
the names of nodes and the respective pathname to the executable. For example to
run icoFoam on machine arp, a Linux machine, and on noddy, a Solaris machine, the
<p4pgFile> would contain the following entries:
arp 0 /usr/local/OpenFOAM/OpenFOAM-1.5/applications/bin/linuxOptMPICH/icoFoam
noddy 1 /usr/local/OpenFOAM/OpenFOAM-1.5/applications/bin/solarisOptMPICH/icoFoam
The second entry per line, here 0 and 1, are the number of additional processes per
machine. Since the MPI run is started from arp the master process runs on it and no
additional processes should be started on it. The job is run by executing
mpirun -p4pg <p4pgFile> `which <foamExec>`
<otherArgs> -parallel < /dev/null >& log &
Open∇FOAM-1.5
Index U-195
Index
Symbols Numbers A B C D E F G H I J K L M N O P Q R S T U V W X Z
Symbols
*
tensor member function, P-25
+
tensor member function, P-25
-
tensor member function, P-25
/
tensor member function, P-25
/*...*/
C++ syntax, U-76
//
C++ syntax, U-76
OpenFOAM ﬁle syntax, U-98
# include
C++ syntax, U-70, U-76
&
tensor member function, P-25
&&
tensor member function, P-25
^
tensor member function, P-25
<LESmodel>Coeffs keyword, U-174
<RASModel>Coeffs keyword, U-174
<delta>Coeffs keyword, U-174
0.000000e+00 directory, U-98
1-dimensional mesh, U-122
1D mesh, U-122
2-dimensional mesh, U-122
2D mesh, U-122
Numbers
0 directory, U-98
A
access functions, P-23
addLayersControls keyword, U-138
adiabaticFlameT utility, U-90
adjustableRunTime
keyword entry, U-59, U-105
adjustPhi tools, U-91
adjustTimeStep keyword, U-59
agglomerator keyword, U-115
algorithms tools, U-91
allTime
menu entry, U-184
analytical solution, P-45
anisotropicFilter model, U-94
Annotation window panel, U-25, U-159
ansysToFoam utility, U-86
APIfunctions model, U-93
applications, U-67
Apply button, U-156, U-160
arbitrarily unstructured, P-31
arc
keyword entry, U-132
arc keyword, U-131
ascii
keyword entry, U-105
attachMesh utility, U-87
Auto Accept button, U-159
autoPatch utility, U-87
axes
right-handed, U-130
right-handed rectangular Cartesian, P-15,
U-20
axi-symmetric cases, U-127, U-135
axi-symmetric mesh, U-122
B
background
process, U-26, U-79
backward
keyword entry, U-112
Backward diﬀerencing, P-39
basicThermophysicalModels
library, U-92
binary
keyword entry, U-105
BirdCarreau model, U-95
blended diﬀerencing, P-38
block
expansion ratio, U-132
block keyword, U-131
blockMesh solver, P-47
Open∇FOAM-1.5
U-196 Index
blockMesh utility, U-38, U-86, U-127
blockMesh executable
vertex numbering, U-132
blockMeshDict
dictionary, U-20, U-22, U-36, U-48, U-127,
U-136
blocks keyword, U-22, U-32, U-132
bound tools, U-91
boundaries, U-124
boundary, U-124
boundary
dictionary, U-121, U-127
boundary condition
calculated, U-128
cyclic, U-127
directionMixed, U-128
empty, P-63, P-69, U-20, U-122, U-127
ﬁxedGradient, U-128
ﬁxedValue, U-128
ﬂuxCorrectedVelocity, U-129
gammaContactAngle, U-57
inlet, P-69
inletOutlet, U-129
mixed, U-128
movingWallVelocity, U-129
outlet, P-69
outletInlet, U-129
partialSlip, U-129
patch, U-126
pressureDirectedInletVelocity, U-129
pressureInletVelocity, U-129
pressureOutlet, P-63
pressureTransmissive, U-129
processor, U-127
setup, U-22
slip, U-129
supersonicFreeStream, U-129
surfaceNormalFixedValue, U-129
symmetryPlane, P-63, U-126
totalPressure, U-129
turbulentInlet, U-129
wall, U-40
wall, P-63, P-69, U-57, U-126
wallBuoyantPressure, U-129
wedge, U-122, U-127, U-135
zeroGradient, U-128
boundary conditions, P-43
Dirichlet, P-43
inlet, P-44
Neumann, P-43
no-slip impermeable wall, P-44
outlet, P-44
physical, P-44
symmetry plane, P-44
boundary type
empty, U-187
boundaryField keyword, U-22, U-102
boundaryFoam solver, U-83
bounded
keyword entry, U-110, U-111
boxToCell keyword, U-58
boxTurb utility, U-86
breaking of a dam, U-55
bubbleFoam solver, U-84
buoyantFoam solver, U-85
buoyantSimpleRadiationFoam solver, U-85
buoyantSimpleFoam solver, U-85
button
Apply, U-156, U-160
Auto Accept, U-159
Choose Preset, U-158
Compact, U-187
Delete, U-156
Edit Color Map, U-157
Info, U-187
My Jobs, U-187
Orientation Axes, U-25, U-159
Rescale to Data Range, U-28
Reset, U-156
Set Solid Color, U-158
Update GUI, U-28, U-157
Use Parallel Projection, U-25
Use parallel projection, U-159
cont, U-187
endNow, U-187
end, U-187
kill, U-187
purge, U-187
read, U-187
status, U-187
suspend, U-187
C
C++ syntax
/*...*/, U-76
//, U-76
# include, U-70, U-76
cacheAgglomeration keyword, U-115
calculated
boundary condition, U-128
case
browser, U-180
server, U-186
case manager
FoamX (obsolete), U-177
Case Name text box, U-182
Case Root text box, U-182
cases, U-97
Open∇FOAM-1.5
Index U-197
castellatedMesh keyword, U-138
castellatedMeshControls
dictionary, U-139, U-141
castellatedMeshControls keyword, U-138
cavity ﬂow, U-19
ccm26ToFoam utility, U-86
CEI ARCH
environment variable, U-164
CEI HOME
environment variable, U-164
cell
expansion ratio, U-132
cell class, P-31
cell
keyword entry, U-166
cellDecompFiniteElement
library, U-91
cellPoint
keyword entry, U-166
cellPointFace
keyword entry, U-166
cells
dictionary, U-127
cellSet utility, U-87
central diﬀerencing, P-38
cfdTools
library, U-91
cfxToFoam utility, U-86, U-145
cGamma keyword, U-61
channelOodles solver, U-83
Chart Options window, U-35
checkMesh utility, U-87, U-146
checkYPlus utility, U-89
chemistryModel
library, U-93
chemistryModel model, U-93
chemistrySolver model, U-93
chemkinMixture model, U-93, U-172
chemkinToFoam utility, U-90
Choose Preset button, U-158
chtMultiRegionFoam solver, U-85
Class menu, U-182
class
cell, P-31
dimensionSet, P-25, P-32, P-33
face, P-31
ﬁniteVolumeCalculus, P-33
ﬁniteVolumeMethod, P-33
fvMesh, P-31
fvSchemes, P-36
fvc, P-36
fvm, P-36
pointField, P-31
polyBoundaryMesh, P-31
polyMesh, P-31, U-119, U-121
polyPatchList, P-31
polyPatch, P-31
scalarField, P-29
scalar, P-23
slice, P-31
symmTensorField, P-29
symmTensorThirdField, P-29
tensorField, P-29
tensorThirdField, P-29
tensor, P-23
vectorField, P-29
vector, P-23, U-101
word, P-25, P-31
class keyword, U-99
clockTime
keyword entry, U-105
cloud keyword, U-167
cmptAv
tensor member function, P-25
Co utility, U-88
cofactors
tensor member function, P-25
coldEngineFoam solver, U-85
Color By menu, U-158
Color Legend window, U-30
Color Legend window panel, U-158
Color Scale window panel, U-158
combustionThermophysicalModels
library, U-92
comments, U-76
Compact button, U-187
compressed
keyword entry, U-105
compressible tools, U-91
compressibleLesInterFoam solver, U-84
compressibleLESModels
library, U-95
compressibleRASModels
library, U-94
constant directory, U-98, U-171
constLaminarFlameSpeed model, U-93
constTransport model, U-93, U-172
cont button, U-187
containers tools, U-91
continuum
mechanics, P-15
control
of time, U-104
controlDict
dictionary, P-65, U-23, U-32, U-41, U-50,
U-59, U-98, U-151
controlDict ﬁle, P-49
convection, see divergence, P-38
Open∇FOAM-1.5
U-198 Index
convergence, U-39
convertToMeters keyword, U-131
coodles solver, U-84
coordinate
system, P-15
coordinate system, U-20
CORBA, U-92, U-177
corrected
keyword entry, U-110, U-111
couplePatches utility, U-87
Courant number, P-42, U-24
cpuTime
keyword entry, U-105
Crank Nicholson
temporal discretisation, P-42
CrankNicholson
keyword entry, U-112
createPatch utility, U-87
cross product, see tensor, vector cross product
CrossPowerLaw
keyword entry, U-58
CrossPowerLaw model, U-95
cubeRootVolDelta model, U-94
cubicCorrected
keyword entry, U-112
cubicCorrection
keyword entry, U-109
curl, P-37
curl
fvc member function, P-37
Current Time Controls menu, U-28, U-157
curve keyword, U-167
cyclic
boundary condition, U-127
cyclic
keyword entry, U-127
cylinder
ﬂow around a, P-45
D
d2dt2
fvc member function, P-37
fvm member function, P-37
dam
breaking of a, U-55
db tools, U-91
ddt
fvc member function, P-37
fvm member function, P-37
DeardorﬀDiﬀStress model, U-95
debug keyword, U-138
decomposePar utility, U-79, U-80, U-90
decomposeParDict
dictionary, U-79
decomposition
of ﬁeld, U-79
of mesh, U-79
decompression of a tank, P-62
defaultFieldValues keyword, U-58
deformedGeom utility, U-87
Delete button, U-156
delta keyword, U-81, U-174
deltaT keyword, U-104
dependencies, U-70
dependency lists, U-70
det
tensor member function, P-25
determinant, see tensor, determinant
dev
tensor member function, P-25
diag
tensor member function, P-25
diagonal
keyword entry, U-115
DIC
keyword entry, U-115
DICGaussSeidel
keyword entry, U-115
Dictionaries dictionary tree, U-188
dictionary
LESProperties, U-174
PISO, U-25
RASProperties, U-41, U-174
blockMeshDict, U-20, U-22, U-36, U-48,
U-127, U-136
boundary, U-121, U-127
castellatedMeshControls, U-139, U-141
cells, U-127
controlDict, P-65, U-23, U-32, U-41, U-50,
U-59, U-98, U-151
decomposeParDict, U-79
faces, U-121, U-127
fvSchemes, U-60, U-98, U-106, U-107
fvSolution, U-98, U-113
mechanicalProperties, U-49
neighbour, U-121
owner, U-121
points, U-121, U-127
thermalProperties, U-50
thermophysicalProperties, U-171
transportProperties, U-23, U-39, U-41
dictionary tree
Dictionaries, U-188
Fields, U-187
dieselEngineFoam solver, U-85
dieselFoam solver, U-85
dieselMixture model, U-92, U-172
dieselSpray
Open∇FOAM-1.5
Index U-199
library, U-92
diEthylEther model, U-93
diﬀerencing
Backward, P-39
blended, P-38
central, P-38
Euler implicit, P-39
Gamma, P-38
MINMOD, P-38
SUPERBEE, P-38
upwind, P-38
van Leer, P-38
DILU
keyword entry, U-115
dimension
checking in OpenFOAM, P-25, U-101
dimensional units, U-101
dimensioned<Type> template class, P-25
dimensionedTypes tools, U-91
dimensions keyword, U-22, U-102
dimensionSet class, P-25, P-32, P-33
dimensionSet tools, U-91
diMethylEther model, U-93
direct numerical simulation, U-60
directionMixed
boundary condition, U-128
directory
0.000000e+00, U-98
0, U-98
Make, U-71
constant, U-98, U-171
ﬂuentInterface, U-162
polyMesh, U-98, U-121
processorN, U-80
run, U-97
system, P-49, U-98
tutorials, P-45, U-19
discretisation
equation, P-33
Display window panel, U-25, U-28,
U-156, U-157
distance
keyword entry, U-141, U-167
distributed keyword, U-81, U-82
div
fvc member function, P-37
fvm member function, P-37
divergence, P-37, P-39
divSchemes keyword, U-107
divU utility, U-88
dnsFoam solver, U-85
doLayers keyword, U-138
double inner product, see tensor,double inner
product
dx
keyword entry, U-166
dynamicMesh
library, U-91
dynMixedSmagorinsky model, U-94
dynOneEqEddy model, U-94, U-95
dynSmagorinsky model, U-94
E
edgeGrading keyword, U-133
edgeMesh
library, U-92
edges keyword, U-131
Edit menu, U-159
Edit Color Map button, U-157
electrostaticFoam solver, U-85
empty
boundary condition, P-63, P-69, U-20,
U-122, U-127
empty boundary type, U-187
empty
keyword entry, U-127
end button, U-187
endNow button, U-187
endTime keyword, U-24, U-104
engine
library, U-92
engineCompRatio utility, U-90
engineFoam solver, U-85
engineSwirl utility, U-86
ensight74FoamExec utility, U-164
ensight76FoamExec utility, U-88
ENSIGHT7 INPUT
environment variable, U-164
ENSIGHT7 READER
environment variable, U-164
enstrophy utility, U-88
environment variable
CEI ARCH, U-164
CEI HOME, U-164
ENSIGHT7 INPUT, U-164
ENSIGHT7 READER, U-164
FOAMX PATH, U-192
FOAMX SYSTEM CONFIG, U-192
FOAMX USER CONFIG, U-192
FOAM RUN, U-97, U-192
JAVA HOME, U-192
WM ARCH, U-74
WM COMPILER BIN, U-74
WM COMPILER DIR, U-74
WM COMPILER LIB, U-74
WM COMPILER, U-74
WM COMPILE OPTION, U-74
WM DIR, U-74
Open∇FOAM-1.5
U-200 Index
WM JAVAC OPTION, U-74
WM LINK LANGUAGE, U-74
WM MPLIB, U-74
WM OPTIONS, U-74
WM PROJECT DIR, U-74
WM PROJECT INST DIR, U-74
WM PROJECT LANGUAGE, U-74
WM PROJECT USER DIR, U-74
WM PROJECT VERSION, U-74
WM PROJECT, U-74
WM SHELL, U-74
wmake, U-73
environmentalProperties ﬁle, U-58
equilibriumCO utility, U-90
equilibriumFlameT utility, U-90
errorEstimation
library, U-92
errorReduction keyword, U-145
estimateScalarError utility, U-90
Euler
keyword entry, U-112
Euler implicit
diﬀerencing, P-39
temporal discretisation, P-42
examples
decompression of a tank, P-62
ﬂow around a cylinder, P-45
ﬂow over backward step, P-53
Hartmann problem, P-67
supersonic ﬂow over forward step, P-58
expansionRatio keyword, U-144
explicit
temporal discretisation, P-42
exponential model, U-93
extrudeMesh utility, U-86
F
face class, P-31
face keyword, U-167
faceAreaPair
keyword entry, U-115
faceDecompFiniteElement
library, U-92
faces
dictionary, U-121, U-127
faceSet utility, U-87
FDIC
keyword entry, U-115
featureAngle keyword, U-144
features keyword, U-139
ﬁeld
U, U-24
p, U-24
decomposition, U-79
FieldField<Type> template class, P-32
Fields dictionary tree, U-187
ﬁelds, P-29
mapping, U-151
ﬁelds tools, U-91
fields keyword, U-166
Field<Type> template class, P-29
fieldValues keyword, U-58
ﬁle
FoamX.cfg, U-191
FoamXClient.cfg, U-178, U-191
Make/ﬁles, U-72
controlDict, P-49
environmentalProperties, U-58
ﬁles, U-71
options, U-71
snappyHexMeshDict, U-137
transportProperties, U-58
ﬁle format, U-98
ﬁles ﬁle, U-71
finalLayerRatio keyword, U-144
ﬁnancialFoam solver, U-86
ﬁnite volume
discretisation, P-27
mesh, P-31
ﬁniteVolume tools, U-91
ﬁniteVolumeCalculus class, P-33
ﬁniteVolumeMethod class, P-33
firstTime
menu entry, U-184
firstTime keyword, U-104
fixed
keyword entry, U-105
ﬁxedGradient
boundary condition, U-128
ﬁxedValue
boundary condition, U-128
ﬂattenMesh utility, U-87
ﬂow
free surface, U-55
laminar, U-19
steady, turbulent, P-53
supersonic, P-58
turbulent, U-19
ﬂow around a cylinder, P-45
ﬂow over backward step, P-53
ﬂowType utility, U-88
ﬂuentInterface directory, U-162
ﬂuentMeshToFoam utility, U-87, U-144
ﬂuxCorrectedVelocity
boundary condition, U-129
fluxRequired keyword, U-107
OpenFOAM
cases, U-97
Open∇FOAM-1.5
Index U-201
FOAM RUN
environment variable, U-97, U-192
foamCalc utility, U-33
foamCorrectVrt script/alias, U-150
foamDataToFluent utility, U-88, U-162
foamDebugSwitches utility, U-90
FoamFile keyword, U-99
foamFile
keyword entry, U-166
foamInfoExec utility, U-90
foamJob script/alias, U-169
foamLog script/alias, U-169
foamMeshToFluent utility, U-87, U-162
foamToEnsight utility, U-88
foamToFieldview9 utility, U-88
foamToGMV utility, U-88
foamToVTK utility, U-88
foamUser
library, U-78
FoamX (obsolete)
case browser, U-180
case manager, U-177
case server, U-186
OpenFOAM case manager, U-177
host browser, U-178
JAVA GUI, U-179
name server, U-178
FoamX utility, U-86
FoamX.cfg ﬁle, U-191
FOAMX PATH
environment variable, U-192
FOAMX SYSTEM CONFIG
environment variable, U-192
FOAMX USER CONFIG
environment variable, U-192
FoamXClient.cfg ﬁle, U-178, U-191
foreground
process, U-26
format keyword, U-99
fourth
keyword entry, U-110, U-111
functions keyword, U-106
fvc class, P-36
fvc member function
curl, P-37
d2dt2, P-37
ddt, P-37
div, P-37
gGrad, P-37
grad, P-37
laplacian, P-37
lsGrad, P-37
snGrad, P-37
snGradCorrection, P-37
sqrGradGrad, P-37
fvm class, P-36
fvm member function
d2dt2, P-37
ddt, P-37
div, P-37
laplacian, P-37
Su, P-37
SuSp, P-37
fvMatrix template class, P-33
fvMesh class, P-31
fvSchemes
dictionary, U-60, U-98, U-106, U-107
fvSchemes class, P-36
fvSchemes
menu entry, U-51
fvSolution
dictionary, U-98, U-113
G
gambitToFoam utility, U-87, U-144
GAMG
keyword entry, U-114, U-115
Gamma
keyword entry, U-109
Gamma diﬀerencing, P-38
gammaContactAngle
boundary condition, U-57
Gauss
keyword entry, U-110
Gauss’s theorem, P-36
GaussSeidel
keyword entry, U-115
General window panel, U-159
general model, U-93
general
keyword entry, U-105
geometric-algebraic multi-grid, U-115
GeometricBoundaryField template class, P-32
geometricField<Type> template class, P-32
geometry keyword, U-138
gGrad
fvc member function, P-37
global tools, U-91
gmshToFoam utility, U-87
gnemdFoam solver, U-86
gnuplot
keyword entry, U-105, U-166
grad
fvc member function, P-37
(Grad Grad) squared, P-37
gradient, P-37, P-40
Gauss scheme, P-40
Gauss’s theorem, U-51
Open∇FOAM-1.5
U-202 Index
least square ﬁt, U-51
least squares method, P-40, U-51
surface normal, P-40
gradSchemes keyword, U-107
graphFormat keyword, U-105
Gstream
library, U-92
guldersLaminarFlameSpeed model, U-93
H
hConstThermo model, U-93, U-171
Help menu, U-159
hhuMixtureThermo model, U-92, U-172
hierarchical
keyword entry, U-80, U-81
hMixtureThermo model, U-92, U-172
homogeneousMixture model, U-92, U-172
host
browser, U-178
hThermo model, U-92, U-172
I
I
tensor member function, P-25
icoDyMFoam solver, U-83
icoErrorEstimate utility, U-90
icoFoam solver, U-19, U-23, U-24, U-26, U-83
icoMomentError utility, U-90
ideasToFoam utility, U-145
ideasUnvToFoam utility, U-87
identities, see tensor, identities
identity, see tensor, identity
incompressible tools, U-91
incompressibleLESModels
library, U-94
incompressiblePostProcessing
library, U-91
incompressibleRASModels
library, U-94
incompressibleTransportModels
library, P-55, U-95
incompressibleTurbulenceModels
library, P-55
index
notation, P-16, P-17
Info button, U-187
Information window panel, U-156
inhomogeneousMixture model, U-92, U-172
inlet
boundary condition, P-69
inletOutlet
boundary condition, U-129
inner product, see tensor, inner product
inside
keyword entry, U-141
insideCells utility, U-87
interDyMFoam solver, U-84
interFoam solver, U-84
internalField keyword, U-22, U-102, U-187
interPhaseChangeFoam solver, U-84
interpolationScheme keyword, U-166
interpolations tools, U-91
interpolationSchemes keyword, U-107
inv
tensor member function, P-25
isoOctane model, U-93
J
janafThermo model, U-93, U-171
JAVA HOME
environment variable, U-192
jplot
keyword entry, U-105, U-166
K
kappa keyword, U-174
kEpsilon model, U-94
keyword
FoamFile, U-99
LESmodel, U-174
RASModel, U-174
addLayersControls, U-138
adjustTimeStep, U-59
agglomerator, U-115
arc, U-131
blocks, U-22, U-32, U-132
block, U-131
boundaryField, U-22, U-102
boxToCell, U-58
cGamma, U-61
cacheAgglomeration, U-115
castellatedMeshControls, U-138
castellatedMesh, U-138
class, U-99
cloud, U-167
convertToMeters, U-131
curve, U-167
debug, U-138
defaultFieldValues, U-58
deltaT, U-104
delta, U-81, U-174
dimensions, U-22, U-102
distributed, U-81, U-82
divSchemes, U-107
doLayers, U-138
edgeGrading, U-133
edges, U-131
endTime, U-24, U-104
Open∇FOAM-1.5
Index U-203
errorReduction, U-145
expansionRatio, U-144
face, U-167
featureAngle, U-144
features, U-139
fieldValues, U-58
fields, U-166
finalLayerRatio, U-144
firstTime, U-104
fluxRequired, U-107
format, U-99
functions, U-106
geometry, U-138
gradSchemes, U-107
graphFormat, U-105
internalField, U-22, U-102, U-187
interpolationSchemes, U-107
interpolationScheme, U-166
kappa, U-174
laplacianSchemes, U-107
latestTime, U-39
layers, U-144
leastSquares, U-51
levels, U-142
libs, U-106
locationInMesh, U-139, U-141
location, U-99
manualCoeffs, U-81
maxBoundarySkewness, U-145
maxConcave, U-145
maxCo, U-59
maxDeltaT, U-59
maxFaceThicknessRatio, U-144
maxGlobalCells, U-139
maxInternalSkewness, U-145
maxLocalCells, U-139
maxNonOrtho, U-145
maxThicknessToMedialRatio, U-144
mergeLevels, U-116
mergeTolerance, U-138
meshQualityControls, U-138
method, U-81
metisCoeffs, U-81
midPointAndFace, U-167
midPoint, U-167
minArea, U-145
minDeterminant, U-145
minFaceWeight, U-145
minFlatness, U-145
minMedianAxisAngle, U-144
minRefinementCells, U-139
minThickness, U-144
minTriangleTwist, U-145
minTwist, U-145
minVolRatio, U-145
minVol, U-145
mode, U-141
nBufferCellsNoExtrude, U-144
nCellsBetweenLevels, U-139
nFaces, U-122
nFinestSweeps, U-115, U-116
nGammaSubCycles, U-61
nGrow, U-144
nPostSweeps, U-115, U-116
nPreSweeps, U-115
nRelaxIter, U-142, U-144
nSmoothNormals, U-144
nSmoothPatch, U-142
nSmoothScale, U-145
nSmoothSurfaceNormals, U-144
nSmoothThickness, U-144
nSolveIter, U-142
numberOfSubdomains, U-81
n, U-81
object, U-99
order, U-81
pRefCell, U-25, U-117
pRefValue, U-25, U-117
patchMap, U-152
patches, U-131, U-133
pdRefCell, U-117
pdRefValue, U-117
preconditioner, U-114
pressure, U-49
processorWeights, U-81
purgeWrite, U-105
refGradient, U-128
referenceLevel, U-187
refinementRegions, U-139, U-142
refinementSurfaces, U-139
refinementRegions, U-141
regions, U-58
relTol, U-52, U-114
resolveFeatureAngle, U-139, U-140
roots, U-81, U-82
runTimeModifiable, U-105
setFormat, U-166
sets, U-166
simpleGrading, U-133
smoother, U-115
snGradSchemes, U-107
snapControls, U-138
snap, U-138
solvers, U-113
spline, U-131
startFace, U-122
startFrom, U-23, U-104
startTime, U-23, U-104
Open∇FOAM-1.5
U-204 Index
stopAt, U-104
surfaceFormat, U-166
surfaces, U-166
thermoType, U-171
timeFormat, U-105
timePrecision, U-105
timeScheme, U-107
tolerance, U-52, U-114, U-142
topoSetSource, U-58
traction, U-49
turbulence, U-174
type, U-124, U-125
uniform, U-167
valueFraction, U-128
value, U-23, U-128
version, U-99
vertices, U-22, U-131
wallFunctionCoeffs, U-174
writeCompression, U-105
writeControl, U-24, U-59, U-104
writeFormat, U-54, U-105
writeInterval, U-24, U-33, U-105
writePrecision, U-105
<LESmodel>Coeffs, U-174
<RASModel>Coeffs, U-174
<delta>Coeffs, U-174
keyword entry
CrankNicholson, U-112
CrossPowerLaw, U-58
DICGaussSeidel, U-115
DIC, U-115
DILU, U-115
Euler, U-112
FDIC, U-115
GAMG, U-114, U-115
Gamma, U-109
GaussSeidel, U-115
Gauss, U-110
MGridGen, U-115
MUSCL, U-109
Newtonian, U-58
PBiCG, U-114
PCG, U-114
QUICK, U-109, U-112
SFCD, U-109, U-112
UMIST, U-108
adjustableRunTime, U-59, U-105
arc, U-132
ascii, U-105
backward, U-112
binary, U-105
bounded, U-110, U-111
cellPointFace, U-166
cellPoint, U-166
cell, U-166
clockTime, U-105
compressed, U-105
corrected, U-110, U-111
cpuTime, U-105
cubicCorrected, U-112
cubicCorrection, U-109
cyclic, U-127
diagonal, U-115
distance, U-141, U-167
dx, U-166
empty, U-127
faceAreaPair, U-115
fixed, U-105
foamFile, U-166
fourth, U-110, U-111
general, U-105
gnuplot, U-105, U-166
hierarchical, U-80, U-81
inside, U-141
jplot, U-105, U-166
latestTime, U-104
leastSquares, U-110
limitedCubic, U-109
limitedLinear, U-109
limited, U-110, U-111
linearUpwind, U-109, U-112
linear, U-109, U-112
line, U-132
manual, U-80, U-81
metis, U-80, U-81
midPoint, U-109
nextWrite, U-104
noWriteNow, U-104
none, U-108, U-115
null, U-166
outside, U-141
patch, U-127, U-168
polyLine, U-132
polySpline, U-132
processor, U-127
raw, U-105, U-166
runTime, U-33, U-104
scientific, U-105
simpleSpline, U-132
simple, U-80, U-81
skewLinear, U-109, U-112
smoothSolver, U-114
startTime, U-23, U-104
steadyState, U-112
stl, U-166
symmetryPlane, U-127
timeStep, U-24, U-33, U-104
uncompressed, U-105
Open∇FOAM-1.5
Index U-205
uncorrected, U-110, U-111
upwind, U-109, U-112
vanLeer, U-109
vtk, U-166
wall, U-127
wedge, U-127
writeControl, U-104
writeNow, U-104
xmgr, U-105, U-166
xyz, U-167
x, U-167
y, U-167
z, U-167
kill button, U-187
kivaToFoam utility, U-87
Kronecker delta, P-20
L
lagrangian
library, U-92
Lambda2 utility, U-89
LamBremhorstKE model, U-94
laminar model, U-94
laminarFlameSpeedModels
library, U-93
laplaceFilter model, U-94
Laplacian, P-38
laplacian, P-37
laplacian
fvc member function, P-37
fvm member function, P-37
laplacianFoam solver, U-83
laplacianSchemes keyword, U-107
latestTime
keyword entry, U-104
menu entry, U-184
latestTime keyword, U-39
LaunderGibsonRSTM model, U-94
LaunderSharmaKE model, U-94
layers keyword, U-144
leastSquares
keyword entry, U-110
leastSquares keyword, U-51
lesBuoyantFoam solver, U-85
lesCavitatingFoam solver, U-84
LESdeltas
library, U-94
LESﬁlters
library, U-94
lesInterFoam solver, U-84
LESmodel keyword, U-174
LESProperties
dictionary, U-174
levels keyword, U-142
libraries, U-67
library
Gstream, U-92
LESdeltas, U-94
LESﬁlters, U-94
ODE, U-92
OpenFOAM, U-91
PV3FoamReader, U-155
PVFoamReader, U-155
basicThermophysicalModels, U-92
cellDecompFiniteElement, U-91
cfdTools, U-91
chemistryModel, U-93
combustionThermophysicalModels, U-92
compressibleLESModels, U-95
compressibleRASModels, U-94
dieselSpray, U-92
dynamicMesh, U-91
edgeMesh, U-92
engine, U-92
errorEstimation, U-92
faceDecompFiniteElement, U-92
foamUser, U-78
incompressibleLESModels, U-94
incompressiblePostProcessing, U-91
incompressibleRASModels, U-94
incompressibleTransportModels, P-55, U-95
incompressibleTurbulenceModels, P-55
lagrangian, U-92
laminarFlameSpeedModels, U-93
liquids, U-93
meshTools, U-92
mico-2.3.13, U-92
mpich-1.2.4, U-92
openmpi-1.2.6, U-92
pdf, U-93
primitive, P-23
randomProcesses, U-92
sampling, U-91
shapeMeshTools, U-92
specie, U-93
thermophysicalFunctions, U-93
thermophysical, U-171
triSurface, U-92
vtkFoam, U-155
vtkPV3Foam, U-155
zlib-1.2.3, U-92
libs keyword, U-106
lid-driven cavity ﬂow, U-19
LienCubicKE model, U-94
LienCubicKELowRE model, U-94
LienLeschzinerLowRE model, U-94
Lights window panel, U-159
limited
Open∇FOAM-1.5
U-206 Index
keyword entry, U-110, U-111
limitedCubic
keyword entry, U-109
limitedLinear
keyword entry, U-109
line
keyword entry, U-132
linear
keyword entry, U-109, U-112
linearUpwind
keyword entry, U-109, U-112
liquid
electrically-conducting, P-67
liquids
library, U-93
lists, P-29
List<Type> template class, P-29
location keyword, U-99
locationInMesh keyword, U-139, U-141
locDynOneEqEddy model, U-94
lowReOneEqEddy model, U-95
LRDDiﬀStress model, U-95
LRR model, U-94
lsGrad
fvc member function, P-37
M
Mach utility, U-89
mag
tensor member function, P-25
magGradU utility, U-89
magnetohydrodynamics, P-67
magSqr
tensor member function, P-25
magU utility, U-89
Make directory, U-71
make script/alias, U-69
Make/ﬁles ﬁle, U-72
manual
keyword entry, U-80, U-81
manualCoeffs keyword, U-81
mapFields utility, U-32, U-38, U-42, U-54, U-86,
U-151
mapping
ﬁelds, U-151
matrices tools, U-91
max
tensor member function, P-25
maxBoundarySkewness keyword, U-145
maxCo keyword, U-59
maxConcave keyword, U-145
maxDeltaT keyword, U-59
maxFaceThicknessRatio keyword, U-144
maxGlobalCells keyword, U-139
maxInternalSkewness keyword, U-145
maxLocalCells keyword, U-139
maxNonOrtho keyword, U-145
maxThicknessToMedialRatio keyword, U-144
mdEquilibrationFoam solver, U-86
mechanicalProperties
dictionary, U-49
menu
Class, U-182
Color By, U-158
Current Time Controls, U-28, U-157
Edit, U-159
Help, U-159
Plot Type, U-35
VCR Controls, U-28, U-157
View, U-159
menu entry
Plot Over Line, U-35
Save Animation, U-161
Save Screenshot, U-161
Settings, U-159
Show Color Legend, U-28
Solid Color, U-158
Toolbars, U-159
View Settings..., U-25
View Settings, U-25, U-159
Wireframe, U-158
allTime, U-184
firstTime, U-184
fvSchemes, U-51
latestTime, U-184
noTime, U-184
mergeLevels keyword, U-116
mergeMeshes utility, U-87
mergeTolerance keyword, U-138
mesh
1-dimensional, U-122
1D, U-122
2-dimensional, U-122
2D, U-122
axi-symmetric, U-122
basic, P-31
block structured, U-127
decomposition, U-79
description, U-119
ﬁnite volume, P-31
generation, U-127, U-136
grading, U-127, U-132
grading, example of, P-53
non-orthogonal, P-45
reﬁnement, P-62
resolution, U-30
speciﬁcation, U-119
split-hex, U-136
Open∇FOAM-1.5
Index U-207
Stereolithography (STL), U-136
surface, U-136
validity constraints, U-119
meshes tools, U-91
meshQualityControls keyword, U-138
meshTools
library, U-92
message passing interface
MPICH, U-193
openMPI, U-81
method keyword, U-81
metis
keyword entry, U-80, U-81
metisCoeffs keyword, U-81
MGridGen
keyword entry, U-115
mhdFoam solver, P-69, U-85
mico-2.3.13
library, U-92
midPoint
keyword entry, U-109
midPoint keyword, U-167
midPointAndFace keyword, U-167
min
tensor member function, P-25
minArea keyword, U-145
minDeterminant keyword, U-145
minFaceWeight keyword, U-145
minFlatness keyword, U-145
minMedianAxisAngle keyword, U-144
MINMOD diﬀerencing, P-38
minRefinementCells keyword, U-139
minThickness keyword, U-144
minTriangleTwist keyword, U-145
minTwist keyword, U-145
minVol keyword, U-145
minVolRatio keyword, U-145
mirrorMesh utility, U-87
mixed
boundary condition, U-128
mixedSmagorinsky model, U-94
mixtureAdiabaticFlameT utility, U-90
mode keyword, U-141
model
APIfunctions, U-93
BirdCarreau, U-95
CrossPowerLaw, U-95
DeardorﬀDiﬀStress, U-95
LRDDiﬀStress, U-95
LRR, U-94
LamBremhorstKE, U-94
LaunderGibsonRSTM, U-94
LaunderSharmaKE, U-94
LienCubicKELowRE, U-94
LienCubicKE, U-94
LienLeschzinerLowRE, U-94
NSRDSfunctions, U-93
Newtonian, U-95
NonlinearKEShih, U-94
PrandtlDelta, U-94
QZeta, U-94
RNGkEpsilon, U-94
RosinRammler, U-93
Smagorinsky2, U-94
Smagorinsky, U-94, U-95
SpalartAllmaras, U-94, U-95
anisotropicFilter, U-94
chemistryModel, U-93
chemistrySolver, U-93
chemkinMixture, U-93, U-172
constLaminarFlameSpeed, U-93
constTransport, U-93, U-172
cubeRootVolDelta, U-94
diEthylEther, U-93
diMethylEther, U-93
dieselMixture, U-92, U-172
dynMixedSmagorinsky, U-94
dynOneEqEddy, U-94, U-95
dynSmagorinsky, U-94
exponential, U-93
general, U-93
guldersLaminarFlameSpeed, U-93
hConstThermo, U-93, U-171
hMixtureThermo, U-92, U-172
hThermo, U-92, U-172
hhuMixtureThermo, U-92, U-172
homogeneousMixture, U-92, U-172
inhomogeneousMixture, U-92, U-172
isoOctane, U-93
janafThermo, U-93, U-171
kEpsilon, U-94
laminar, U-94
laplaceFilter, U-94
locDynOneEqEddy, U-94
lowReOneEqEddy, U-95
mixedSmagorinsky, U-94
multiComponentMixture, U-93, U-172
nDecane, U-93
nDodecane, U-93
nHeptane, U-93
nOctane, U-93
normal, U-93
oneEqEddy, U-94, U-95
perfectGas, U-93, U-171
pureMixture, U-92, U-172
scaleSimilarity, U-94
simpleFilter, U-94
smoothDelta, U-94
Open∇FOAM-1.5
U-208 Index
specieThermo, U-93, U-171
spectEddyVisc, U-95
sutherlandTransport, U-93, U-172
uniform, U-93
veryInhomogeneousMixture, U-92, U-172
water, U-93
momentScalarError utility, U-90
moveDynamicMesh utility, U-87
moveEngineMesh utility, U-87
moveMesh utility, U-87
movingWallVelocity
boundary condition, U-129
MPI
MPICH, U-193
openMPI, U-81
MPICH
message passing interface, U-193
MPI, U-193
mpich-1.2.4
library, U-92
mshToFoam utility, U-87
multiComponentMixture model, U-93, U-172
multigrid
geometric-algebraic, U-115
multiphaseInterFoam solver, U-84
MUSCL
keyword entry, U-109
My Jobs button, U-187
N
n keyword, U-81
nabla
operator, P-27
name
server, U-178
nBufferCellsNoExtrude keyword, U-144
nCellsBetweenLevels keyword, U-139
nDecane model, U-93
nDodecane model, U-93
neighbour
dictionary, U-121
netgenNeutralToFoam utility, U-87
Newtonian
keyword entry, U-58
Newtonian model, U-95
nextWrite
keyword entry, U-104
nFaces keyword, U-122
nFinestSweeps keyword, U-115, U-116
nGammaSubCycles keyword, U-61
nGrow keyword, U-144
nHeptane model, U-93
nOctane model, U-93
non-orthogonal mesh, P-45
none
keyword entry, U-108, U-115
NonlinearKEShih model, U-94
nonNewtonianIcoFoam solver, U-83
normal model, U-93
noTime
menu entry, U-184
noWriteNow
keyword entry, U-104
nPostSweeps keyword, U-115, U-116
nPreSweeps keyword, U-115
nRelaxIter keyword, U-142, U-144
nSmoothNormals keyword, U-144
nSmoothPatch keyword, U-142
nSmoothScale keyword, U-145
nSmoothSurfaceNormals keyword, U-144
nSmoothThickness keyword, U-144
nSolveIter keyword, U-142
NSRDSfunctions model, U-93
null
keyword entry, U-166
numberOfSubdomains keyword, U-81
O
object keyword, U-99
objToVTK utility, U-87
ODE
library, U-92
oneEqEddy model, U-94, U-95
oodles solver, U-83
Opacity text box, U-159
OpenFOAM
applications, U-67
ﬁle format, U-98
libraries, U-67
OpenFOAM
library, U-91
OpenFOAM ﬁle syntax
//, U-98
openMPI
message passing interface, U-81
MPI, U-81
openmpi-1.2.6
library, U-92
operator
scalar, P-28
vector, P-27
Options window, U-159
options ﬁle, U-71
order keyword, U-81
Orientation Axes button, U-25, U-159
outer product, see tensor, outer product
outlet
boundary condition, P-69
Open∇FOAM-1.5
Index U-209
outletInlet
boundary condition, U-129
outside
keyword entry, U-141
owner
dictionary, U-121
P
p ﬁeld, U-24
paraFoam, U-25, U-155
paraFoam utility, U-88
parallel
running, U-79
partialSlip
boundary condition, U-129
patch
boundary condition, U-126
patch
keyword entry, U-127, U-168
patchAverage utility, U-89
patches keyword, U-131, U-133
patchIntegrate utility, U-89
patchMap keyword, U-152
patchTool utility, U-87
PBiCG
keyword entry, U-114
PCG
keyword entry, U-114
pdf
library, U-93
pdRefCell keyword, U-117
pdRefValue keyword, U-117
PDRFoam solver, U-85
Pe utility, U-89
perfectGas model, U-93, U-171
permutation symbol, P-19
Pipeline Browser window, U-25, U-156
PISO
dictionary, U-25
Plot Over Line
menu entry, U-35
Plot Type menu, U-35
plot3dToFoam utility, U-87
pointField class, P-31
pointField<Type> template class, P-33
points
dictionary, U-121, U-127
pointSet utility, U-87
polyBoundaryMesh class, P-31
polyDualMesh utility, U-87
polyLine
keyword entry, U-132
polyMesh directory, U-98, U-121
polyMesh class, P-31, U-119, U-121
polyPatch class, P-31
polyPatchList class, P-31
polySpline
keyword entry, U-132
post-processing, U-155
post-processing
paraFoam, U-155
postChannel utility, U-90
potentialFoam solver, P-46, U-83
pow
tensor member function, P-25
PrandtlDelta model, U-94
preconditioner keyword, U-114
pRefCell keyword, U-25, U-117
pRefValue keyword, U-25, U-117
pressure keyword, U-49
pressure waves
in liquids, P-62
pressureDirectedInletVelocity
boundary condition, U-129
pressureInletVelocity
boundary condition, U-129
pressureOutlet
boundary condition, P-63
pressureTransmissive
boundary condition, U-129
primitive
library, P-23
primitives tools, U-91
process
background, U-26, U-79
foreground, U-26
processor
boundary condition, U-127
processor
keyword entry, U-127
processorN directory, U-80
processorWeights keyword, U-81
Properties window panel, U-26, U-156
ptot utility, U-90
pureMixture model, U-92, U-172
purge button, U-187
purgeWrite keyword, U-105
PV3FoamReader
library, U-155
PVFoamReader
library, U-155
Q
Q utility, U-89
QUICK
keyword entry, U-109, U-112
QZeta model, U-94
Open∇FOAM-1.5
U-210 Index
R
R utility, U-89
randomProcesses
library, U-92
rasCavitatingFoam solver, U-84
rasInterFoam solver, U-84
RASModel keyword, U-174
RASProperties
dictionary, U-41, U-174
raw
keyword entry, U-105, U-166
Rcomponents utility, U-89
reactingFoam solver, U-85
read button, U-187
reconstructPar utility, U-83, U-90
reconstructParMesh utility, U-90
referenceLevel keyword, U-187
refGradient keyword, U-128
refinementRegions keyword, U-141
refinementRegions keyword, U-139, U-142
refinementSurfaces keyword, U-139
reﬁneMesh utility, U-87
Region Status window panel, U-25
regions keyword, U-58
relative tolerance, U-114
relTol keyword, U-52, U-114
Render View window, U-160
Render View window panel, U-159
Render View Options window, U-159
renumberMesh utility, U-87
Rescale to Data Range button, U-28
Reset button, U-156
resolveFeatureAngle keyword, U-139, U-140
restart, U-39
Reynolds number, U-19, U-23
rhoCentralFoam solver, U-84
rhoPimpleFoam solver, U-84
rhoPorousSimpleFoam solver, U-84
rhopSonicFoam solver, U-84
rhoSimpleFoam solver, U-84
rhoSonicFoam solver, U-84
rhoTurbFoam solver, U-84
rmdepall script/alias, U-74
RNGkEpsilon model, U-94
roots keyword, U-81, U-82
RosinRammler model, U-93
rotateMesh utility, U-88
run
parallel, U-79
run directory, U-97
runFoamX script/alias, U-177–U-179
runFoamXHB script/alias, U-177, U-178
runTime
keyword entry, U-33, U-104
runTimeModifiable keyword, U-105
S
sammToFoam utility, U-87
sample utility, U-90, U-165
sampleSurface utility, U-90
sampling
library, U-91
Save Animation
menu entry, U-161
Save Screenshot
menu entry, U-161
scalar, P-16
operator, P-28
scalar class, P-23
scalarField class, P-29
scalarTransportFoam solver, U-83
scale
tensor member function, P-25
scalePoints utility, U-148
scaleSimilarity model, U-94
scientific
keyword entry, U-105
script/alias
foamCorrectVrt, U-150
foamJob, U-169
foamLog, U-169
make, U-69
rmdepall, U-74
runFoamXHB, U-177, U-178
runFoamX, U-177–U-179
wclean, U-73
wmake, U-69
second time derivative, P-37
Seed window, U-160
Set Solid Color button, U-158
setFields utility, U-57, U-58, U-86
setFormat keyword, U-166
sets keyword, U-166
Settings
menu entry, U-159
settlingFoam solver, U-85
SFCD
keyword entry, U-109, U-112
shape, U-132
shapeMeshTools
library, U-92
Show Color Legend
menu entry, U-28
SI units, U-101
simple
keyword entry, U-80, U-81
simpleFilter model, U-94
simpleFoam solver, P-54, U-83
Open∇FOAM-1.5
Index U-211
simpleGrading keyword, U-133
simpleSpline
keyword entry, U-132
skew
tensor member function, P-25
skewLinear
keyword entry, U-109, U-112
slice class, P-31
slip
boundary condition, U-129
Smagorinsky model, U-94, U-95
Smagorinsky2 model, U-94
smapToFoam utility, U-88
smoothDelta model, U-94
smoother keyword, U-115
smoothSolver
keyword entry, U-114
snap keyword, U-138
snapControls keyword, U-138
snappyHexMesh utility
background mesh, U-138
cell removal, U-140
cell splitting, U-139
mesh layers, U-142
meshing process, U-137
snapping to surfaces, U-142
snappyHexMesh utility, U-136
snappyHexMeshDict ﬁle, U-137
snGrad
fvc member function, P-37
snGradCorrection
fvc member function, P-37
snGradSchemes keyword, U-107
Solid Color
menu entry, U-158
solidDisplacementFoam solver, U-50, U-85
solidEquilibriumDisplacementFoam solver, U-86
solver
PDRFoam, U-85
XiFoam, U-85
Xoodles, U-85
blockMesh, P-47
boundaryFoam, U-83
bubbleFoam, U-84
buoyantFoam, U-85
buoyantSimpleFoam, U-85
buoyantSimpleRadiationFoam, U-85
channelOodles, U-83
chtMultiRegionFoam, U-85
coldEngineFoam, U-85
compressibleLesInterFoam, U-84
coodles, U-84
dieselEngineFoam, U-85
dieselFoam, U-85
dnsFoam, U-85
electrostaticFoam, U-85
engineFoam, U-85
ﬁnancialFoam, U-86
gnemdFoam, U-86
icoDyMFoam, U-83
icoFoam, U-19, U-23, U-24, U-26, U-83
interDyMFoam, U-84
interFoam, U-84
interPhaseChangeFoam, U-84
laplacianFoam, U-83
lesBuoyantFoam, U-85
lesCavitatingFoam, U-84
lesInterFoam, U-84
mdEquilibrationFoam, U-86
mhdFoam, P-69, U-85
multiphaseInterFoam, U-84
nonNewtonianIcoFoam, U-83
oodles, U-83
potentialFoam, P-46, U-83
rasCavitatingFoam, U-84
rasInterFoam, U-84
reactingFoam, U-85
rhoCentralFoam, U-84
rhoPimpleFoam, U-84
rhoPorousSimpleFoam, U-84
rhoSimpleFoam, U-84
rhoSonicFoam, U-84
rhoTurbFoam, U-84
rhopSonicFoam, U-84
scalarTransportFoam, U-83
settlingFoam, U-85
simpleFoam, P-54, U-83
solidDisplacementFoam, U-50, U-85
solidEquilibriumDisplacementFoam, U-86
sonicFoamAutoMotion, U-84
sonicFoam, P-60, U-84
sonicLiquidFoam, P-63, U-84
sonicTurbFoam, U-84
turbDyMFoam, U-84
turbFoam, U-19, U-84
twoLiquidMixingFoam, U-85
twoPhaseEulerFoam, U-85
solver relative tolerance, U-114
solver tolerance, U-114
solvers keyword, U-113
sonicFoam solver, P-60, U-84
sonicFoamAutoMotion solver, U-84
sonicLiquidFoam solver, P-63, U-84
sonicTurbFoam solver, U-84
source, P-37
SpalartAllmaras model, U-94, U-95
specie
library, U-93
Open∇FOAM-1.5
U-212 Index
specieThermo model, U-93, U-171
spectEddyVisc model, U-95
spline keyword, U-131
splitMesh utility, U-88
splitMeshRegions utility, U-88
sqr
tensor member function, P-25
sqrGradGrad
fvc member function, P-37
startFace keyword, U-122
startFrom keyword, U-23, U-104
starToFoam utility, U-87, U-144
startTime
keyword entry, U-23, U-104
startTime keyword, U-23, U-104
status button, U-187
steady ﬂow
turbulent, P-53
steadyState
keyword entry, U-112
Stereolithography (STL), U-136
stitchMesh utility, U-88
stl
keyword entry, U-166
stopAt keyword, U-104
streamFunction utility, U-89
stress analysis of plate with hole, U-45
stressComponents utility, U-89
Style window panel, U-25, U-158
Su
fvm member function, P-37
subsetMesh utility, U-88
summation convention, P-17
SUPERBEE diﬀerencing, P-38
supersonic ﬂow, P-58
supersonic ﬂow over forward step, P-58
supersonicFreeStream
boundary condition, U-129
surface mesh, U-136
surfaceField<Type> template class, P-33
surfaceFormat keyword, U-166
surfaceNormalFixedValue
boundary condition, U-129
surfaces keyword, U-166
SuSp
fvm member function, P-37
suspend button, U-187
sutherlandTransport model, U-93, U-172
symm
tensor member function, P-25
symmetryPlane
boundary condition, P-63, U-126
symmetryPlane
keyword entry, U-127
symmTensorField class, P-29
symmTensorThirdField class, P-29
system directory, P-49, U-98
T
T()
tensor member function, P-25
template class
GeometricBoundaryField, P-32
fvMatrix, P-33
dimensioned<Type>, P-25
FieldField<Type>, P-32
Field<Type>, P-29
geometricField<Type>, P-32
List<Type>, P-29
pointField<Type>, P-33
surfaceField<Type>, P-33
volField<Type>, P-33
temporal discretisation, P-42
Crank Nicholson, P-42
Euler implicit, P-42
explicit, P-42
in OpenFOAM, P-43
tensor, P-15
addition, P-17
algebraic operations, P-17
algebraic operations in OpenFOAM, P-23
antisymmetric, see tensor, skew
calculus, P-27
classes in OpenFOAM, P-23
cofactors, P-22
component average, P-20
component maximum, P-20
component minimum, P-20
determinant, P-22
deviatoric, P-21
diagonal, P-21
dimension, P-16
double inner product, P-19
geometric transformation, P-20
Hodge dual, P-22
hydrostatic, P-21
identities, P-21
identity, P-20
inner product, P-18
inverse, P-22
magnitude, P-20
magnitude squared, P-20
mathematics, P-15
notation, P-17
nth power, P-20
outer product, P-19
rank, P-16
rank 3, P-16
Open∇FOAM-1.5
Index U-213
scalar division, P-18
scalar multiplication, P-17
scale function, P-20
second rank, P-16
skew, P-21
square of, P-20
subtraction, P-17
symmetric, P-21
symmetric rank 2, P-16
symmetric rank 3, P-16
trace, P-21
transformation, P-20
transpose, P-16, P-21
triple inner product, P-19
vector cross product, P-19
tensor class, P-23
tensor member function
*, P-25
+, P-25
-, P-25
/, P-25
&, P-25
&&, P-25
^, P-25
cmptAv, P-25
cofactors, P-25
det, P-25
dev, P-25
diag, P-25
I, P-25
inv, P-25
mag, P-25
magSqr, P-25
max, P-25
min, P-25
pow, P-25
scale, P-25
skew, P-25
sqr, P-25
symm, P-25
T(), P-25
tr, P-25
transform, P-25
tensorField class, P-29
tensorThirdField class, P-29
tetDecomposition utility, U-88
tetgenToFoam utility, U-87
text box
Case Name, U-182
Case Root, U-182
Opacity, U-159
thermalProperties
dictionary, U-50
thermophysical
library, U-171
thermophysicalFunctions
library, U-93
thermophysicalProperties
dictionary, U-171
thermoType keyword, U-171
time
control, U-104
time derivative, P-37
ﬁrst, P-39
second, P-37, P-39
time step, U-24
timeFormat keyword, U-105
timePrecision keyword, U-105
timeScheme keyword, U-107
timeStep
keyword entry, U-24, U-33, U-104
tolerance
solver, U-114
solver relative, U-114
tolerance keyword, U-52, U-114, U-142
Toolbars
menu entry, U-159
tools
adjustPhi, U-91
algorithms, U-91
bound, U-91
compressible, U-91
containers, U-91
db, U-91
dimensionSet, U-91
dimensionedTypes, U-91
ﬁelds, U-91
ﬁniteVolume, U-91
global, U-91
incompressible, U-91
interpolations, U-91
matrices, U-91
meshes, U-91
primitives, U-91
wallDist, U-91
topoSetSource keyword, U-58
totalPressure
boundary condition, U-129
tr
tensor member function, P-25
trace, see tensor, trace
traction keyword, U-49
transform
tensor member function, P-25
transformPoints utility, U-88
transportProperties
dictionary, U-23, U-39, U-41
transportProperties ﬁle, U-58
Open∇FOAM-1.5
U-214 Index
triple inner product, P-19
triSurface
library, U-92
turbDyMFoam solver, U-84
turbFoam solver, U-19, U-84
turbulence
dissipation, U-40
kinetic energy, U-40
length scale, U-41
model, U-41
turbulence keyword, U-174
turbulence model
RAS, U-40
turbulent ﬂow
steady, P-53
turbulentInlet
boundary condition, U-129
tutorials
breaking of a dam, U-55
lid-driven cavity ﬂow, U-19
stress analysis of plate with hole, U-45
tutorials directory, P-45, U-19
twoLiquidMixingFoam solver, U-85
twoPhaseEulerFoam solver, U-85
type keyword, U-124, U-125
U
U ﬁeld, U-24
Ucomponents utility, P-70, U-89
UMIST
keyword entry, U-108
uncompressed
keyword entry, U-105
uncorrected
keyword entry, U-110, U-111
uniform model, U-93
uniform keyword, U-167
units
base, U-101
of measurement, P-25, U-101
S.I. base, P-25
SI, U-101
Syst`eme International, U-101
United States Customary System, U-101
USCS, U-101
Update GUI button, U-28, U-157
uprime utility, U-89
upwind
keyword entry, U-109, U-112
upwind diﬀerencing, P-38, U-60
USCS units, U-101
Use Parallel Projection button, U-25
Use parallel projection button, U-159
utility
Co, U-88
FoamX, U-86
Lambda2, U-89
Mach, U-89
Pe, U-89
Q, U-89
Rcomponents, U-89
R, U-89
Ucomponents, P-70, U-89
adiabaticFlameT, U-90
ansysToFoam, U-86
attachMesh, U-87
autoPatch, U-87
blockMesh, U-38, U-86, U-127
boxTurb, U-86
ccm26ToFoam, U-86
cellSet, U-87
cfxToFoam, U-86, U-145
checkMesh, U-87, U-146
checkYPlus, U-89
chemkinToFoam, U-90
couplePatches, U-87
createPatch, U-87
decomposePar, U-79, U-80, U-90
deformedGeom, U-87
divU, U-88
engineCompRatio, U-90
engineSwirl, U-86
ensight74FoamExec, U-164
ensight76FoamExec, U-88
enstrophy, U-88
equilibriumCO, U-90
equilibriumFlameT, U-90
estimateScalarError, U-90
extrudeMesh, U-86
faceSet, U-87
ﬂattenMesh, U-87
ﬂowType, U-88
ﬂuentMeshToFoam, U-87, U-144
foamCalc, U-33
foamDataToFluent, U-88, U-162
foamDebugSwitches, U-90
foamInfoExec, U-90
foamMeshToFluent, U-87, U-162
foamToEnsight, U-88
foamToFieldview9, U-88
foamToGMV, U-88
foamToVTK, U-88
gambitToFoam, U-87, U-144
gmshToFoam, U-87
icoErrorEstimate, U-90
icoMomentError, U-90
ideasToFoam, U-145
ideasUnvToFoam, U-87
Open∇FOAM-1.5
Index U-215
insideCells, U-87
kivaToFoam, U-87
magGradU, U-89
magU, U-89
mapFields, U-32, U-38, U-42, U-54, U-86,
U-151
mergeMeshes, U-87
mirrorMesh, U-87
mixtureAdiabaticFlameT, U-90
momentScalarError, U-90
moveDynamicMesh, U-87
moveEngineMesh, U-87
moveMesh, U-87
mshToFoam, U-87
netgenNeutralToFoam, U-87
objToVTK, U-87
paraFoam, U-88
patchAverage, U-89
patchIntegrate, U-89
patchTool, U-87
plot3dToFoam, U-87
pointSet, U-87
polyDualMesh, U-87
postChannel, U-90
ptot, U-90
reconstructParMesh, U-90
reconstructPar, U-83, U-90
reﬁneMesh, U-87
renumberMesh, U-87
rotateMesh, U-88
sammToFoam, U-87
sampleSurface, U-90
sample, U-90, U-165
scalePoints, U-148
setFields, U-57, U-58, U-86
smapToFoam, U-88
snappyHexMesh, U-136
splitMeshRegions, U-88
splitMesh, U-88
starToFoam, U-87, U-144
stitchMesh, U-88
streamFunction, U-89
stressComponents, U-89
subsetMesh, U-88
tetDecomposition, U-88
tetgenToFoam, U-87
transformPoints, U-88
uprime, U-89
vorticity, U-89
wallGradU, U-89
wallHeatFlux, U-89
wallShearStress, U-89
wdot, U-90
writeCellCentres, U-90
writeMeshObj, U-87
yPlusLES, U-89
zipUpMesh, U-88
V
value keyword, U-23, U-128
valueFraction keyword, U-128
van Leer diﬀerencing, P-38
vanLeer
keyword entry, U-109
VCR Controls menu, U-28, U-157
vector, P-16
operator, P-27
unit, P-20
vector class, P-23, U-101
vector product, see tensor, vector cross product
vectorField class, P-29
version keyword, U-99
vertices keyword, U-22, U-131
veryInhomogeneousMixture model, U-92, U-172
View menu, U-159
View Settings
menu entry, U-25, U-159
View Settings...
menu entry, U-25
viscosity
kinematic, U-23, U-41
volField<Type> template class, P-33
vorticity utility, U-89
vtk
keyword entry, U-166
vtkFoam
library, U-155
vtkPV3Foam
library, U-155
W
wall
boundary condition, P-63, P-69, U-57,
U-126
wall
keyword entry, U-127
wall function, U-94
wallBuoyantPressure
boundary condition, U-129
wallDist tools, U-91
wallFunctionCoeffs keyword, U-174
wallGradU utility, U-89
wallHeatFlux utility, U-89
wallShearStress utility, U-89
water model, U-93
wclean script/alias, U-73
wdot utility, U-90
wedge
Open∇FOAM-1.5
U-216 Index
boundary condition, U-122, U-127, U-135
wedge
keyword entry, U-127
window
Chart Options, U-35
Color Legend, U-30
Options, U-159
Pipeline Browser, U-25, U-156
Render View Options, U-159
Render View, U-160
Seed, U-160
window panel
Annotation, U-25, U-159
Color Legend, U-158
Color Scale, U-158
Display, U-25, U-28, U-156, U-157
General, U-159
Information, U-156
Lights, U-159
Properties, U-26, U-156
Region Status, U-25
Render View, U-159
Style, U-25, U-158
Wireframe
menu entry, U-158
WM ARCH
environment variable, U-74
WM COMPILE OPTION
environment variable, U-74
WM COMPILER
environment variable, U-74
WM COMPILER BIN
environment variable, U-74
WM COMPILER DIR
environment variable, U-74
WM COMPILER LIB
environment variable, U-74
WM DIR
environment variable, U-74
WM JAVAC OPTION
environment variable, U-74
WM LINK LANGUAGE
environment variable, U-74
WM MPLIB
environment variable, U-74
WM OPTIONS
environment variable, U-74
WM PROJECT
environment variable, U-74
WM PROJECT DIR
environment variable, U-74
WM PROJECT INST DIR
environment variable, U-74
WM PROJECT LANGUAGE
environment variable, U-74
WM PROJECT USER DIR
environment variable, U-74
WM PROJECT VERSION
environment variable, U-74
WM SHELL
environment variable, U-74
wmake
platforms, U-71
wmake script/alias, U-69
word class, P-25, P-31
writeCellCentres utility, U-90
writeCompression keyword, U-105
writeControl
keyword entry, U-104
writeControl keyword, U-24, U-59, U-104
writeFormat keyword, U-54, U-105
writeInterval keyword, U-24, U-33, U-105
writeMeshObj utility, U-87
writeNow
keyword entry, U-104
writePrecision keyword, U-105
X
x
keyword entry, U-167
XiFoam solver, U-85
xmgr
keyword entry, U-105, U-166
Xoodles solver, U-85
xyz
keyword entry, U-167
Y
y
keyword entry, U-167
yPlusLES utility, U-89
Z
z
keyword entry, U-167
zeroGradient
boundary condition, U-128
zipUpMesh utility, U-88
zlib-1.2.3
library, U-92
Open∇FOAM-1.5
