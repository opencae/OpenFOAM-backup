Open∇FOAM
The Open Source CFD Toolbox
User Guide
Version 2.2.0
22nd February 2013
U-2
Copyright © 2011-2013 OpenFOAM Foundation.
This work is licensed under a Creative Commons Attribution-NonCommercial-
NoDerivs 3.0 Unported License.
Typeset in LATEX.
License
THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CRE-
ATIVE COMMONS PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PRO-
TECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE
WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW
IS PROHIBITED.
BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND
AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS
LICENSE MAY BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU
THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF
SUCH TERMS AND CONDITIONS.
1. Deﬁnitions
a. “Adaptation” means a work based upon the Work, or upon the Work and other pre-
existing works, such as a translation, adaptation, derivative work, arrangement of music
or other alterations of a literary or artistic work, or phonogram or performance and
includes cinematographic adaptations or any other form in which the Work may be recast,
transformed, or adapted including in any form recognizably derived from the original,
except that a work that constitutes a Collection will not be considered an Adaptation
for the purpose of this License. For the avoidance of doubt, where the Work is a musical
work, performance or phonogram, the synchronization of the Work in timed-relation with
a moving image (“synching”) will be considered an Adaptation for the purpose of this
License.
b. “Collection” means a collection of literary or artistic works, such as encyclopedias and
anthologies, or performances, phonograms or broadcasts, or other works or subject mat-
ter other than works listed in Section 1(f) below, which, by reason of the selection and
arrangement of their contents, constitute intellectual creations, in which the Work is in-
cluded in its entirety in unmodiﬁed form along with one or more other contributions, each
constituting separate and independent works in themselves, which together are assembled
into a collective whole. A work that constitutes a Collection will not be considered an
Adaptation (as deﬁned above) for the purposes of this License.
c. “Distribute” means to make available to the public the original and copies of the Work
through sale or other transfer of ownership.
d. “Licensor” means the individual, individuals, entity or entities that oﬀer(s) the Work
under the terms of this License.
e. “Original Author” means, in the case of a literary or artistic work, the individual, individ-
uals, entity or entities who created the Work or if no individual or entity can be identiﬁed,
the publisher; and in addition (i) in the case of a performance the actors, singers, mu-
sicians, dancers, and other persons who act, sing, deliver, declaim, play in, interpret or
otherwise perform literary or artistic works or expressions of folklore; (ii) in the case of
a phonogram the producer being the person or legal entity who ﬁrst ﬁxes the sounds of
Open∇FOAM-2.2.0
U-3
a performance or other sounds; and, (iii) in the case of broadcasts, the organization that
transmits the broadcast.
f. “Work” means the literary and/or artistic work oﬀered under the terms of this License
including without limitation any production in the literary, scientiﬁc and artistic domain,
whatever may be the mode or form of its expression including digital form, such as a
book, pamphlet and other writing; a lecture, address, sermon or other work of the same
nature; a dramatic or dramatico-musical work; a choreographic work or entertainment in
dumb show; a musical composition with or without words; a cinematographic work to
which are assimilated works expressed by a process analogous to cinematography; a work
of drawing, painting, architecture, sculpture, engraving or lithography; a photographic
work to which are assimilated works expressed by a process analogous to photography; a
work of applied art; an illustration, map, plan, sketch or three-dimensional work relative to
geography, topography, architecture or science; a performance; a broadcast; a phonogram;
a compilation of data to the extent it is protected as a copyrightable work; or a work
performed by a variety or circus performer to the extent it is not otherwise considered a
literary or artistic work.
g. “You” means an individual or entity exercising rights under this License who has not
previously violated the terms of this License with respect to the Work, or who has re-
ceived express permission from the Licensor to exercise rights under this License despite
a previous violation.
h. “Publicly Perform” means to perform public recitations of the Work and to communicate
to the public those public recitations, by any means or process, including by wire or
wireless means or public digital performances; to make available to the public Works in
such a way that members of the public may access these Works from a place and at a
place individually chosen by them; to perform the Work to the public by any means or
process and the communication to the public of the performances of the Work, including
by public digital performance; to broadcast and rebroadcast the Work by any means
including signs, sounds or images.
i. “Reproduce” means to make copies of the Work by any means including without limitation
by sound or visual recordings and the right of ﬁxation and reproducing ﬁxations of the
Work, including storage of a protected performance or phonogram in digital form or other
electronic medium.
2. Fair Dealing Rights.
Nothing in this License is intended to reduce, limit, or restrict any uses free from copyright
or rights arising from limitations or exceptions that are provided for in connection with the
copyright protection under copyright law or other applicable laws.
3. License Grant.
Subject to the terms and conditions of this License, Licensor hereby grants You a worldwide,
royalty-free, non-exclusive, perpetual (for the duration of the applicable copyright) license to
exercise the rights in the Work as stated below:
a. to Reproduce the Work, to incorporate the Work into one or more Collections, and to
Reproduce the Work as incorporated in the Collections;
b. and, to Distribute and Publicly Perform the Work including as incorporated in Collections.
The above rights may be exercised in all media and formats whether now known or hereafter
devised. The above rights include the right to make such modiﬁcations as are technically
necessary to exercise the rights in other media and formats, but otherwise you have no rights
Open∇FOAM-2.2.0
U-4
to make Adaptations. Subject to 8(f), all rights not expressly granted by Licensor are hereby
reserved, including but not limited to the rights set forth in Section 4(d).
4. Restrictions.
The license granted in Section 3 above is expressly made subject to and limited by the following
restrictions:
a. You may Distribute or Publicly Perform the Work only under the terms of this License.
You must include a copy of, or the Uniform Resource Identiﬁer (URI) for, this License
with every copy of the Work You Distribute or Publicly Perform. You may not oﬀer or
impose any terms on the Work that restrict the terms of this License or the ability of the
recipient of the Work to exercise the rights granted to that recipient under the terms of
the License. You may not sublicense the Work. You must keep intact all notices that
refer to this License and to the disclaimer of warranties with every copy of the Work You
Distribute or Publicly Perform. When You Distribute or Publicly Perform the Work,
You may not impose any eﬀective technological measures on the Work that restrict the
ability of a recipient of the Work from You to exercise the rights granted to that recipient
under the terms of the License. This Section 4(a) applies to the Work as incorporated
in a Collection, but this does not require the Collection apart from the Work itself to be
made subject to the terms of this License. If You create a Collection, upon notice from
any Licensor You must, to the extent practicable, remove from the Collection any credit
as required by Section 4(c), as requested.
b. You may not exercise any of the rights granted to You in Section 3 above in any manner
that is primarily intended for or directed toward commercial advantage or private mon-
etary compensation. The exchange of the Work for other copyrighted works by means
of digital ﬁle-sharing or otherwise shall not be considered to be intended for or directed
toward commercial advantage or private monetary compensation, provided there is no
payment of any monetary compensation in connection with the exchange of copyrighted
works.
c. If You Distribute, or Publicly Perform the Work or Collections, You must, unless a request
has been made pursuant to Section 4(a), keep intact all copyright notices for the Work and
provide, reasonable to the medium or means You are utilizing: (i) the name of the Original
Author (or pseudonym, if applicable) if supplied, and/or if the Original Author and/or
Licensor designate another party or parties (e.g., a sponsor institute, publishing entity,
journal) for attribution (“Attribution Parties”) in Licensor’s copyright notice, terms of
service or by other reasonable means, the name of such party or parties; (ii) the title of the
Work if supplied; (iii) to the extent reasonably practicable, the URI, if any, that Licensor
speciﬁes to be associated with the Work, unless such URI does not refer to the copyright
notice or licensing information for the Work. The credit required by this Section 4(c)
may be implemented in any reasonable manner; provided, however, that in the case of a
Collection, at a minimum such credit will appear, if a credit for all contributing authors
of Collection appears, then as part of these credits and in a manner at least as prominent
as the credits for the other contributing authors. For the avoidance of doubt, You may
only use the credit required by this Section for the purpose of attribution in the manner
set out above and, by exercising Your rights under this License, You may not implicitly
or explicitly assert or imply any connection with, sponsorship or endorsement by the
Original Author, Licensor and/or Attribution Parties, as appropriate, of You or Your
use of the Work, without the separate, express prior written permission of the Original
Author, Licensor and/or Attribution Parties.
d. For the avoidance of doubt:
Open∇FOAM-2.2.0
U-5
i. Non-waivable Compulsory License Schemes. In those jurisdictions in which
the right to collect royalties through any statutory or compulsory licensing scheme
cannot be waived, the Licensor reserves the exclusive right to collect such royalties
for any exercise by You of the rights granted under this License;
ii. Waivable Compulsory License Schemes. In those jurisdictions in which the
right to collect royalties through any statutory or compulsory licensing scheme can
be waived, the Licensor reserves the exclusive right to collect such royalties for any
exercise by You of the rights granted under this License if Your exercise of such
rights is for a purpose or use which is otherwise than noncommercial as permitted
under Section 4(b) and otherwise waives the right to collect royalties through any
statutory or compulsory licensing scheme; and,
iii. Voluntary License Schemes. The Licensor reserves the right to collect royalties,
whether individually or, in the event that the Licensor is a member of a collecting
society that administers voluntary licensing schemes, via that society, from any
exercise by You of the rights granted under this License that is for a purpose or use
which is otherwise than noncommercial as permitted under Section 4(b).
e. Except as otherwise agreed in writing by the Licensor or as may be otherwise permitted
by applicable law, if You Reproduce, Distribute or Publicly Perform the Work either by
itself or as part of any Collections, You must not distort, mutilate, modify or take other
derogatory action in relation to the Work which would be prejudicial to the Original
Author’s honor or reputation.
5. Representations, Warranties and Disclaimer
UNLESS OTHERWISE MUTUALLY AGREED BY THE PARTIES IN WRITING, LICEN-
SOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES
OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTH-
ERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHAN-
TIBILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE
ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF
ABSENCE OF ERRORS, WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS
DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION
MAY NOT APPLY TO YOU.
6. Limitation on Liability.
EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL
LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCI-
DENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT
OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN AD-
VISED OF THE POSSIBILITY OF SUCH DAMAGES.
7. Termination
a. This License and the rights granted hereunder will terminate automatically upon any
breach by You of the terms of this License. Individuals or entities who have received
Collections from You under this License, however, will not have their licenses terminated
provided such individuals or entities remain in full compliance with those licenses. Sections
1, 2, 5, 6, 7, and 8 will survive any termination of this License.
b. Subject to the above terms and conditions, the license granted here is perpetual (for the
duration of the applicable copyright in the Work). Notwithstanding the above, Licensor
reserves the right to release the Work under diﬀerent license terms or to stop distributing
the Work at any time; provided, however that any such election will not serve to withdraw
Open∇FOAM-2.2.0
U-6
this License (or any other license that has been, or is required to be, granted under
the terms of this License), and this License will continue in full force and eﬀect unless
terminated as stated above.
8. Miscellaneous
a. Each time You Distribute or Publicly Perform the Work or a Collection, the Licensor
oﬀers to the recipient a license to the Work on the same terms and conditions as the
license granted to You under this License.
b. If any provision of this License is invalid or unenforceable under applicable law, it shall
not aﬀect the validity or enforceability of the remainder of the terms of this License, and
without further action by the parties to this agreement, such provision shall be reformed
to the minimum extent necessary to make such provision valid and enforceable.
c. No term or provision of this License shall be deemed waived and no breach consented to
unless such waiver or consent shall be in writing and signed by the party to be charged
with such waiver or consent.
d. This License constitutes the entire agreement between the parties with respect to the
Work licensed here. There are no understandings, agreements or representations with
respect to the Work not speciﬁed here. Licensor shall not be bound by any additional
provisions that may appear in any communication from You.
e. This License may not be modiﬁed without the mutual written agreement of the Licensor
and You. The rights granted under, and the subject matter referenced, in this License were
drafted utilizing the terminology of the Berne Convention for the Protection of Literary
and Artistic Works (as amended on September 28, 1979), the Rome Convention of 1961,
the WIPO Copyright Treaty of 1996, the WIPO Performances and Phonograms Treaty of
1996 and the Universal Copyright Convention (as revised on July 24, 1971). These rights
and subject matter take eﬀect in the relevant jurisdiction in which the License terms are
sought to be enforced according to the corresponding provisions of the implementation
of those treaty provisions in the applicable national law. If the standard suite of rights
granted under applicable copyright law includes additional rights not granted under this
License, such additional rights are deemed to be included in the License; this License is
not intended to restrict the license of any rights under applicable law.
Open∇FOAM-2.2.0
U-7
Trademarks
ANSYS is a registered trademark of ANSYS Inc.
CFX is a registered trademark of Ansys Inc.
CHEMKIN is a registered trademark of Reaction Design Corporation
EnSight is a registered trademark of Computational Engineering International Ltd.
Fieldview is a registered trademark of Intelligent Light
Fluent is a registered trademark of Ansys Inc.
GAMBIT is a registered trademark of Ansys Inc.
Icem-CFD is a registered trademark of Ansys Inc.
I-DEAS is a registered trademark of Structural Dynamics Research Corporation
JAVA is a registered trademark of Sun Microsystems Inc.
Linux is a registered trademark of Linus Torvalds
OpenFOAM is a registered trademark of SGI Corp.
ParaView is a registered trademark of Kitware
STAR-CD is a registered trademark of Computational Dynamics Ltd.
UNIX is a registered trademark of The Open Group
Open∇FOAM-2.2.0
U-8
Open∇FOAM-2.2.0
Contents
Copyright Notice U-2
1. Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-2
2. Fair Dealing Rights. . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-3
3. License Grant. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-3
4. Restrictions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-4
5. Representations, Warranties and Disclaimer . . . . . . . . . . . . . . . U-5
6. Limitation on Liability. . . . . . . . . . . . . . . . . . . . . . . . . . . U-5
7. Termination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-5
8. Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-6
Trademarks U-7
Contents U-9
1 Introduction U-15
2 Tutorials U-17
2.1 Lid-driven cavity ﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . U-17
2.1.1 Pre-processing . . . . . . . . . . . . . . . . . . . . . . . . . . U-18
2.1.1.1 Mesh generation . . . . . . . . . . . . . . . . . . . U-18
2.1.1.2 Boundary and initial conditions . . . . . . . . . . . U-20
2.1.1.3 Physical properties . . . . . . . . . . . . . . . . . . U-21
2.1.1.4 Control . . . . . . . . . . . . . . . . . . . . . . . . U-21
2.1.1.5 Discretisation and linear-solver settings . . . . . . . U-23
2.1.2 Viewing the mesh . . . . . . . . . . . . . . . . . . . . . . . . U-23
2.1.3 Running an application . . . . . . . . . . . . . . . . . . . . . U-24
2.1.4 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-25
2.1.4.1 Isosurface and contour plots . . . . . . . . . . . . . U-25
2.1.4.2 Vector plots . . . . . . . . . . . . . . . . . . . . . . U-27
2.1.4.3 Streamline plots . . . . . . . . . . . . . . . . . . . U-27
2.1.5 Increasing the mesh resolution . . . . . . . . . . . . . . . . . U-30
2.1.5.1 Creating a new case using an existing case . . . . . U-30
2.1.5.2 Creating the ﬁner mesh . . . . . . . . . . . . . . . U-30
2.1.5.3 Mapping the coarse mesh results onto the ﬁne mesh U-30
2.1.5.4 Control adjustments . . . . . . . . . . . . . . . . . U-31
2.1.5.5 Running the code as a background process . . . . . U-31
2.1.5.6 Vector plot with the reﬁned mesh . . . . . . . . . . U-31
2.1.5.7 Plotting graphs . . . . . . . . . . . . . . . . . . . . U-32
2.1.6 Introducing mesh grading . . . . . . . . . . . . . . . . . . . U-34
2.1.6.1 Creating the graded mesh . . . . . . . . . . . . . . U-35
2.1.6.2 Changing time and time step . . . . . . . . . . . . U-36
U-10 Contents
2.1.6.3 Mapping ﬁelds . . . . . . . . . . . . . . . . . . . . U-37
2.1.7 Increasing the Reynolds number . . . . . . . . . . . . . . . . U-37
2.1.7.1 Pre-processing . . . . . . . . . . . . . . . . . . . . U-38
2.1.7.2 Running the code . . . . . . . . . . . . . . . . . . . U-38
2.1.8 High Reynolds number ﬂow . . . . . . . . . . . . . . . . . . U-39
2.1.8.1 Pre-processing . . . . . . . . . . . . . . . . . . . . U-39
2.1.8.2 Running the code . . . . . . . . . . . . . . . . . . . U-41
2.1.9 Changing the case geometry . . . . . . . . . . . . . . . . . . U-41
2.1.10 Post-processing the modiﬁed geometry . . . . . . . . . . . . U-43
2.2 Stress analysis of a plate with a hole . . . . . . . . . . . . . . . . . U-45
2.2.1 Mesh generation . . . . . . . . . . . . . . . . . . . . . . . . U-46
2.2.1.1 Boundary and initial conditions . . . . . . . . . . . U-49
2.2.1.2 Mechanical properties . . . . . . . . . . . . . . . . U-49
2.2.1.3 Thermal properties . . . . . . . . . . . . . . . . . . U-50
2.2.1.4 Control . . . . . . . . . . . . . . . . . . . . . . . . U-50
2.2.1.5 Discretisation schemes and linear-solver control . . U-51
2.2.2 Running the code . . . . . . . . . . . . . . . . . . . . . . . . U-52
2.2.3 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-53
2.2.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-54
2.2.4.1 Increasing mesh resolution . . . . . . . . . . . . . . U-54
2.2.4.2 Introducing mesh grading . . . . . . . . . . . . . . U-54
2.2.4.3 Changing the plate size . . . . . . . . . . . . . . . U-55
2.3 Breaking of a dam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-55
2.3.1 Mesh generation . . . . . . . . . . . . . . . . . . . . . . . . U-55
2.3.2 Boundary conditions . . . . . . . . . . . . . . . . . . . . . . U-57
2.3.3 Setting initial ﬁeld . . . . . . . . . . . . . . . . . . . . . . . U-57
2.3.4 Fluid properties . . . . . . . . . . . . . . . . . . . . . . . . . U-59
2.3.5 Turbulence modelling . . . . . . . . . . . . . . . . . . . . . . U-59
2.3.6 Time step control . . . . . . . . . . . . . . . . . . . . . . . . U-59
2.3.7 Discretisation schemes . . . . . . . . . . . . . . . . . . . . . U-60
2.3.8 Linear-solver control . . . . . . . . . . . . . . . . . . . . . . U-61
2.3.9 Running the code . . . . . . . . . . . . . . . . . . . . . . . . U-62
2.3.10 Post-processing . . . . . . . . . . . . . . . . . . . . . . . . . U-62
2.3.11 Running in parallel . . . . . . . . . . . . . . . . . . . . . . . U-62
2.3.12 Post-processing a case run in parallel . . . . . . . . . . . . . U-64
3 Applications and libraries U-67
3.1 The programming language of OpenFOAM . . . . . . . . . . . . . . U-67
3.1.1 Language in general . . . . . . . . . . . . . . . . . . . . . . U-67
3.1.2 Object-orientation and C++ . . . . . . . . . . . . . . . . . . U-68
3.1.3 Equation representation . . . . . . . . . . . . . . . . . . . . U-68
3.1.4 Solver codes . . . . . . . . . . . . . . . . . . . . . . . . . . . U-69
3.2 Compiling applications and libraries . . . . . . . . . . . . . . . . . . U-69
3.2.1 Header .H ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . U-70
3.2.2 Compiling with wmake . . . . . . . . . . . . . . . . . . . . . U-71
3.2.2.1 Including headers . . . . . . . . . . . . . . . . . . . U-71
3.2.2.2 Linking to libraries . . . . . . . . . . . . . . . . . . U-72
3.2.2.3 Source ﬁles to be compiled . . . . . . . . . . . . . . U-72
3.2.2.4 Running wmake . . . . . . . . . . . . . . . . . . . . U-73
3.2.2.5 wmake environment variables . . . . . . . . . . . . U-73
3.2.3 Removing dependency lists: wclean and rmdepall . . . . . . . U-73
Open∇FOAM-2.2.0
Contents U-11
3.2.4 Compilation example: the pisoFoam application . . . . . . . U-74
3.2.5 Debug messaging and optimisation switches . . . . . . . . . U-77
3.2.6 Linking new user-deﬁned libraries to existing applications . . U-78
3.3 Running applications . . . . . . . . . . . . . . . . . . . . . . . . . . U-79
3.4 Running applications in parallel . . . . . . . . . . . . . . . . . . . . U-79
3.4.1 Decomposition of mesh and initial ﬁeld data . . . . . . . . . U-79
3.4.2 Running a decomposed case . . . . . . . . . . . . . . . . . . U-81
3.4.3 Distributing data across several disks . . . . . . . . . . . . . U-82
3.4.4 Post-processing parallel processed cases . . . . . . . . . . . . U-83
3.4.4.1 Reconstructing mesh and data . . . . . . . . . . . U-83
3.4.4.2 Post-processing decomposed cases . . . . . . . . . . U-83
3.5 Standard solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-83
3.6 Standard utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-88
3.7 Standard libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-95
4 OpenFOAM cases U-103
4.1 File structure of OpenFOAM cases . . . . . . . . . . . . . . . . . . U-103
4.2 Basic input/output ﬁle format . . . . . . . . . . . . . . . . . . . . . U-104
4.2.1 General syntax rules . . . . . . . . . . . . . . . . . . . . . . U-104
4.2.2 Dictionaries . . . . . . . . . . . . . . . . . . . . . . . . . . . U-104
4.2.3 The data ﬁle header . . . . . . . . . . . . . . . . . . . . . . U-105
4.2.4 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-106
4.2.5 Scalars, vectors and tensors . . . . . . . . . . . . . . . . . . U-107
4.2.6 Dimensional units . . . . . . . . . . . . . . . . . . . . . . . . U-107
4.2.7 Dimensioned types . . . . . . . . . . . . . . . . . . . . . . . U-108
4.2.8 Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-108
4.2.9 Directives and macro substitutions . . . . . . . . . . . . . . U-109
4.2.10 The #include and #inputMode directives . . . . . . . . . . U-109
4.2.11 The #codeStream directive . . . . . . . . . . . . . . . . . . U-110
4.3 Time and data input/output control . . . . . . . . . . . . . . . . . U-111
4.4 Numerical schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . U-113
4.4.1 Interpolation schemes . . . . . . . . . . . . . . . . . . . . . . U-115
4.4.1.1 Schemes for strictly bounded scalar ﬁelds . . . . . U-116
4.4.1.2 Schemes for vector ﬁelds . . . . . . . . . . . . . . . U-116
4.4.2 Surface normal gradient schemes . . . . . . . . . . . . . . . U-117
4.4.3 Gradient schemes . . . . . . . . . . . . . . . . . . . . . . . . U-117
4.4.4 Laplacian schemes . . . . . . . . . . . . . . . . . . . . . . . U-118
4.4.5 Divergence schemes . . . . . . . . . . . . . . . . . . . . . . . U-118
4.4.6 Time schemes . . . . . . . . . . . . . . . . . . . . . . . . . . U-119
4.4.7 Flux calculation . . . . . . . . . . . . . . . . . . . . . . . . . U-120
4.5 Solution and algorithm control . . . . . . . . . . . . . . . . . . . . . U-120
4.5.1 Linear solver control . . . . . . . . . . . . . . . . . . . . . . U-120
4.5.1.1 Solution tolerances . . . . . . . . . . . . . . . . . . U-121
4.5.1.2 Preconditioned conjugate gradient solvers . . . . . U-122
4.5.1.3 Smooth solvers . . . . . . . . . . . . . . . . . . . . U-122
4.5.1.4 Geometric-algebraic multi-grid solvers . . . . . . . U-122
4.5.2 Solution under-relaxation . . . . . . . . . . . . . . . . . . . U-123
4.5.3 PISO and SIMPLE algorithms . . . . . . . . . . . . . . . . . U-124
4.5.3.1 Pressure referencing . . . . . . . . . . . . . . . . . U-125
4.5.4 Other parameters . . . . . . . . . . . . . . . . . . . . . . . . U-125
Open∇FOAM-2.2.0
U-12 Contents
5 Mesh generation and conversion U-127
5.1 Mesh description . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-127
5.1.1 Mesh speciﬁcation and validity constraints . . . . . . . . . . U-127
5.1.1.1 Points . . . . . . . . . . . . . . . . . . . . . . . . . U-128
5.1.1.2 Faces . . . . . . . . . . . . . . . . . . . . . . . . . U-128
5.1.1.3 Cells . . . . . . . . . . . . . . . . . . . . . . . . . . U-128
5.1.1.4 Boundary . . . . . . . . . . . . . . . . . . . . . . . U-129
5.1.2 The polyMesh description . . . . . . . . . . . . . . . . . . . . U-129
5.1.3 The cellShape tools . . . . . . . . . . . . . . . . . . . . . . . U-130
5.1.4 1- and 2-dimensional and axi-symmetric problems . . . . . . U-130
5.2 Boundaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-132
5.2.1 Speciﬁcation of patch types in OpenFOAM . . . . . . . . . . U-132
5.2.2 Base types . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-134
5.2.3 Primitive types . . . . . . . . . . . . . . . . . . . . . . . . . U-135
5.2.4 Derived types . . . . . . . . . . . . . . . . . . . . . . . . . . U-135
5.3 Mesh generation with the blockMesh utility . . . . . . . . . . . . . . U-136
5.3.1 Writing a blockMeshDict ﬁle . . . . . . . . . . . . . . . . . . U-138
5.3.1.1 The vertices . . . . . . . . . . . . . . . . . . . . U-139
5.3.1.2 The edges . . . . . . . . . . . . . . . . . . . . . . U-139
5.3.1.3 The blocks . . . . . . . . . . . . . . . . . . . . . . U-140
5.3.1.4 The boundary . . . . . . . . . . . . . . . . . . . . U-141
5.3.2 Multiple blocks . . . . . . . . . . . . . . . . . . . . . . . . . U-142
5.3.3 Creating blocks with fewer than 8 vertices . . . . . . . . . . U-144
5.3.4 Running blockMesh . . . . . . . . . . . . . . . . . . . . . . . U-144
5.4 Mesh generation with the snappyHexMesh utility . . . . . . . . . . . U-145
5.4.1 The mesh generation process of snappyHexMesh . . . . . . . U-145
5.4.2 Creating the background hex mesh . . . . . . . . . . . . . . U-146
5.4.3 Cell splitting at feature edges and surfaces . . . . . . . . . . U-147
5.4.4 Cell removal . . . . . . . . . . . . . . . . . . . . . . . . . . . U-149
5.4.5 Cell splitting in speciﬁed regions . . . . . . . . . . . . . . . . U-149
5.4.6 Snapping to surfaces . . . . . . . . . . . . . . . . . . . . . . U-150
5.4.7 Mesh layers . . . . . . . . . . . . . . . . . . . . . . . . . . . U-150
5.4.8 Mesh quality controls . . . . . . . . . . . . . . . . . . . . . . U-153
5.5 Mesh conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-153
5.5.1 ﬂuentMeshToFoam . . . . . . . . . . . . . . . . . . . . . . . U-154
5.5.2 starToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-155
5.5.2.1 General advice on conversion . . . . . . . . . . . . U-155
5.5.2.2 Eliminating extraneous data . . . . . . . . . . . . . U-155
5.5.2.3 Removing default boundary conditions . . . . . . . U-156
5.5.2.4 Renumbering the model . . . . . . . . . . . . . . . U-157
5.5.2.5 Writing out the mesh data . . . . . . . . . . . . . . U-157
5.5.2.6 Problems with the .vrt ﬁle . . . . . . . . . . . . . . U-158
5.5.2.7 Converting the mesh to OpenFOAM format . . . . U-159
5.5.3 gambitToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . U-159
5.5.4 ideasToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-159
5.5.5 cfx4ToFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . U-159
5.6 Mapping ﬁelds between diﬀerent geometries . . . . . . . . . . . . . U-160
5.6.1 Mapping consistent ﬁelds . . . . . . . . . . . . . . . . . . . . U-160
5.6.2 Mapping inconsistent ﬁelds . . . . . . . . . . . . . . . . . . . U-160
5.6.3 Mapping parallel cases . . . . . . . . . . . . . . . . . . . . . U-161
Open∇FOAM-2.2.0
Contents U-13
6 Post-processing U-163
6.1 paraFoam . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-163
6.1.1 Overview of paraFoam . . . . . . . . . . . . . . . . . . . . . U-163
6.1.2 The Properties panel . . . . . . . . . . . . . . . . . . . . . . U-164
6.1.3 The Display panel . . . . . . . . . . . . . . . . . . . . . . . . U-165
6.1.4 The button toolbars . . . . . . . . . . . . . . . . . . . . . . U-167
6.1.5 Manipulating the view . . . . . . . . . . . . . . . . . . . . . U-167
6.1.5.1 View settings . . . . . . . . . . . . . . . . . . . . . U-167
6.1.5.2 General settings . . . . . . . . . . . . . . . . . . . U-168
6.1.6 Contour plots . . . . . . . . . . . . . . . . . . . . . . . . . . U-168
6.1.6.1 Introducing a cutting plane . . . . . . . . . . . . . U-168
6.1.7 Vector plots . . . . . . . . . . . . . . . . . . . . . . . . . . . U-168
6.1.7.1 Plotting at cell centres . . . . . . . . . . . . . . . . U-168
6.1.8 Streamlines . . . . . . . . . . . . . . . . . . . . . . . . . . . U-169
6.1.9 Image output . . . . . . . . . . . . . . . . . . . . . . . . . . U-169
6.1.10 Animation output . . . . . . . . . . . . . . . . . . . . . . . . U-169
6.2 Post-processing with Fluent . . . . . . . . . . . . . . . . . . . . . . U-170
6.3 Post-processing with Fieldview . . . . . . . . . . . . . . . . . . . . . U-171
6.4 Post-processing with EnSight . . . . . . . . . . . . . . . . . . . . . . U-171
6.4.1 Converting data to EnSight format . . . . . . . . . . . . . . U-172
6.4.2 The ensight74FoamExec reader module . . . . . . . . . . . . U-172
6.4.2.1 Conﬁguration of EnSight for the reader module . . U-172
6.4.2.2 Using the reader module . . . . . . . . . . . . . . . U-172
6.5 Sampling data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . U-173
6.6 Monitoring and managing jobs . . . . . . . . . . . . . . . . . . . . . U-176
6.6.1 The foamJob script for running jobs . . . . . . . . . . . . . . U-177
6.6.2 The foamLog script for monitoring jobs . . . . . . . . . . . . U-177
7 Models and physical properties U-179
7.1 Thermophysical models . . . . . . . . . . . . . . . . . . . . . . . . . U-179
7.1.1 Thermophysical property data . . . . . . . . . . . . . . . . . U-181
7.2 Turbulence models . . . . . . . . . . . . . . . . . . . . . . . . . . . U-184
7.2.1 Model coeﬃcients . . . . . . . . . . . . . . . . . . . . . . . . U-184
7.2.2 Wall functions . . . . . . . . . . . . . . . . . . . . . . . . . . U-185
Index U-187
Open∇FOAM-2.2.0
U-14 Contents
Open∇FOAM-2.2.0
Chapter 1
Introduction
This guide accompanies the release of version 2.2.0 of the Open Source Field Operation
and Manipulation (OpenFOAM) C++ libraries. It provides a description of the basic
operation of OpenFOAM, ﬁrst through a set of tutorial exercises in chapter 2 and later
by a more detailed description of the individual components that make up OpenFOAM.
OpenFOAM is ﬁrst and foremost a C++ library, used primarily to create executa-
bles, known as applications. The applications fall into two categories: solvers, that are
each designed to solve a speciﬁc problem in continuum mechanics; and utilities, that are
designed to perform tasks that involve data manipulation. The OpenFOAM distribution
contains numerous solvers and utilities covering a wide range of problems, as described
in chapter 3.
One of the strengths of OpenFOAM is that new solvers and utilities can be created
by its users with some pre-requisite knowledge of the underlying method, physics and
programming techniques involved.
OpenFOAM is supplied with pre- and post-processing environments. The interface
to the pre- and post-processing are themselves OpenFOAM utilities, thereby ensuring
consistent data handling across all environments. The overall structure of OpenFOAM is
shown in Figure 1.1. The pre-processing and running of OpenFOAM cases is described
Applications
User
Tools
MeshingUtilities Standard
Applications
Others
e.g.EnSight
Post-processingSolvingPre-processing
Open Source Field Operation and Manipulation (OpenFOAM) C++ Library
ParaView
Figure 1.1: Overview of OpenFOAM structure.
in chapter 4. In chapter 5, we cover both the generation of meshes using the mesh
generator supplied with OpenFOAM and conversion of mesh data generated by third-
party products. Post-processing is described in chapter 6.
U-16 Introduction
Open∇FOAM-2.2.0
Chapter 2
Tutorials
In this chapter we shall describe in detail the process of setup, simulation and post-
processing for some OpenFOAM test cases, with the principal aim of introducing a user to
the basic procedures of running OpenFOAM. The $FOAM TUTORIALS directory contains
many more cases that demonstrate the use of all the solvers and many utilities supplied
with OpenFOAM. Before attempting to run the tutorials, the user must ﬁrst make sure
that they have installed OpenFOAM correctly.
The tutorial cases describe the use of the blockMesh pre-processing tool, case setup
and running OpenFOAM solvers and post-processing using paraFoam. Those users with
access to third-party post-processing tools supported in OpenFOAM have an option:
either they can follow the tutorials using paraFoam; or refer to the description of the use
of the third-party product in chapter 6 when post-processing is required.
Copies of all tutorials are available from the tutorials directory of the OpenFOAM
installation. The tutorials are organised into a set of directories according to the type
of ﬂow and then subdirectories according to solver. For example, all the icoFoam cases
are stored within a subdirectory incompressible/icoFoam, where incompressible indicates
the type of ﬂow. If the user wishes to run a range of example cases, it is recommended
that the user copy the tutorials directory into their local run directory. They can be easily
copied by typing:
mkdir -p $FOAM RUN
cp -r $FOAM TUTORIALS $FOAM RUN
2.1 Lid-driven cavity ﬂow
This tutorial will describe how to pre-process, run and post-process a case involving
isothermal, incompressible ﬂow in a two-dimensional square domain. The geometry is
shown in Figure 2.1 in which all the boundaries of the square are walls. The top wall
moves in the x-direction at a speed of 1 m/s while the other 3 are stationary. Initially,
the ﬂow will be assumed laminar and will be solved on a uniform mesh using the icoFoam
solver for laminar, isothermal, incompressible ﬂow. During the course of the tutorial, the
eﬀect of increased mesh resolution and mesh grading towards the walls will be investigated.
Finally, the ﬂow Reynolds number will be increased and the pisoFoam solver will be used
for turbulent, isothermal, incompressible ﬂow.
U-18 Tutorials
x
Ux = 1 m/s
d = 0.1 m
y
Figure 2.1: Geometry of the lid driven cavity.
2.1.1 Pre-processing
Cases are setup in OpenFOAM by editing case ﬁles. Users should select an xeditor of
choice with which to do this, such as emacs, vi, gedit, kate, nedit, etc. Editing ﬁles is
possible in OpenFOAM because the I/O uses a dictionary format with keywords that
convey suﬃcient meaning to be understood by even the least experienced users.
A case being simulated involves data for mesh, ﬁelds, properties, control parameters,
etc. As described in section 4.1, in OpenFOAM this data is stored in a set of ﬁles within
a case directory rather than in a single case ﬁle, as in many other CFD packages. The
case directory is given a suitably descriptive name, e.g. the ﬁrst example case for this
tutorial is simply named cavity. In preparation of editing case ﬁles and running the ﬁrst
cavity case, the user should change to the case directory
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavity
2.1.1.1 Mesh generation
OpenFOAM always operates in a 3 dimensional Cartesian coordinate system and all
geometries are generated in 3 dimensions. OpenFOAM solves the case in 3 dimensions
by default but can be instructed to solve in 2 dimensions by specifying a ‘special’ empty
boundary condition on boundaries normal to the (3rd) dimension for which no solution
is required.
The cavity domain consists of a square of side length d = 0.1 m in the x-y plane.
A uniform mesh of 20 by 20 cells will be used initially. The block structure is shown
in Figure 2.2. The mesh generator supplied with OpenFOAM, blockMesh, generates
meshes from a description speciﬁed in an input dictionary, blockMeshDict located in the
constant/polyMesh directory for a given case. The blockMeshDict entries for this case are
as follows:
1 /*--------------------------------*- C++ -*----------------------------------*\
2 | ========= | |
3 | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox |
4 | \\ / O peration | Version: 2.2.0 |
5 | \\ / A nd | Web: www.OpenFOAM.org |
6 | \\/ M anipulation | |
7 \*---------------------------------------------------------------------------*/
8 FoamFile
9 {
10 version 2.0;
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-19
3 2
4 5
7 6
0
z
x 1
y
Figure 2.2: Block structure of the mesh for the cavity.
11 format ascii;
12 class dictionary;
13 object blockMeshDict;
14 }
15 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
16
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (1 0 0)
23 (1 1 0)
24 (0 1 0)
25 (0 0 0.1)
26 (1 0 0.1)
27 (1 1 0.1)
28 (0 1 0.1)
29 );
30
31 blocks
32 (
33 hex (0 1 2 3 4 5 6 7) (20 20 1) simpleGrading (1 1 1)
34 );
35
36 edges
37 (
38 );
39
40 boundary
41 (
42 movingWall
43 {
44 type wall;
45 faces
46 (
47 (3 7 6 2)
48 );
49 }
50 fixedWalls
51 {
52 type wall;
53 faces
54 (
55 (0 4 7 3)
56 (2 6 5 1)
57 (1 5 4 0)
58 );
59 }
60 frontAndBack
61 {
62 type empty;
63 faces
64 (
65 (0 3 2 1)
66 (4 5 6 7)
67 );
68 }
Open∇FOAM-2.2.0
U-20 Tutorials
69 );
70
71 mergePatchPairs
72 (
73 );
74
75 // ************************************************************************* //
The ﬁle ﬁrst contains header information in the form of a banner (lines 1-7), then ﬁle
information contained in a FoamFile sub-dictionary, delimited by curly braces ({...}).
For the remainder of the manual:
For the sake of clarity and to save space, ﬁle headers, including the banner and
FoamFile sub-dictionary, will be removed from verbatim quoting of case ﬁles
The ﬁle ﬁrst speciﬁes coordinates of the block vertices; it then deﬁnes the blocks
(here, only 1) from the vertex labels and the number of cells within it; and ﬁnally, it deﬁnes
the boundary patches. The user is encouraged to consult section 5.3 to understand the
meaning of the entries in the blockMeshDict ﬁle.
The mesh is generated by running blockMesh on this blockMeshDict ﬁle. From within
the case directory, this is done, simply by typing in the terminal:
blockMesh
The running status of blockMesh is reported in the terminal window. Any mistakes in
the blockMeshDict ﬁle are picked up by blockMesh and the resulting error message directs
the user to the line in the ﬁle where the problem occurred. There should be no error
messages at this stage.
2.1.1.2 Boundary and initial conditions
Once the mesh generation is complete, the user can look at this initial ﬁelds set up for
this case. The case is set up to start at time t = 0 s, so the initial ﬁeld data is stored in
a 0 sub-directory of the cavity directory. The 0 sub-directory contains 2 ﬁles, p and U,
one for each of the pressure (p) and velocity (U) ﬁelds whose initial values and boundary
conditions must be set. Let us examine ﬁle p:
17 dimensions [0 2 -2 0 0 0 0];
18
19 internalField uniform 0;
20
21 boundaryField
22 {
23 movingWall
24 {
25 type zeroGradient;
26 }
27
28 fixedWalls
29 {
30 type zeroGradient;
31 }
32
33 frontAndBack
34 {
35 type empty;
36 }
37 }
38
39 // ************************************************************************* //
There are 3 principal entries in ﬁeld data ﬁles:
dimensions speciﬁes the dimensions of the ﬁeld, here kinematic pressure, i.e. m2
s−2
(see
section 4.2.6 for more information);
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-21
internalField the internal ﬁeld data which can be uniform, described by a single value;
or nonuniform, where all the values of the ﬁeld must be speciﬁed (see section 4.2.8
for more information);
boundaryField the boundary ﬁeld data that includes boundary conditions and data for
all the boundary patches (see section 4.2.8 for more information).
For this case cavity, the boundary consists of walls only, split into 2 patches named: (1)
fixedWalls for the ﬁxed sides and base of the cavity; (2) movingWall for the moving top
of the cavity. As walls, both are given a zeroGradient boundary condition for p, meaning
“the normal gradient of pressure is zero”. The frontAndBack patch represents the front
and back planes of the 2D case and therefore must be set as empty.
In this case, as in most we encounter, the initial ﬁelds are set to be uniform. Here the
pressure is kinematic, and as an incompressible case, its absolute value is not relevant, so
is set to uniform 0 for convenience.
The user can similarly examine the velocity ﬁeld in the 0/U ﬁle. The dimensions are
those expected for velocity, the internal ﬁeld is initialised as uniform zero, which in the
case of velocity must be expressed by 3 vector components, i.e.uniform (0 0 0) (see
section 4.2.5 for more information).
The boundary ﬁeld for velocity requires the same boundary condition for the front-
AndBack patch. The other patches are walls: a no-slip condition is assumed on the
fixedWalls, hence a ﬁxedValue condition with a value of uniform (0 0 0). The top
surface moves at a speed of 1 m/s in the x-direction so requires a ﬁxedValue condition
also but with uniform (1 0 0).
2.1.1.3 Physical properties
The physical properties for the case are stored in dictionaries whose names are given the
suﬃx . . . Properties, located in the Dictionaries directory tree. For an icoFoam case,
the only property that must be speciﬁed is the kinematic viscosity which is stored from
the transportProperties dictionary. The user can check that the kinematic viscosity is
set correctly by opening the transportProperties dictionary to view/edit its entries. The
keyword for kinematic viscosity is nu, the phonetic label for the Greek symbol ν by which
it is represented in equations. Initially this case will be run with a Reynolds number of
10, where the Reynolds number is deﬁned as:
Re =
d|U|
ν
(2.1)
where d and |U| are the characteristic length and velocity respectively and ν is the
kinematic viscosity. Here d = 0.1 m, |U| = 1 m s−1
, so that for Re = 10, ν = 0.01 m2
s−1
.
The correct ﬁle entry for kinematic viscosity is thus speciﬁed below:
17
18 nu nu [ 0 2 -1 0 0 0 0 ] 0.01;
19
20
21 // ************************************************************************* //
2.1.1.4 Control
Input data relating to the control of time and reading and writing of the solution data are
read in from the controlDict dictionary. The user should view this ﬁle; as a case control
ﬁle, it is located in the system directory.
The start/stop times and the time step for the run must be set. OpenFOAM oﬀers
great ﬂexibility with time control which is described in full in section 4.3. In this tutorial
Open∇FOAM-2.2.0
U-22 Tutorials
we wish to start the run at time t = 0 which means that OpenFOAM needs to read ﬁeld
data from a directory named 0 — see section 4.1 for more information of the case ﬁle
structure. Therefore we set the startFrom keyword to startTime and then specify the
startTime keyword to be 0.
For the end time, we wish to reach the steady state solution where the ﬂow is circu-
lating around the cavity. As a general rule, the ﬂuid should pass through the domain 10
times to reach steady state in laminar ﬂow. In this case the ﬂow does not pass through
this domain as there is no inlet or outlet, so instead the end time can be set to the time
taken for the lid to travel ten times across the cavity, i.e. 1 s; in fact, with hindsight, we
discover that 0.5 s is suﬃcient so we shall adopt this value. To specify this end time, we
must specify the stopAt keyword as endTime and then set the endTime keyword to 0.5.
Now we need to set the time step, represented by the keyword deltaT. To achieve
temporal accuracy and numerical stability when running icoFoam, a Courant number of
less than 1 is required. The Courant number is deﬁned for one cell as:
Co =
δt|U|
δx
(2.2)
where δt is the time step, |U| is the magnitude of the velocity through that cell and δx
is the cell size in the direction of the velocity. The ﬂow velocity varies across the domain
and we must ensure Co < 1 everywhere. We therefore choose δt based on the worst case:
the maximum Co corresponding to the combined eﬀect of a large ﬂow velocity and small
cell size. Here, the cell size is ﬁxed across the domain so the maximum Co will occur next
to the lid where the velocity approaches 1 m s−1
. The cell size is:
δx =
d
n
=
0.1
20
= 0.005 m (2.3)
Therefore to achieve a Courant number less than or equal to 1 throughout the domain
the time step deltaT must be set to less than or equal to:
δt =
Co δx
|U|
=
1 × 0.005
1
= 0.005 s (2.4)
As the simulation progresses we wish to write results at certain intervals of time that
we can later view with a post-processing package. The writeControl keyword presents
several options for setting the time at which the results are written; here we select the
timeStep option which speciﬁes that results are written every nth time step where the
value n is speciﬁed under the writeInterval keyword. Let us decide that we wish to
write our results at times 0.1, 0.2,. . . , 0.5 s. With a time step of 0.005 s, we therefore
need to output results at every 20th time time step and so we set writeInterval to 20.
OpenFOAM creates a new directory named after the current time, e.g. 0.1 s, on each
occasion that it writes a set of data, as discussed in full in section 4.1. In the icoFoam
solver, it writes out the results for each ﬁeld, U and p, into the time directories. For this
case, the entries in the controlDict are shown below:
17
18 application icoFoam;
19
20 startFrom startTime;
21
22 startTime 0;
23
24 stopAt endTime;
25
26 endTime 0.5;
27
28 deltaT 0.005;
29
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-23
30 writeControl timeStep;
31
32 writeInterval 20;
33
34 purgeWrite 0;
35
36 writeFormat ascii;
37
38 writePrecision 6;
39
40 writeCompression off;
41
42 timeFormat general;
43
44 timePrecision 6;
45
46 runTimeModifiable true;
47
48
49 // ************************************************************************* //
2.1.1.5 Discretisation and linear-solver settings
The user speciﬁes the choice of ﬁnite volume discretisation schemes in the fvSchemes
dictionary in the system directory. The speciﬁcation of the linear equation solvers and
tolerances and other algorithm controls is made in the fvSolution dictionary, similarly in
the system directory. The user is free to view these dictionaries but we do not need to
discuss all their entries at this stage except for pRefCell and pRefValue in the PISO
sub-dictionary of the fvSolution dictionary. In a closed incompressible system such as the
cavity, pressure is relative: it is the pressure range that matters not the absolute values.
In cases such as this, the solver sets a reference level by pRefValue in cell pRefCell. In
this example both are set to 0. Changing either of these values will change the absolute
pressure ﬁeld, but not, of course, the relative pressures or velocity ﬁeld.
2.1.2 Viewing the mesh
Before the case is run it is a good idea to view the mesh to check for any errors. The mesh
is viewed in paraFoam, the post-processing tool supplied with OpenFOAM. The paraFoam
post-processing is started by typing in the terminal from within the case directory
paraFoam
Alternatively, it can be launched from another directory location with an optional
-case argument giving the case directory, e.g.
paraFoam -case $FOAM RUN/tutorials/incompressible/icoFoam/cavity
This launches the ParaView window as shown in Figure 6.1. In the Pipeline Browser,
the user can see that ParaView has opened cavity.OpenFOAM, the module for the cavity
case. Before clicking the Apply button, the user needs to select some geometry from
the Mesh Parts panel. Because the case is small, it is easiest to select all the data by
checking the box adjacent to the Mesh Parts panel title, which automatically checks all
individual components within the respective panel. The user should then click the Apply
button to load the geometry into ParaView.
The user should then open the Display panel that controls the visual representation
of the selected module. Within the Display panel the user should do the following as
shown in Figure 2.3: (1) set Color By Solid Color; (2) click Set Ambient Color and
select an appropriate colour e.g. black (for a white background); (3) in the Style panel,
Open∇FOAM-2.2.0
U-24 Tutorials
Open Display panel
Select Color by Solid Color
Set Solid Color, e.g. black
Select Wireframe
Figure 2.3: Viewing the mesh in paraFoam.
select Wireframe from the Representation menu. The background colour can be set by
selecting View Settings... from Edit in the top menu panel.
Especially the ﬁrst time the user starts ParaView, it is recommended that they
manipulate the view as described in section 6.1.5. In particular, since this is a 2D case,
it is recommended that Use Parallel Projection is selected in the General panel of View
Settings window selected from the Edit menu. The Orientation Axes can be toggled on
and oﬀ in the Annotation window or moved by drag and drop with the mouse.
2.1.3 Running an application
Like any UNIX/Linux executable, OpenFOAM applications can be run in two ways: as
a foreground process, i.e. one in which the shell waits until the command has ﬁnished
before giving a command prompt; as a background process, one which does not have to
be completed before the shell accepts additional commands.
On this occasion, we will run icoFoam in the foreground. The icoFoam solver is exe-
cuted either by entering the case directory and typing
icoFoam
at the command prompt, or with the optional -case argument giving the case directory,
e.g.
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-25
icoFoam -case $FOAM RUN/tutorials/incompressible/icoFoam/cavity
The progress of the job is written to the terminal window. It tells the user the current
time, maximum Courant number, initial and ﬁnal residuals for all ﬁelds.
2.1.4 Post-processing
As soon as results are written to time directories, they can be viewed using paraFoam.
Return to the paraFoam window and select the Properties panel for the cavity.OpenFOAM
case module. If the correct window panels for the case module do not seem to be present
at any time, please ensure that: cavity.OpenFOAM is highlighted in blue; eye button
alongside it is switched on to show the graphics are enabled;
To prepare paraFoam to display the data of interest, we must ﬁrst load the data at
the required run time of 0.5 s. If the case was run while ParaView was open, the output
data in time directories will not be automatically loaded within ParaView. To load the
data the user should click Refresh Times in the Properties window. The time data will be
loaded into ParaView.
2.1.4.1 Isosurface and contour plots
To view pressure, the user should open the Display panel since it controls the visual
representation of the selected module. To make a simple plot of pressure, the user should
select the following, as described in detail in Figure 2.4: in the Style panel, select Surface
from the Representation menu; in the Color panel, select Color by and Rescale to
Data Range. Now in order to view the solution at t = 0.5 s, the user can use the VCR
Controls or Current Time Controls to change the current time to 0.5. These are
located in the toolbars below the menus at the top of the ParaView window, as shown in
Figure 6.4. The pressure ﬁeld solution has, as expected, a region of low pressure at the
top left of the cavity and one of high pressure at the top right of the cavity as shown in
Figure 2.5.
With the point icon ( ) the pressure ﬁeld is interpolated across each cell to give a
continuous appearance. Instead if the user selects the cell icon, , from the Color by
menu, a single value for pressure will be attributed to each cell so that each cell will be
denoted by a single colour with no grading.
A colour bar can be included by either by clicking the Toggle Color Legend Visibility
button in the Active Variable Controls toolbar, or by selecting Show Color Legend
from the View menu. Clicking the Edit Color Map button, either in the Active Variable
Controls toolbar or in the Color panel of the Display window, the user can set a range
of attributes of the colour bar, such as text size, font selection and numbering format for
the scale. The colour bar can be located in the image window by drag and drop with the
mouse.
New versions of ParaView default to using a colour scale of blue to white to red rather
than the more common blue to green to red (rainbow). Therefore the ﬁrst time that the
user executes ParaView, they may wish to change the colour scale. This can be done by
selecting Choose Preset in the Color Scale Editor and selecting Blue to Red Rainbow. After
clicking the OK conﬁrmation button, the user can click the Make Default button so that
ParaView will always adopt this type of colour bar.
If the user rotates the image, they can see that they have now coloured the complete
geometry surface by the pressure. In order to produce a genuine contour plot the user
should ﬁrst create a cutting plane, or ‘slice’, through the geometry using the Slice ﬁlter
Open∇FOAM-2.2.0
U-26 Tutorials
Open Display panel
Rescale to Data Range
Select Surface
Select Color by interpolated p
Figure 2.4: Displaying pressure contours for the cavity case.
Figure 2.5: Pressures in the cavity case.
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-27
as described in section 6.1.6.1. The cutting plane should be centred at (0.05, 0.05, 0.005)
and its normal should be set to (0, 0, 1) (click the Z Normal button). Having generated
the cutting plane, the contours can be created using by the Contour ﬁlter described in
section 6.1.6.
2.1.4.2 Vector plots
Before we start to plot the vectors of the ﬂow velocity, it may be useful to remove other
modules that have been created, e.g. using the Slice and Contour ﬁlters described above.
These can: either be deleted entirely, by highlighting the relevant module in the Pipeline
Browser and clicking Delete in their respective Properties panel; or, be disabled by toggling
the eye button for the relevant module in the Pipeline Browser.
We now wish to generate a vector glyph for velocity at the centre of each cell. We
ﬁrst need to ﬁlter the data to cell centres as described in section 6.1.7.1. With the
cavity.OpenFOAM module highlighted in the Pipeline Browser, the user should select Cell
Centers from the Filter->Alphabetical menu and then click Apply.
With these Centers highlighted in the Pipeline Browser, the user should then select
Glyph from the Filter->Alphabetical menu. The Properties window panel should ap-
pear as shown in Figure 2.6. In the resulting Properties panel, the velocity ﬁeld, U, is
automatically selected in the vectors menu, since it is the only vector ﬁeld present. By
default the Scale Mode for the glyphs will be Vector Magnitude of velocity but, since
the we may wish to view the velocities throughout the domain, the user should instead se-
lect off and Set Scale Factor to 0.005. On clicking Apply, the glyphs appear but, probably
as a single colour, e.g. white. The user should colour the glyphs by velocity magnitude
which, as usual, is controlled by setting Color by U in the Display panel. The user should
also select Show Color Legend in Edit Color Map. The output is shown in Figure 2.7, in
which uppercase Times Roman fonts are selected for the Color Legend headings and the
labels are speciﬁed to 2 ﬁxed signiﬁcant ﬁgures by deselecting Automatic Label Format and
entering %-#6.2f in the Label Format text box. The background colour is set to white in
the General panel of View Settings as described in section 6.1.5.1.
Note that at the left and right walls, glyphs appear to indicate ﬂow through the walls.
On closer examination, however, the user can see that while the ﬂow direction is normal
to the wall, its magnitude is 0. This slightly confusing situation is caused by ParaView
choosing to orientate the glyphs in the x-direction when the glyph scaling off and the
velocity magnitude is 0.
2.1.4.3 Streamline plots
Again, before the user continues to post-process in ParaView, they should disable modules
such as those for the vector plot described above. We now wish to plot streamlines of
velocity as described in section 6.1.8.
With the cavity.OpenFOAM module highlighted in the Pipeline Browser, the user
should then select Stream Tracer from the Filter menu and then click Apply. The
Properties window panel should appear as shown in Figure 2.8. The Seed points should
be speciﬁed along a Line Source running vertically through the centre of the geometry,
i.e. from (0.05, 0, 0.005) to (0.05, 0.1, 0.005). For the image in this guide we used: a point
Resolution of 21; Max Propagation by Length 0.5; Initial Step Length by Cell Length 0.01;
and, Integration Direction BOTH. The Runge-Kutta 2 IntegratorType was used with
default parameters.
On clicking Apply the tracer is generated. The user should then select Tube from the
Filter menu to produce high quality streamline images. For the image in this report, we
Open∇FOAM-2.2.0
U-28 Tutorials
Open Parameters panel
Select Scale Mode off
Select Glyph Type Arrow
Specify Set Scale Factor 0.005
Figure 2.6: Properties panel for the Glyph ﬁlter.
Figure 2.7: Velocities in the cavity case.
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-29
Open Parameters panel
Set Integration Direction to BOTH
Set Max Propagation to Length 0.5
Set Initial Step Length to Cell Length 0.01
Specify Line Source and set points and resolution
Figure 2.8: Properties panel for the Stream Tracer ﬁlter.
Figure 2.9: Streamlines in the cavity case.
Open∇FOAM-2.2.0
U-30 Tutorials
used: Num. sides 6; Radius 0.0003; and, Radius factor 10. The streamtubes are coloured
by velocity magnitude. On clicking Apply the image in Figure 2.9 should be produced.
2.1.5 Increasing the mesh resolution
The mesh resolution will now be increased by a factor of two in each direction. The results
from the coarser mesh will be mapped onto the ﬁner mesh to use as initial conditions for
the problem. The solution from the ﬁner mesh will then be compared with those from
the coarser mesh.
2.1.5.1 Creating a new case using an existing case
We now wish to create a new case named cavityFine that is created from cavity. The user
should therefore clone the cavity case and edit the necessary ﬁles. First the user should
create a new case directory at the same directory level as the cavity case, e.g.
cd $FOAM RUN/tutorials/incompressible/icoFoam
mkdir cavityFine
The user should then copy the base directories from the cavity case into cavityFine, and
then enter the cavityFine case.
cp -r cavity/constant cavityFine
cp -r cavity/system cavityFine
cd cavityFine
2.1.5.2 Creating the ﬁner mesh
We now wish to increase the number of cells in the mesh by using blockMesh. The user
should open the blockMeshDict ﬁle in an editor and edit the block speciﬁcation. The blocks
are speciﬁed in a list under the blocks keyword. The syntax of the block deﬁnitions is
described fully in section 5.3.1.3; at this stage it is suﬃcient to know that following hex
is ﬁrst the list of vertices in the block, then a list (or vector) of numbers of cells in each
direction. This was originally set to (20 20 1) for the cavity case. The user should now
change this to (40 40 1) and save the ﬁle. The new reﬁned mesh should then be created
by running blockMesh as before.
2.1.5.3 Mapping the coarse mesh results onto the ﬁne mesh
The mapFields utility maps one or more ﬁelds relating to a given geometry onto the cor-
responding ﬁelds for another geometry. In our example, the ﬁelds are deemed ‘consistent’
because the geometry and the boundary types, or conditions, of both source and tar-
get ﬁelds are identical. We use the -consistent command line option when executing
mapFields in this example.
The ﬁeld data that mapFields maps is read from the time directory speciﬁed by
startFrom/startTime in the controlDict of the target case, i.e. those into which the
results are being mapped. In this example, we wish to map the ﬁnal results of the coarser
mesh from case cavity onto the ﬁner mesh of case cavityFine. Therefore, since these re-
sults are stored in the 0.5 directory of cavity, the startTime should be set to 0.5 s in the
controlDict dictionary and startFrom should be set to startTime.
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-31
The case is ready to run mapFields. Typing mapFields -help quickly shows that map-
Fields requires the source case directory as an argument. We are using the -consistent
option, so the utility is executed from withing the cavityFine directory by
mapFields ../cavity -consistent
The utility should run with output to the terminal including:
Source: ".." "cavity"
Target: "." "cavityFine"
Create databases as time
Source time: 0.5
Target time: 0.5
Create meshes
Source mesh size: 400 Target mesh size: 1600
Consistently creating and mapping fields for time 0.5
interpolating p
interpolating U
End
2.1.5.4 Control adjustments
To maintain a Courant number of less that 1, as discussed in section 2.1.1.4, the time
step must now be halved since the size of all cells has halved. Therefore deltaT should
be set to to 0.0025 s in the controlDict dictionary. Field data is currently written out at
an interval of a ﬁxed number of time steps. Here we demonstrate how to specify data
output at ﬁxed intervals of time. Under the writeControl keyword in controlDict, instead
of requesting output by a ﬁxed number of time steps with the timeStep entry, a ﬁxed
amount of run time can be speciﬁed between the writing of results using the runTime
entry. In this case the user should specify output every 0.1 and therefore should set
writeInterval to 0.1 and writeControl to runTime. Finally, since the case is starting
with a the solution obtained on the coarse mesh we only need to run it for a short period
to achieve reasonable convergence to steady-state. Therefore the endTime should be set
to 0.7 s. Make sure these settings are correct and then save the ﬁle.
2.1.5.5 Running the code as a background process
The user should experience running icoFoam as a background process, redirecting the
terminal output to a log ﬁle that can be viewed later. From the cavityFine directory, the
user should execute:
icoFoam > log &
cat log
2.1.5.6 Vector plot with the reﬁned mesh
The user can open multiple cases simultaneously in ParaView; essentially because each new
case is simply another module that appears in the Pipeline Browser. There is one minor
inconvenience when opening a new case in ParaView because there is a prerequisite that
the selected data is a ﬁle with a name that has an extension. However, in OpenFOAM,
each case is stored in a multitude of ﬁles with no extensions within a speciﬁc directory
Open∇FOAM-2.2.0
U-32 Tutorials
Open Display panel
Select Scatter Plot
Select Ux from Line Series
Select arc length
Figure 2.10: Selecting ﬁelds for graph plotting.
structure. The solution, that the paraFoam script performs automatically, is to create
a dummy ﬁle with the extension .OpenFOAM — hence, the cavity case module is called
cavity.OpenFOAM.
However, if the user wishes to open another case directly from within ParaView, they
need to create such a dummy ﬁle. For example, to load the cavityFine case the ﬁle would
be created by typing at the command prompt:
cd $FOAM RUN/tutorials/incompressible/icoFoam
touch cavityFine/cavityFine.OpenFOAM
Now the cavityFine case can be loaded into ParaView by selecting Open from the File
menu, and having navigated the directory tree, selecting cavityFine.OpenFOAM. The user
can now make a vector plot of the results from the reﬁned mesh in ParaView. The plot can
be compared with the cavity case by enabling glyph images for both case simultaneously.
2.1.5.7 Plotting graphs
The user may wish to visualise the results by extracting some scalar measure of velocity
and plotting 2-dimensional graphs along lines through the domain. OpenFOAM is well
equipped for this kind of data manipulation. There are numerous utilities that do spe-
cialised data manipulations, and some, simpler calculations are incorporated into a single
utility foamCalc. As a utility, it is unique in that it is executed by
foamCalc <calcType> <fieldName1 ... fieldNameN>
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-33
The calculator operation is speciﬁed in <calcType>; at the time of writing, the following
operations are implemented: addSubtract; randomise; div; components; mag; magGrad;
magSqr; interpolate. The user can obtain the list of <calcType> by deliberately calling
one that does not exist, so that foamCalc throws up an error message and lists the types
available, e.g.
>> foamCalc xxxx
Selecting calcType xxxx
unknown calcType type xxxx, constructor not in hash table
Valid calcType selections are:
8
(
randomise
magSqr
magGrad
addSubtract
div
mag
interpolate
components
)
The components and mag calcTypes provide useful scalar measures of velocity. When
“foamCalc components U” is run on a case, say cavity, it reads in the velocity vector ﬁeld
from each time directory and, in the corresponding time directories, writes scalar ﬁelds
Ux, Uy and Uz representing the x, y and z components of velocity. Similarly “foamCalc
mag U” writes a scalar ﬁeld magU to each time directory representing the magnitude of
velocity.
The user can run foamCalc with the components calcType on both cavity and cavityFine
cases. For example, for the cavity case the user should do into the cavity directory and
execute foamCalc as follows:
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavity
foamCalc components U
The individual components can be plotted as a graph in ParaView. It is quick, con-
venient and has reasonably good control over labelling and formatting, so the printed
output is a fairly good standard. However, to produce graphs for publication, users may
prefer to write raw data and plot it with a dedicated graphing tool, such as gnuplot or
Grace/xmgr. To do this, we recommend using the sample utility, described in section 6.5
and section 2.2.3.
Before commencing plotting, the user needs to load the newly generated Ux, Uy and
Uz ﬁelds into ParaView. To do this, the user should click the Refresh Times at the top
of the Properties panel for the cavity.OpenFOAM module which will cause the new ﬁelds
to be loaded into ParaView and appear in the Volume Fields window. Ensure the new
ﬁelds are selected and the changes are applied, i.e. click Apply again if necessary. Also,
data is interpolated incorrectly at boundaries if the boundary regions are selected in the
Mesh Parts panel. Therefore the user should deselect the patches in the Mesh Parts panel,
i.e.movingWall, fixedWall and frontAndBack, and apply the changes.
Now, in order to display a graph in ParaView the user should select the module of inter-
est, e.g.cavity.OpenFOAM and apply the Plot Over Line ﬁlter from the Filter->Data
Analysis menu. This opens up a new XY Plot window below or beside the existing 3D
View window. A PlotOverLine module is created in which the user can specify the end
points of the line in the Properties panel. In this example, the user should position the
line vertically up the centre of the domain, i.e. from (0.05, 0, 0.005) to (0.05, 0.1, 0.005),
in the Point1 and Point2 text boxes. The Resolution can be set to 100.
Open∇FOAM-2.2.0
U-34 Tutorials
Figure 2.11: Plotting graphs in paraFoam.
On clicking Apply, a graph is generated in the XY Plot window. In the Display panel,
the user should set Attribute Mode to Point Data. The Use Data Array option can
be selected for the X Axis Data, taking the arc length option so that the x-axis of the
graph represents distance from the base of the cavity.
The user can choose the ﬁelds to be displayed in the Line Series panel of the Display
window. From the list of scalar ﬁelds to be displayed, it can be seen that the magnitude
and components of vector ﬁelds are available by default, e.g. displayed as U:X, so that
it was not necessary to create Ux using foamCalc. Nevertheless, the user should deselect
all series except Ux (or U:x). A square colour box in the adjacent column to the selected
series indicates the line colour. The user can edit this most easily by a double click of the
mouse over that selection.
In order to format the graph, the user should modify the settings below the Line Series
panel, namely Line Color, Line Thickness, Line Style, Marker Style and Chart
Axes.
Also the user can click one of the buttons above the top left corner of the XY Plot.
The third button, for example, allows the user to control View Settings in which the user
can set title and legend for each axis, for example. Also, the user can set font, colour and
alignment of the axes titles, and has several options for axis range and labels in linear or
logarithmic scales.
Figure 2.11 is a graph produced using ParaView. The user can produce a graph
however he/she wishes. For information, the graph in Figure 2.11 was produced with the
options for axes of: Standard type of Notation; Specify Axis Range selected; titles in Sans
Serif 12 font. The graph is displayed as a set of points rather than a line by activating
the Enable Line Series button in the Display window. Note: if this button appears to be
inactive by being “greyed out”, it can be made active by selecting and deselecting the
sets of variables in the Line Series panel. Once the Enable Line Series button is selected,
the Line Style and Marker Style can be adjusted to the user’s preference.
2.1.6 Introducing mesh grading
The error in any solution will be more pronounced in regions where the form of the
true solution diﬀer widely from the form assumed in the chosen numerical schemes. For
example a numerical scheme based on linear variations of variables over cells can only
generate an exact solution if the true solution is itself linear in form. The error is largest
in regions where the true solution deviates greatest from linear form, i.e. where the change
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-35
in gradient is largest. Error decreases with cell size.
It is useful to have an intuitive appreciation of the form of the solution before setting
up any problem. It is then possible to anticipate where the errors will be largest and
to grade the mesh so that the smallest cells are in these regions. In the cavity case the
large variations in velocity can be expected near a wall and so in this part of the tutorial
the mesh will be graded to be smaller in this region. By using the same number of cells,
greater accuracy can be achieved without a signiﬁcant increase in computational cost.
A mesh of 20 × 20 cells with grading towards the walls will be created for the lid-
driven cavity problem and the results from the ﬁner mesh of section 2.1.5.2 will then be
mapped onto the graded mesh to use as an initial condition. The results from the graded
mesh will be compared with those from the previous meshes. Since the changes to the
blockMeshDict dictionary are fairly substantial, the case used for this part of the tutorial,
cavityGrade, is supplied in the $FOAM RUN/tutorials/incompressible/icoFoam directory.
2.1.6.1 Creating the graded mesh
The mesh now needs 4 blocks as diﬀerent mesh grading is needed on the left and right and
top and bottom of the domain. The block structure for this mesh is shown in Figure 2.12.
The user can view the blockMeshDict ﬁle in the constant/polyMesh subdirectory of cavi-
0
z
x
y
3 4 5
6 87
1 2
1715
9 1110
16
12 13 14
0 1
2 3
Figure 2.12: Block structure of the graded mesh for the cavity (block numbers encircled).
tyGrade; for completeness the key elements of the blockMeshDict ﬁle are also reproduced
below. Each block now has 10 cells in the x and y directions and the ratio between largest
and smallest cells is 2.
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (0.5 0 0)
23 (1 0 0)
24 (0 0.5 0)
25 (0.5 0.5 0)
26 (1 0.5 0)
27 (0 1 0)
28 (0.5 1 0)
29 (1 1 0)
30 (0 0 0.1)
31 (0.5 0 0.1)
32 (1 0 0.1)
33 (0 0.5 0.1)
34 (0.5 0.5 0.1)
35 (1 0.5 0.1)
36 (0 1 0.1)
Open∇FOAM-2.2.0
U-36 Tutorials
37 (0.5 1 0.1)
38 (1 1 0.1)
39 );
40
41 blocks
42 (
43 hex (0 1 4 3 9 10 13 12) (10 10 1) simpleGrading (2 2 1)
44 hex (1 2 5 4 10 11 14 13) (10 10 1) simpleGrading (0.5 2 1)
45 hex (3 4 7 6 12 13 16 15) (10 10 1) simpleGrading (2 0.5 1)
46 hex (4 5 8 7 13 14 17 16) (10 10 1) simpleGrading (0.5 0.5 1)
47 );
48
49 edges
50 (
51 );
52
53 boundary
54 (
55 movingWall
56 {
57 type wall;
58 faces
59 (
60 (6 15 16 7)
61 (7 16 17 8)
62 );
63 }
64 fixedWalls
65 {
66 type wall;
67 faces
68 (
69 (3 12 15 6)
70 (0 9 12 3)
71 (0 1 10 9)
72 (1 2 11 10)
73 (2 5 14 11)
74 (5 8 17 14)
75 );
76 }
77 frontAndBack
78 {
79 type empty;
80 faces
81 (
82 (0 3 4 1)
83 (1 4 5 2)
84 (3 6 7 4)
85 (4 7 8 5)
86 (9 10 13 12)
87 (10 11 14 13)
88 (12 13 16 15)
89 (13 14 17 16)
90 );
91 }
92 );
93
94 mergePatchPairs
95 (
96 );
97
98 // ************************************************************************* //
Once familiar with the blockMeshDict ﬁle for this case, the user can execute blockMesh
from the command line. The graded mesh can be viewed as before using paraFoam as
described in section 2.1.2.
2.1.6.2 Changing time and time step
The highest velocities and smallest cells are next to the lid, therefore the highest Courant
number will be generated next to the lid, for reasons given in section 2.1.1.4. It is therefore
useful to estimate the size of the cells next to the lid to calculate an appropriate time
step for this case.
When a nonuniform mesh grading is used, blockMesh calculates the cell sizes using a
geometric progression. Along a length l, if n cells are requested with a ratio of R between
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-37
the last and ﬁrst cells, the size of the smallest cell, δxs, is given by:
δxs = l
r − 1
αr − 1
(2.5)
where r is the ratio between one cell size and the next which is given by:
r = R
1
n−1 (2.6)
and
α =
R for R > 1,
1 − r−n
+ r−1
for R < 1.
(2.7)
For the cavityGrade case the number of cells in each direction in a block is 10, the ratio
between largest and smallest cells is 2 and the block height and width is 0.05 m. Therefore
the smallest cell length is 3.45 mm. From Equation 2.2, the time step should be less than
3.45 ms to maintain a Courant of less than 1. To ensure that results are written out
at convenient time intervals, the time step deltaT should be reduced to 2.5 ms and the
writeInterval set to 40 so that results are written out every 0.1 s. These settings can
be viewed in the cavityGrade/system/controlDict ﬁle.
The startTime needs to be set to that of the ﬁnal conditions of the case cavityFine,
i.e.0.7. Since cavity and cavityFine converged well within the prescribed run time, we can
set the run time for case cavityGrade to 0.1 s, i.e. the endTime should be 0.8.
2.1.6.3 Mapping ﬁelds
As in section 2.1.5.3, use mapFields to map the ﬁnal results from case cavityFine onto the
mesh for case cavityGrade. Enter the cavityGrade directory and execute mapFields by:
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavityGrade
mapFields ../cavityFine -consistent
Now run icoFoam from the case directory and monitor the run time information. View
the converged results for this case and compare with other results using post-processing
tools described previously in section 2.1.5.6 and section 2.1.5.7.
2.1.7 Increasing the Reynolds number
The cases solved so far have had a Reynolds number of 10. This is very low and leads to
a stable solution quickly with only small secondary vortices at the bottom corners of the
cavity. We will now increase the Reynolds number to 100, at which point the solution
takes a noticeably longer time to converge. The coarsest mesh in case cavity will be used
initially. The user should make a copy of the cavity case and name it cavityHighRe by
typing:
cd $FOAM_RUN/tutorials/incompressible/icoFoam
cp -r cavity cavityHighRe
Open∇FOAM-2.2.0
U-38 Tutorials
2.1.7.1 Pre-processing
Enter the cavityHighRe case and edit the transportProperties dictionary. Since the Reynolds
number is required to be increased by a factor of 10, decrease the kinematic viscosity by
a factor of 10, i.e. to 1 × 10−3
m2
s−1
. We can now run this case by restarting from the
solution at the end of the cavity case run. To do this we can use the option of setting the
startFrom keyword to latestTime so that icoFoam takes as its initial data the values
stored in the directory corresponding to the most recent time, i.e. 0.5. The endTime
should be set to 2 s.
2.1.7.2 Running the code
Run icoFoam for this case from the case directory and view the run time information.
When running a job in the background, the following UNIX commands can be useful:
nohup enables a command to keep running after the user who issues the command has
logged out;
nice changes the priority of the job in the kernel’s scheduler; a niceness of -20 is the
highest priority and 19 is the lowest priority.
This is useful, for example, if a user wishes to set a case running on a remote machine
and does not wish to monitor it heavily, in which case they may wish to give it low
priority on the machine. In that case the nohup command allows the user to log out of a
remote machine he/she is running on and the job continues running, while nice can set
the priority to 19. For our case of interest, we can execute the command in this manner
as follows:
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavityHighRe
nohup nice -n 19 icoFoam > log &
cat log
In previous runs you may have noticed that icoFoam stops solving for velocity U quite
quickly but continues solving for pressure p for a lot longer or until the end of the run.
In practice, once icoFoam stops solving for U and the initial residual of p is less than
the tolerance set in the fvSolution dictionary (typically 10−6
), the run has eﬀectively
converged and can be stopped once the ﬁeld data has been written out to a time directory.
For example, at convergence a sample of the log ﬁle from the run on the cavityHighRe
case appears as follows in which the velocity has already converged after 1.62 s and
initial pressure residuals are small; No Iterations 0 indicates that the solution of U has
stopped:
1
2 Time = 1.63
3
4 Courant Number mean: 0.108642 max: 0.818175
5 DILUPBiCG: Solving for Ux, Initial residual = 7.86044e-06, Final residual = 7.86044e-06,
6 No Iterations 0
7 DILUPBiCG: Solving for Uy, Initial residual = 9.4171e-06, Final residual = 9.4171e-06,
8 No Iterations 0
9 DICPCG: Solving for p, Initial residual = 3.54721e-06, Final residual = 7.13506e-07,
10 No Iterations 4
11 time step continuity errors : sum local = 6.46788e-09, global = -9.44516e-19,
12 cumulative = 1.04595e-17
13 DICPCG: Solving for p, Initial residual = 2.15824e-06, Final residual = 9.95068e-07,
14 No Iterations 3
15 time step continuity errors : sum local = 8.67501e-09, global = 7.54182e-19,
16 cumulative = 1.12136e-17
17 ExecutionTime = 1.02 s ClockTime = 1 s
18
19 Time = 1.635
20
21 Courant Number mean: 0.108643 max: 0.818176
22 DILUPBiCG: Solving for Ux, Initial residual = 7.6728e-06, Final residual = 7.6728e-06,
23 No Iterations 0
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-39
24 DILUPBiCG: Solving for Uy, Initial residual = 9.19442e-06, Final residual = 9.19442e-06,
25 No Iterations 0
26 DICPCG: Solving for p, Initial residual = 3.13107e-06, Final residual = 8.60504e-07,
27 No Iterations 4
28 time step continuity errors : sum local = 8.15435e-09, global = -5.84817e-20,
29 cumulative = 1.11552e-17
30 DICPCG: Solving for p, Initial residual = 2.16689e-06, Final residual = 5.27197e-07,
31 No Iterations 14
32 time step continuity errors : sum local = 3.45666e-09, global = -5.62297e-19,
33 cumulative = 1.05929e-17
34 ExecutionTime = 1.02 s ClockTime = 1 s
2.1.8 High Reynolds number ﬂow
View the results in paraFoam and display the velocity vectors. The secondary vortices in
the corners have increased in size somewhat. The user can then increase the Reynolds
number further by decreasing the viscosity and then rerun the case. The number of
vortices increases so the mesh resolution around them will need to increase in order to
resolve the more complicated ﬂow patterns. In addition, as the Reynolds number increases
the time to convergence increases. The user should monitor residuals and extend the
endTime accordingly to ensure convergence.
The need to increase spatial and temporal resolution then becomes impractical as
the ﬂow moves into the turbulent regime, where problems of solution stability may also
occur. Of course, many engineering problems have very high Reynolds numbers and it
is infeasible to bear the huge cost of solving the turbulent behaviour directly. Instead
Reynolds-averaged simulation (RAS) turbulence models are used to solve for the mean
ﬂow behaviour and calculate the statistics of the ﬂuctuations. The standard k − ε model
with wall functions will be used in this tutorial to solve the lid-driven cavity case with
a Reynolds number of 104
. Two extra variables are solved for: k, the turbulent kinetic
energy; and, ε, the turbulent dissipation rate. The additional equations and models for
turbulent ﬂow are implemented into a OpenFOAM solver called pisoFoam.
2.1.8.1 Pre-processing
Change directory to the cavity case in the $FOAM RUN/tutorials/incompressible/pisoFoam/-
ras directory (N.B: the pisoFoam/ras directory). Generate the mesh by running blockMesh
as before. Mesh grading towards the wall is not necessary when using the standard k − ε
model with wall functions since the ﬂow in the near wall cell is modelled, rather than
having to be resolved.
A range of wall function models is available in OpenFOAM that are applied as bound-
ary conditions on individual patches. This enables diﬀerent wall function models to be
applied to diﬀerent wall regions. The choice of wall function models are speciﬁed through
the turbulent viscosity ﬁeld, νt in the 0/nut ﬁle:
17
18 dimensions [0 2 -1 0 0 0 0];
19
20 internalField uniform 0;
21
22 boundaryField
23 {
24 movingWall
25 {
26 type nutkWallFunction;
27 value uniform 0;
28 }
29 fixedWalls
30 {
31 type nutkWallFunction;
32 value uniform 0;
33 }
34 frontAndBack
35 {
36 type empty;
37 }
Open∇FOAM-2.2.0
U-40 Tutorials
38 }
39
40
41 // ************************************************************************* //
This case uses standard wall functions, speciﬁed by the nutWallFunction type on the
movingWall and fixedWalls patches. Other wall function models include the rough wall
functions, speciﬁed though the nutRoughWallFunction keyword.
The user should now open the ﬁeld ﬁles for k and ε (0/k and 0/epsilon) and examine
their boundary conditions. For a wall boundary condition, ε is assigned a epsilonWall-
Function boundary condition and a kqRwallFunction boundary condition is assigned to k.
The latter is a generic boundary condition that can be applied to any ﬁeld that are of a
turbulent kinetic energy type, e.g. k, q or Reynolds Stress R. The initial values for k and
ε are set using an estimated ﬂuctuating component of velocity U′
and a turbulent length
scale, l. k and ε are deﬁned in terms of these parameters as follows:
k =
1
2
U′ • U′ (2.8)
ε =
C0.75
µ k1.5
l
(2.9)
where Cµ is a constant of the k − ε model equal to 0.09. For a Cartesian coordinate
system, k is given by:
k =
1
2
(U′ 2
x + U′ 2
y + U′ 2
z ) (2.10)
where U′ 2
x , U′ 2
y and U′ 2
z are the ﬂuctuating components of velocity in the x, y and z
directions respectively. Let us assume the initial turbulence is isotropic, i.e. U′ 2
x = U′ 2
y =
U′ 2
z , and equal to 5% of the lid velocity and that l, is equal to 20% of the box width, 0.1
m, then k and ε are given by:
U′
x = U′
y = U′
z =
5
100
1 m s−1
(2.11)
⇒ k =
3
2
5
100
2
m2
s−2
= 3.75 × 10−3
m2
s−2
(2.12)
ε =
C0.75
µ k1.5
l
≈ 7.65 × 10−4
m2
s−3
(2.13)
These form the initial conditions for k and ε. The initial conditions for U and p are
(0, 0, 0) and 0 respectively as before.
Turbulence modelling includes a range of methods, e.g. RAS or large-eddy simulation
(LES), that are provided in OpenFOAM. In most transient solvers, the choice of turbu-
lence modelling method is selectable at run-time through the simulationType keyword
in turbulenceProperties dictionary. The user can view this ﬁle in the constant directory:
17
18 simulationType RASModel;
19
20
21 // ************************************************************************* //
The options for simulationType are laminar, RASModel and LESModel. With RASModel
selected in this case, the choice of RAS modelling is speciﬁed in a RASProperties ﬁle, also
in the constant directory. The turbulence model is selected by the RASModel entry from a
long list of available models that are listed in Table 3.9. The kEpsilon model should be
selected which is is the standard k−ε model; the user should also ensure that turbulence
calculation is switched on.
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-41
The coeﬃcients for each turbulence model are stored within the respective code with a
set of default values. Setting the optional switch called printCoeffs to on will make the
default values be printed to standard output, i.e. the terminal, when the model is called
at run time. The coeﬃcients are printed out as a sub-dictionary whose name is that of
the model name with the word Coeffs appended, e.g. kEpsilonCoeffs in the case of
the kEpsilon model. The coeﬃcients of the model, e.g. kEpsilon, can be modiﬁed by
optionally including (copying and pasting) that sub-dictionary within the RASProperties
dictionary and adjusting values accordingly.
The user should next set the laminar kinematic viscosity in the transportProperties
dictionary. To achieve a Reynolds number of 104
, a kinematic viscosity of 10−5
m is
required based on the Reynolds number deﬁnition given in Equation 2.1.
Finally the user should set the startTime, stopTime, deltaT and the writeInterval
in the controlDict. Set deltaT to 0.005 s to satisfy the Courant number restriction and
the endTime to 10 s.
2.1.8.2 Running the code
Execute pisoFoam by entering the case directory and typing “pisoFoam” in a terminal.
In this case, where the viscosity is low, the boundary layer next to the moving lid is
very thin and the cells next to the lid are comparatively large so the velocity at their
centres are much less than the lid velocity. In fact, after ≈ 100 time steps it becomes
apparent that the velocity in the cells adjacent to the lid reaches an upper limit of around
0.2 m s−1
hence the maximum Courant number does not rise much above 0.2. It is sensible
to increase the solution time by increasing the time step to a level where the Courant
number is much closer to 1. Therefore reset deltaT to 0.02 s and, on this occasion, set
startFrom to latestTime. This instructs pisoFoam to read the start data from the latest
time directory, i.e.10.0. The endTime should be set to 20 s since the run converges a lot
slower than the laminar case. Restart the run as before and monitor the convergence of
the solution. View the results at consecutive time steps as the solution progresses to see
if the solution converges to a steady-state or perhaps reaches some periodically oscillating
state. In the latter case, convergence may never occur but this does not mean the results
are inaccurate.
2.1.9 Changing the case geometry
A user may wish to make changes to the geometry of a case and perform a new simulation.
It may be useful to retain some or all of the original solution as the starting conditions
for the new simulation. This is a little complex because the ﬁelds of the original solution
are not consistent with the ﬁelds of the new case. However the mapFields utility can map
ﬁelds that are inconsistent, either in terms of geometry or boundary types or both.
As an example, let us go to the cavityClipped case in the icoFoam directory which
consists of the standard cavity geometry but with a square of length 0.04 m removed from
the bottom right of the cavity, according to the blockMeshDict below:
17 convertToMeters 0.1;
18
19 vertices
20 (
21 (0 0 0)
22 (0.6 0 0)
23 (0 0.4 0)
24 (0.6 0.4 0)
25 (1 0.4 0)
26 (0 1 0)
27 (0.6 1 0)
28 (1 1 0)
29
Open∇FOAM-2.2.0
U-42 Tutorials
30 (0 0 0.1)
31 (0.6 0 0.1)
32 (0 0.4 0.1)
33 (0.6 0.4 0.1)
34 (1 0.4 0.1)
35 (0 1 0.1)
36 (0.6 1 0.1)
37 (1 1 0.1)
38
39 );
40
41 blocks
42 (
43 hex (0 1 3 2 8 9 11 10) (12 8 1) simpleGrading (1 1 1)
44 hex (2 3 6 5 10 11 14 13) (12 12 1) simpleGrading (1 1 1)
45 hex (3 4 7 6 11 12 15 14) (8 12 1) simpleGrading (1 1 1)
46 );
47
48 edges
49 (
50 );
51
52 boundary
53 (
54 lid
55 {
56 type wall;
57 faces
58 (
59 (5 13 14 6)
60 (6 14 15 7)
61 );
62 }
63 fixedWalls
64 {
65 type wall;
66 faces
67 (
68 (0 8 10 2)
69 (2 10 13 5)
70 (7 15 12 4)
71 (4 12 11 3)
72 (3 11 9 1)
73 (1 9 8 0)
74 );
75 }
76 frontAndBack
77 {
78 type empty;
79 faces
80 (
81 (0 2 3 1)
82 (2 5 6 3)
83 (3 6 7 4)
84 (8 9 11 10)
85 (10 11 14 13)
86 (11 12 15 14)
87 );
88 }
89 );
90
91 mergePatchPairs
92 (
93 );
94
95 // ************************************************************************* //
Generate the mesh with blockMesh. The patches are set accordingly as in previous cavity
cases. For the sake of clarity in describing the ﬁeld mapping process, the upper wall patch
is renamed lid, previously the movingWall patch of the original cavity.
In an inconsistent mapping, there is no guarantee that all the ﬁeld data can be mapped
from the source case. The remaining data must come from ﬁeld ﬁles in the target case
itself. Therefore ﬁeld data must exist in the time directory of the target case before
mapping takes place. In the cavityClipped case the mapping is set to occur at time 0.5 s,
since the startTime is set to 0.5 s in the controlDict. Therefore the user needs to copy
initial ﬁeld data to that directory, e.g. from time 0:
cd $FOAM RUN/tutorials/incompressible/icoFoam/cavityClipped
Open∇FOAM-2.2.0
2.1 Lid-driven cavity ﬂow U-43
cp -r 0 0.5
Before mapping the data, the user should view the geometry and ﬁelds at 0.5 s.
Now we wish to map the velocity and pressure ﬁelds from cavity onto the new ﬁelds
of cavityClipped. Since the mapping is inconsistent, we need to edit the mapFieldsDict
dictionary, located in the system directory. The dictionary contains 2 keyword entries:
patchMap and cuttingPatches. The patchMap list contains a mapping of patches from
the source ﬁelds to the target ﬁelds. It is used if the user wishes a patch in the target
ﬁeld to inherit values from a corresponding patch in the source ﬁeld. In cavityClipped, we
wish to inherit the boundary values on the lid patch from movingWall in cavity so we
must set the patchMap as:
patchMap
(
lid movingWall
);
The cuttingPatches list contains names of target patches whose values are to be
mapped from the source internal ﬁeld through which the target patch cuts. In this case
we will include the fixedWalls to demonstrate the interpolation process.
cuttingPatches
(
fixedWalls
);
Now the user should run mapFields, from within the cavityClipped directory:
mapFields ../cavity
The user can view the mapped ﬁeld as shown in Figure 2.13. The boundary patches
have inherited values from the source case as we expected. Having demonstrated this,
however, we actually wish to reset the velocity on the fixedWalls patch to (0, 0, 0). Edit
the U ﬁeld, go to the fixedWalls patch and change the ﬁeld from nonuniform to uniform
(0, 0, 0). The nonuniform ﬁeld is a list of values that requires deleting in its entirety. Now
run the case with icoFoam.
2.1.10 Post-processing the modiﬁed geometry
Velocity glyphs can be generated for the case as normal, ﬁrst at time 0.5 s and later at
time 0.6 s, to compare the initial and ﬁnal solutions. In addition, we provide an outline of
the geometry which requires some care to generate for a 2D case. The user should select
Extract Block from the Filter menu and, in the Parameter panel, highlight the patches
of interest, namely the lid and ﬁxedWalls. On clicking Apply, these items of geometry can
be displayed by selecting Wireframe in the Display panel. Figure 2.14 displays the patches
in black and shows vortices forming in the bottom corners of the modiﬁed geometry.
Open∇FOAM-2.2.0
U-44 Tutorials
Figure 2.13: cavity solution velocity ﬁeld mapped onto cavityClipped.
Figure 2.14: cavityClipped solution for velocity ﬁeld.
Open∇FOAM-2.2.0
2.2 Stress analysis of a plate with a hole U-45
2.2 Stress analysis of a plate with a hole
This tutorial describes how to pre-process, run and post-process a case involving linear-
elastic, steady-state stress analysis on a square plate with a circular hole at its centre.
The plate dimensions are: side length 4 m and radius R = 0.5 m. It is loaded with a
uniform traction of σ = 10 kPa over its left and right faces as shown in Figure 2.15. Two
symmetry planes can be identiﬁed for this geometry and therefore the solution domain
need only cover a quarter of the geometry, shown by the shaded area in Figure 2.15.
xsymmetry plane
4.0 m
y
σ = 10 kPaσ = 10 kPa
R = 0.5 m
symmetryplane
Figure 2.15: Geometry of the plate with a hole.
The problem can be approximated as 2-dimensional since the load is applied in the
plane of the plate. In a Cartesian coordinate system there are two possible assumptions
to take in regard to the behaviour of the structure in the third dimension: (1) the plane
stress condition, in which the stress components acting out of the 2D plane are assumed
to be negligible; (2) the plane strain condition, in which the strain components out of
the 2D plane are assumed negligible. The plane stress condition is appropriate for solids
whose third dimension is thin as in this case; the plane strain condition is applicable for
solids where the third dimension is thick.
An analytical solution exists for loading of an inﬁnitely large, thin plate with a circular
hole. The solution for the stress normal to the vertical plane of symmetry is
(σxx)x=0 =



σ 1 +
R2
2y2
+
3R4
2y4
for |y| ≥ R
0 for |y| < R
(2.14)
Results from the simulation will be compared with this solution. At the end of the
tutorial, the user can: investigate the sensitivity of the solution to mesh resolution and
mesh grading; and, increase the size of the plate in comparison to the hole to try to
estimate the error in comparing the analytical solution for an inﬁnite plate to the solution
of this problem of a ﬁnite plate.
Open∇FOAM-2.2.0
U-46 Tutorials
2.2.1 Mesh generation
The domain consists of four blocks, some of which have arc-shaped edges. The block
structure for the part of the mesh in the x − y plane is shown in Figure 2.16. As already
mentioned in section 2.1.1.1, all geometries are generated in 3 dimensions in OpenFOAM
even if the case is to be as a 2 dimensional problem. Therefore a dimension of the block
in the z direction has to be chosen; here, 0.5 m is selected. It does not aﬀect the solution
since the traction boundary condition is speciﬁed as a stress rather than a force, thereby
making the solution independent of the cross-sectional area.
x
y x2
x1 x1
x2
x2
x1
x1
x2
x2
x1
left
left
up 7 up
right
3
down
hole
0
down
right
6
9
8
4
10
10 2
5
2
1
4 3
Figure 2.16: Block structure of the mesh for the plate with a hole.
The user should change into the plateHole case in the $FOAM RUN/tutorials/stress-
Analysis/solidDisplacementFoam directory and open the constant/polyMesh/blockMeshDict
ﬁle in an editor, as listed below
17 convertToMeters 1;
18
19 vertices
20 (
21 (0.5 0 0)
22 (1 0 0)
23 (2 0 0)
24 (2 0.707107 0)
25 (0.707107 0.707107 0)
26 (0.353553 0.353553 0)
27 (2 2 0)
28 (0.707107 2 0)
29 (0 2 0)
30 (0 1 0)
31 (0 0.5 0)
32 (0.5 0 0.5)
33 (1 0 0.5)
34 (2 0 0.5)
35 (2 0.707107 0.5)
36 (0.707107 0.707107 0.5)
Open∇FOAM-2.2.0
2.2 Stress analysis of a plate with a hole U-47
37 (0.353553 0.353553 0.5)
38 (2 2 0.5)
39 (0.707107 2 0.5)
40 (0 2 0.5)
41 (0 1 0.5)
42 (0 0.5 0.5)
43 );
44
45 blocks
46 (
47 hex (5 4 9 10 16 15 20 21) (10 10 1) simpleGrading (1 1 1)
48 hex (0 1 4 5 11 12 15 16) (10 10 1) simpleGrading (1 1 1)
49 hex (1 2 3 4 12 13 14 15) (20 10 1) simpleGrading (1 1 1)
50 hex (4 3 6 7 15 14 17 18) (20 20 1) simpleGrading (1 1 1)
51 hex (9 4 7 8 20 15 18 19) (10 20 1) simpleGrading (1 1 1)
52 );
53
54 edges
55 (
56 arc 0 5 (0.469846 0.17101 0)
57 arc 5 10 (0.17101 0.469846 0)
58 arc 1 4 (0.939693 0.34202 0)
59 arc 4 9 (0.34202 0.939693 0)
60 arc 11 16 (0.469846 0.17101 0.5)
61 arc 16 21 (0.17101 0.469846 0.5)
62 arc 12 15 (0.939693 0.34202 0.5)
63 arc 15 20 (0.34202 0.939693 0.5)
64 );
65
66 boundary
67 (
68 left
69 {
70 type symmetryPlane;
71 faces
72 (
73 (8 9 20 19)
74 (9 10 21 20)
75 );
76 }
77 right
78 {
79 type patch;
80 faces
81 (
82 (2 3 14 13)
83 (3 6 17 14)
84 );
85 }
86 down
87 {
88 type symmetryPlane;
89 faces
90 (
91 (0 1 12 11)
92 (1 2 13 12)
93 );
94 }
95 up
96 {
97 type patch;
98 faces
99 (
100 (7 8 19 18)
101 (6 7 18 17)
102 );
103 }
104 hole
105 {
106 type patch;
107 faces
108 (
109 (10 5 16 21)
110 (5 0 11 16)
111 );
112 }
113 frontAndBack
114 {
115 type empty;
116 faces
117 (
118 (10 9 4 5)
119 (5 4 1 0)
120 (1 4 3 2)
121 (4 7 6 3)
Open∇FOAM-2.2.0
U-48 Tutorials
122 (4 9 8 7)
123 (21 16 15 20)
124 (16 11 12 15)
125 (12 13 14 15)
126 (15 14 17 18)
127 (15 18 19 20)
128 );
129 }
130 );
131
132 mergePatchPairs
133 (
134 );
135
136 // ************************************************************************* //
Until now, we have only speciﬁed straight edges in the geometries of previous tutorials but
here we need to specify curved edges. These are speciﬁed under the edges keyword entry
which is a list of non-straight edges. The syntax of each list entry begins with the type
of curve, including arc, simpleSpline, polyLine etc., described further in section 5.3.1.
In this example, all the edges are circular and so can be speciﬁed by the arc keyword
entry. The following entries are the labels of the start and end vertices of the arc and a
point vector through which the circular arc passes.
The blocks in this blockMeshDict do not all have the same orientation. As can be seen
in Figure 2.16 the x2 direction of block 0 is equivalent to the −x1 direction for block 4.
This means care must be taken when deﬁning the number and distribution of cells in each
block so that the cells match up at the block faces.
6 patches are deﬁned: one for each side of the plate, one for the hole and one for the
front and back planes. The left and down patches are both a symmetry plane. Since this
is a geometric constraint, it is included in the deﬁnition of the mesh, rather than being
purely a speciﬁcation on the boundary condition of the ﬁelds. Therefore they are deﬁned
as such using a special symmetryPlane type as shown in the blockMeshDict.
The frontAndBack patch represents the plane which is ignored in a 2D case. Again
this is a geometric constraint so is deﬁned within the mesh, using the empty type as shown
in the blockMeshDict. For further details of boundary types and geometric constraints,
the user should refer to section 5.2.1.
The remaining patches are of the regular patch type. The mesh should be generated
using blockMesh and can be viewed in paraFoam as described in section 2.1.2. It should
appear as in Figure 2.17.
Figure 2.17: Mesh of the hole in a plate problem.
Open∇FOAM-2.2.0
2.2 Stress analysis of a plate with a hole U-49
2.2.1.1 Boundary and initial conditions
Once the mesh generation is complete, the initial ﬁeld with boundary conditions must be
set. For a stress analysis case without thermal stresses, only displacement D needs to be
set. The 0/D is as follows:
17 dimensions [0 1 0 0 0 0 0];
18
19 internalField uniform (0 0 0);
20
21 boundaryField
22 {
23 left
24 {
25 type symmetryPlane;
26 }
27 right
28 {
29 type tractionDisplacement;
30 traction uniform ( 10000 0 0 );
31 pressure uniform 0;
32 value uniform (0 0 0);
33 }
34 down
35 {
36 type symmetryPlane;
37 }
38 up
39 {
40 type tractionDisplacement;
41 traction uniform ( 0 0 0 );
42 pressure uniform 0;
43 value uniform (0 0 0);
44 }
45 hole
46 {
47 type tractionDisplacement;
48 traction uniform ( 0 0 0 );
49 pressure uniform 0;
50 value uniform (0 0 0);
51 }
52 frontAndBack
53 {
54 type empty;
55 }
56 }
57
58 // ************************************************************************* //
Firstly, it can be seen that the displacement initial conditions are set to (0, 0, 0) m. The
left and down patches must be both of symmetryPlane type since they are speciﬁed
as such in the mesh description in the constant/polyMesh/boundary ﬁle. Similarly the
frontAndBack patch is declared empty.
The other patches are traction boundary conditions, set by a specialist traction bound-
ary type. The traction boundary conditions are speciﬁed by a linear combination of: (1)
a boundary traction vector under keyword traction; (2) a pressure that produces a trac-
tion normal to the boundary surface that is deﬁned as negative when pointing out of
the surface, under keyword pressure. The up and hole patches are zero traction so the
boundary traction and pressure are set to zero. For the right patch the traction should
be (1e4, 0, 0) Pa and the pressure should be 0 Pa.
2.2.1.2 Mechanical properties
The physical properties for the case are set in the mechanicalProperties dictionary in the
constant directory. For this problem, we need to specify the mechanical properties of
steel given in Table 2.1. In the mechanical properties dictionary, the user must also set
planeStress to yes.
Open∇FOAM-2.2.0
U-50 Tutorials
Property Units Keyword Value
Density kg m−3
rho 7854
Young’s modulus Pa E 2 × 1011
Poisson’s ratio — nu 0.3
Table 2.1: Mechanical properties for steel
2.2.1.3 Thermal properties
The temperature ﬁeld variable T is present in the solidDisplacementFoam solver since the
user may opt to solve a thermal equation that is coupled with the momentum equation
through the thermal stresses that are generated. The user speciﬁes at run time whether
OpenFOAM should solve the thermal equation by the thermalStress switch in the ther-
malProperties dictionary. This dictionary also sets the thermal properties for the case,
e.g. for steel as listed in Table 2.2.
Property Units Keyword Value
Speciﬁc heat capacity Jkg−1
K−1
C 434
Thermal conductivity Wm−1
K−1
k 60.5
Thermal expansion coeﬀ. K−1
alpha 1.1 × 10−5
Table 2.2: Thermal properties for steel
In this case we do not want to solve for the thermal equation. Therefore we must set
the thermalStress keyword entry to no in the thermalProperties dictionary.
2.2.1.4 Control
As before, the information relating to the control of the solution procedure are read in
from the controlDict dictionary. For this case, the startTime is 0 s. The time step is
not important since this is a steady state case; in this situation it is best to set the time
step deltaT to 1 so it simply acts as an iteration counter for the steady-state case. The
endTime, set to 100, then acts as a limit on the number of iterations. The writeInterval
can be set to 20.
The controlDict entries are as follows:
17
18 application solidDisplacementFoam;
19
20 startFrom startTime;
21
22 startTime 0;
23
24 stopAt endTime;
25
26 endTime 100;
27
28 deltaT 1;
29
30 writeControl timeStep;
31
32 writeInterval 20;
33
34 purgeWrite 0;
35
36 writeFormat ascii;
37
38 writePrecision 6;
39
40 writeCompression off;
41
42 timeFormat general;
Open∇FOAM-2.2.0
2.2 Stress analysis of a plate with a hole U-51
43
44 timePrecision 6;
45
46 graphFormat raw;
47
48 runTimeModifiable true;
49
50
51 // ************************************************************************* //
2.2.1.5 Discretisation schemes and linear-solver control
Let us turn our attention to the fvSchemes dictionary. Firstly, the problem we are
analysing is steady-state so the user should select SteadyState for the time derivatives
in timeScheme. This essentially switches oﬀ the time derivative terms. Not all solvers,
especially in ﬂuid dynamics, work for both steady-state and transient problems but solid-
DisplacementFoam does work, since the base algorithm is the same for both types of
simulation.
The momentum equation in linear-elastic stress analysis includes several explicit terms
containing the gradient of displacement. The calculations beneﬁt from accurate and
smooth evaluation of the gradient. Normally, in the ﬁnite volume method the discreti-
sation is based on Gauss’s theorem The Gauss method is suﬃciently accurate for most
purposes but, in this case, the least squares method will be used. The user should there-
fore open the fvSchemes dictionary in the system directory and ensure the leastSquares
method is selected for the grad(U) gradient discretisation scheme in the gradSchemes
sub-dictionary:
17
18 d2dt2Schemes
19 {
20 default steadyState;
21 }
22
23 ddtSchemes
24 {
25 default Euler;
26 }
27
28 gradSchemes
29 {
30 default leastSquares;
31 grad(D) leastSquares;
32 grad(T) leastSquares;
33 }
34
35 divSchemes
36 {
37 default none;
38 div(sigmaD) Gauss linear;
39 }
40
41 laplacianSchemes
42 {
43 default none;
44 laplacian(DD,D) Gauss linear corrected;
45 laplacian(DT,T) Gauss linear corrected;
46 }
47
48 interpolationSchemes
49 {
50 default linear;
51 }
52
53 snGradSchemes
54 {
55 default none;
56 }
57
58 fluxRequired
59 {
60 default no;
61 D yes;
62 T no;
Open∇FOAM-2.2.0
U-52 Tutorials
63 }
64
65
66 // ************************************************************************* //
The fvSolution dictionary in the system directory controls the linear equation solvers and
algorithms used in the solution. The user should ﬁrst look at the solvers sub-dictionary
and notice that the choice of solver for D is GAMG. The solver tolerance should be set to
10−6
for this problem. The solver relative tolerance, denoted by relTol, sets the required
reduction in the residuals within each iteration. It is uneconomical to set a tight (low)
relative tolerance within each iteration since a lot of terms in each equation are explicit
and are updated as part of the segregated iterative procedure. Therefore a reasonable
value for the relative tolerance is 0.01, or possibly even higher, say 0.1, or in some cases
even 0.9 (as in this case).
17
18 solvers
19 {
20 "(D|T)"
21 {
22 solver GAMG;
23 tolerance 1e-06;
24 relTol 0.9;
25 smoother GaussSeidel;
26 cacheAgglomeration true;
27 nCellsInCoarsestLevel 20;
28 agglomerator faceAreaPair;
29 mergeLevels 1;
30 }
31 }
32
33 stressAnalysis
34 {
35 compactNormalStress yes;
36 nCorrectors 1;
37 D 1e-06;
38 }
39
40
41 // ************************************************************************* //
The fvSolution dictionary contains a sub-dictionary, stressAnalysis that contains some con-
trol parameters speciﬁc to the application solver. Firstly there is nCorrectors which
speciﬁes the number of outer loops around the complete system of equations, including
traction boundary conditions within each time step. Since this problem is steady-state,
we are performing a set of iterations towards a converged solution with the ’time step’
acting as an iteration counter. We can therefore set nCorrectors to 1.
The D keyword speciﬁes a convergence tolerance for the outer iteration loop, i.e. sets
a level of initial residual below which solving will cease. It should be set to the desired
solver tolerance speciﬁed earlier, 10−6
for this problem.
2.2.2 Running the code
The user should run the code here in the background from the command line as speciﬁed
below, so he/she can look at convergence information in the log ﬁle afterwards.
cd $FOAM RUN/tutorials/stressAnalysis/solidDisplacementFoam/plateHole
solidDisplacementFoam > log &
The user should check the convergence information by viewing the generated log ﬁle which
shows the number of iterations and the initial and ﬁnal residuals of the displacement in
each direction being solved. The ﬁnal residual should always be less than 0.9 times the
initial residual as this iteration tolerance set. Once both initial residuals have dropped
below the convergence tolerance of 10−6
the run has converged and can be stopped by
killing the batch job.
Open∇FOAM-2.2.0
2.2 Stress analysis of a plate with a hole U-53
2.2.3 Post-processing
Post processing can be performed as in section 2.1.4. The solidDisplacementFoam solver
outputs the stress ﬁeld σ as a symmetric tensor ﬁeld sigma. This is consistent with the
way variables are usually represented in OpenFOAM solvers by the mathematical symbol
by which they are represented; in the case of Greek symbols, the variable is named
phonetically.
For post-processing individual scalar ﬁeld components, σxx, σxy etc., can be generated
by running the foamCalc utility as before in section 2.1.5.7, this time on sigma:
foamCalc components sigma
Components named sigmaxx, sigmaxy etc. are written to time directories of the case.
The σxx stresses can be viewed in paraFoam as shown in Figure 2.18.
0
5
10
15
20
25
30
σxx(kPa)
Figure 2.18: σxx stress ﬁeld in the plate with hole.
We would like to compare the analytical solution of Equation 2.14 to our solution.
We therefore must output a set of data of σxx along the left edge symmetry plane of
our domain. The user may generate the required graph data using the sample utility.
The utility uses a sampleDict dictionary located in the system directory, whose entries are
summarised in Table 6.3. The sample line speciﬁed in sets is set between (0.0, 0.5, 0.25)
and (0.0, 2.0, 0.25), and the ﬁelds are speciﬁed in the fields list:
17
18 interpolationScheme cellPoint;
19
20 setFormat raw;
21
22 sets
23 (
24 leftPatch
25 {
26 type uniform;
27 axis y;
28 start ( 0 0.5 0.25 );
29 end ( 0 2 0.25 );
30 nPoints 100;
31 }
32 );
33
34 fields ( sigmaxx );
35
36
37 // ************************************************************************* //
Open∇FOAM-2.2.0
U-54 Tutorials
0
5
10
15
20
25
30
35
0.6 0.8 1.0 1.2 1.4 1.6 1.8 2.0
Stress(σxx)x=0(kPa)
Distance, y (m)
Numerical prediction Analytical solution
Figure 2.19: Normal stress along the vertical symmetry (σxx)x=0
The user should execute sample as normal. The writeFormat is raw 2 column format.
The data is written into ﬁles within time subdirectories of a sets directory, e.g. the data
at t = 100 s is found within the ﬁle sets/100/leftPatch sigmaxx.xy. In an application such
as GnuPlot, one could type the following at the command prompt would be suﬃcient to
plot both the numerical data and analytical solution:
plot [0.5:2] [0:] 'sets/100/leftPatch sigmaxx.xy',
1e4*(1+(0.125/(x**2))+(0.09375/(x**4)))
An example plot is shown in Figure 2.19.
2.2.4 Exercises
The user may wish to experiment with solidDisplacementFoam by trying the following
exercises:
2.2.4.1 Increasing mesh resolution
Increase the mesh resolution in each of the x and y directions. Use mapFields to map the
ﬁnal coarse mesh results from section 2.2.3 to the initial conditions for the ﬁne mesh.
2.2.4.2 Introducing mesh grading
Grade the mesh so that the cells near the hole are ﬁner than those away from the hole.
Design the mesh so that the ratio of sizes between adjacent cells is no more than 1.1
and so that the ratio of cell sizes between blocks is similar to the ratios within blocks.
Mesh grading is described in section 2.1.6. Again use mapFields to map the ﬁnal coarse
mesh results from section 2.2.3 to the initial conditions for the graded mesh. Compare
the results with those from the analytical solution and previous calculations. Can this
solution be improved upon using the same number of cells with a diﬀerent solution?
Open∇FOAM-2.2.0
2.3 Breaking of a dam U-55
2.2.4.3 Changing the plate size
The analytical solution is for an inﬁnitely large plate with a ﬁnite sized hole in it. There-
fore this solution is not completely accurate for a ﬁnite sized plate. To estimate the error,
increase the plate size while maintaining the hole size at the same value.
2.3 Breaking of a dam
In this tutorial we shall solve a problem of simpliﬁed dam break in 2 dimensions using
the interFoam.The feature of the problem is a transient ﬂow of two ﬂuids separated by
a sharp interface, or free surface. The two-phase algorithm in interFoam is based on the
volume of ﬂuid (VOF) method in which a specie transport equation is used to determine
the relative volume fraction of the two phases, or phase fraction α1, in each computational
cell. Physical properties are calculated as weighted averages based on this fraction. The
nature of the VOF method means that an interface between the species is not explicitly
computed, but rather emerges as a property of the phase fraction ﬁeld. Since the phase
fraction can have any value between 0 and 1, the interface is never sharply deﬁned, but
occupies a volume around the region where a sharp interface should exist.
The test setup consists of a column of water at rest located behind a membrane on
the left side of a tank. At time t = 0 s, the membrane is removed and the column of
water collapses. During the collapse, the water impacts an obstacle at the bottom of the
tank and creates a complicated ﬂow structure, including several captured pockets of air.
The geometry and the initial setup is shown in Figure 2.20.
0.584 m
0.048 m
0.024 m
0.584 m
0.292 m
0.1459 m0.1461 m
water column
Figure 2.20: Geometry of the dam break.
2.3.1 Mesh generation
The user should go to the damBreak case in their $FOAM RUN/tutorials/multiphase/inter-
Foam/laminar directory. Generate the mesh running blockMesh as described previously.
The damBreak mesh consist of 5 blocks; the blockMeshDict entries are given below.
Open∇FOAM-2.2.0
U-56 Tutorials
17 convertToMeters 0.146;
18
19 vertices
20 (
21 (0 0 0)
22 (2 0 0)
23 (2.16438 0 0)
24 (4 0 0)
25 (0 0.32876 0)
26 (2 0.32876 0)
27 (2.16438 0.32876 0)
28 (4 0.32876 0)
29 (0 4 0)
30 (2 4 0)
31 (2.16438 4 0)
32 (4 4 0)
33 (0 0 0.1)
34 (2 0 0.1)
35 (2.16438 0 0.1)
36 (4 0 0.1)
37 (0 0.32876 0.1)
38 (2 0.32876 0.1)
39 (2.16438 0.32876 0.1)
40 (4 0.32876 0.1)
41 (0 4 0.1)
42 (2 4 0.1)
43 (2.16438 4 0.1)
44 (4 4 0.1)
45 );
46
47 blocks
48 (
49 hex (0 1 5 4 12 13 17 16) (23 8 1) simpleGrading (1 1 1)
50 hex (2 3 7 6 14 15 19 18) (19 8 1) simpleGrading (1 1 1)
51 hex (4 5 9 8 16 17 21 20) (23 42 1) simpleGrading (1 1 1)
52 hex (5 6 10 9 17 18 22 21) (4 42 1) simpleGrading (1 1 1)
53 hex (6 7 11 10 18 19 23 22) (19 42 1) simpleGrading (1 1 1)
54 );
55
56 edges
57 (
58 );
59
60 boundary
61 (
62 leftWall
63 {
64 type wall;
65 faces
66 (
67 (0 12 16 4)
68 (4 16 20 8)
69 );
70 }
71 rightWall
72 {
73 type wall;
74 faces
75 (
76 (7 19 15 3)
77 (11 23 19 7)
78 );
79 }
80 lowerWall
81 {
82 type wall;
83 faces
84 (
85 (0 1 13 12)
86 (1 5 17 13)
87 (5 6 18 17)
88 (2 14 18 6)
89 (2 3 15 14)
90 );
91 }
92 atmosphere
93 {
94 type patch;
95 faces
96 (
97 (8 20 21 9)
98 (9 21 22 10)
99 (10 22 23 11)
100 );
101 }
Open∇FOAM-2.2.0
2.3 Breaking of a dam U-57
102 );
103
104 mergePatchPairs
105 (
106 );
107
108 // ************************************************************************* //
2.3.2 Boundary conditions
The user can examine the boundary geometry generated by blockMesh by viewing the
boundary ﬁle in the constant/polyMesh directory. The ﬁle contains a list of 5 boundary
patches: leftWall, rightWall, lowerWall, atmosphere and defaultFaces. The user
should notice the type of the patches. The atmosphere is a standard patch, i.e. has no
special attributes, merely an entity on which boundary conditions can be speciﬁed. The
defaultFaces patch is empty since the patch normal is in the direction we will not solve
in this 2D case. The leftWall, rightWall and lowerWall patches are each a wall. Like
the plain patch, the wall type contains no geometric or topological information about the
mesh and only diﬀers from the plain patch in that it identiﬁes the patch as a wall, should
an application need to know, e.g. to apply special wall surface modelling.
A good example is that the interFoam solver includes modelling of surface tension at
the contact point between the interface and wall surface. The models are applied by
specifying the alphaContactAngle boundary condition on the alpha1 (α1) ﬁeld. With it,
the user must specify the following: a static contact angle, theta0 θ0; leading and trailing
edge dynamic contact angles, thetaA θA and thetaR θR respectively; and a velocity scaling
function for dynamic contact angle, uTheta.
In this tutorial we would like to ignore surface tension eﬀects between the wall and
interface. We can do this by setting the static contact angle, θ0 = 90◦
and the velocity
scaling function to 0. However, the simpler option which we shall choose here is to specify
a zeroGradient type on alpha1, rather than use the alphaContactAngle boundary condition.
The top boundary is free to the atmosphere so needs to permit both outﬂow and inﬂow
according to the internal ﬂow. We therefore use a combination of boundary conditions
for pressure and velocity that does this while maintaining stability. They are:
• totalPressure which is a ﬁxedValue condition calculated from speciﬁed total pressure
p0 and local velocity U;
• pressureInletOutletVelocity, which applies zeroGradient on all components, except
where there is inﬂow, in which case a ﬁxedValue condition is applied to the tangential
component;
• inletOutlet, which is a zeroGradient condition when ﬂow outwards, ﬁxedValue when
ﬂow is inwards.
At all wall boundaries, the buoyantPressure boundary condition is applied to the pressure
ﬁeld, which calculates the normal gradient from the local density gradient.
The defaultFaces patch representing the front and back planes of the 2D problem,
is, as usual, an empty type.
2.3.3 Setting initial ﬁeld
Unlike the previous cases, we shall now specify a non-uniform initial condition for the
phase fraction α1 where
α1 =
1 for the liquid phase
0 for the gas phase
(2.15)
Open∇FOAM-2.2.0
U-58 Tutorials
This will be done by running the setFields utility. It requires a setFieldsDict dictionary,
located in the system directory, whose entries for this case are shown below.
17
18 defaultFieldValues
19 (
20 volScalarFieldValue alpha1 0
21 );
22
23 regions
24 (
25 boxToCell
26 {
27 box (0 0 -1) (0.1461 0.292 1);
28 fieldValues
29 (
30 volScalarFieldValue alpha1 1
31 );
32 }
33 );
34
35
36 // ************************************************************************* //
The defaultFieldValues sets the default value of the ﬁelds, i.e. the value the ﬁeld
takes unless speciﬁed otherwise in the regions sub-dictionary. That sub-dictionary con-
tains a list of subdictionaries containing fieldValues that override the defaults in a
speciﬁed region. The region is expressed in terms of a topoSetSource that creates a set
of points, cells or faces based on some topological constraint. Here, boxToCell creates
a bounding box within a vector minimum and maximum to deﬁne the set of cells of the
liquid region. The phase fraction α1 is deﬁned as 1 in this region.
The setFields utility reads ﬁelds from ﬁle and, after re-calculating those ﬁelds, will
write them back to ﬁle. Because the ﬁles are then overridden, it is recommended that a
backup is made before setFields is executed. In the damBreak tutorial, the alpha1 ﬁeld is
initially stored as a backup only, named alpha1.org. Before running setFields, the user
ﬁrst needs to copy alpha1.org to alpha1, e.g. by typing:
cp 0/alpha1.org 0/alpha1
The user should then execute setFields as any other utility is executed. Using paraFoam,
check that the initial alpha1 ﬁeld corresponds to the desired distribution as in Figure 2.21.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
Figure 2.21: Initial conditions for phase fraction alpha1.
Open∇FOAM-2.2.0
2.3 Breaking of a dam U-59
2.3.4 Fluid properties
Let us examine the transportProperties ﬁle in the constant directory. The dictionary
contains the material properties for each ﬂuid, separated into two subdictionaries phase1
and phase2. The transport model for each phase is selected by the transportModel
keyword. The user should select Newtonian in which case the kinematic viscosity is
single valued and speciﬁed under the keyword nu. The viscosity parameters for the other
models, e.g.CrossPowerLaw, are speciﬁed within subdictionaries with the generic name
<model>Coeﬀs, i.e.CrossPowerLawCoeﬀs in this example. The density is speciﬁed under
the keyword rho.
The surface tension between the two phases is speciﬁed under the keyword sigma.
The values used in this tutorial are listed in Table 2.3.
phase1 properties
Kinematic viscosity m2
s−1
nu 1.0 × 10−6
Density kg m−3
rho 1.0 × 103
phase2 properties
Kinematic viscosity m2
s−1
nu 1.48 × 10−5
Density kg m−3
rho 1.0
Properties of both phases
Surface tension N m−1
sigma 0.07
Table 2.3: Fluid properties for the damBreak tutorial
Gravitational acceleration is uniform across the domain and is speciﬁed in a ﬁle named
g in the constant directory. Unlike a normal ﬁeld ﬁle, e.g. U and p, g is a uniformDimen-
sionedVectorField and so simply contains a set of dimensions and a value that represents
(0, 9.81, 0) m s−2
for this tutorial:
17
18 dimensions [0 1 -2 0 0 0 0];
19 value ( 0 -9.81 0 );
20
21
22 // ************************************************************************* //
2.3.5 Turbulence modelling
As in the cavity example, the choice of turbulence modelling method is selectable at run-
time through the simulationType keyword in turbulenceProperties dictionary. In this
example, we wish to run without turbulence modelling so we set laminar:
17
18 simulationType laminar;
19
20
21 // ************************************************************************* //
2.3.6 Time step control
Time step control is an important issue in free surface tracking since the surface-tracking
algorithm is considerably more sensitive to the Courant number Co than in standard ﬂuid
ﬂow calculations. Ideally, we should not exceed an upper limit Co ≈ 0.5 in the region
of the interface. In some cases, where the propagation velocity is easy to predict, the
Open∇FOAM-2.2.0
U-60 Tutorials
user should specify a ﬁxed time-step to satisfy the Co criterion. For more complex cases,
this is considerably more diﬃcult. interFoam therefore oﬀers automatic adjustment of the
time step as standard in the controlDict. The user should specify adjustTimeStep to be
on and the the maximum Co for the phase ﬁelds, maxAlphaCo, and other ﬁelds, maxCo,
to be 0.5. The upper limit on time step maxDeltaT can be set to a value that will not be
exceeded in this simulation, e.g. 1.0.
By using automatic time step control, the steps themselves are never rounded to a
convenient value. Consequently if we request that OpenFOAM saves results at a ﬁxed
number of time step intervals, the times at which results are saved are somewhat arbitrary.
However even with automatic time step adjustment, OpenFOAM allows the user to specify
that results are written at ﬁxed times; in this case OpenFOAM forces the automatic time
stepping procedure to adjust time steps so that it ‘hits’ on the exact times speciﬁed for
write output. The user selects this with the adjustableRunTime option for writeControl
in the controlDict dictionary. The controlDict dictionary entries should be:
17
18 application interFoam;
19
20 startFrom startTime;
21
22 startTime 0;
23
24 stopAt endTime;
25
26 endTime 1;
27
28 deltaT 0.001;
29
30 writeControl adjustableRunTime;
31
32 writeInterval 0.05;
33
34 purgeWrite 0;
35
36 writeFormat ascii;
37
38 writePrecision 6;
39
40 writeCompression uncompressed;
41
42 timeFormat general;
43
44 timePrecision 6;
45
46 runTimeModifiable yes;
47
48 adjustTimeStep yes;
49
50 maxCo 0.5;
51 maxAlphaCo 0.5;
52
53 maxDeltaT 1;
54
55
56 // ************************************************************************* //
2.3.7 Discretisation schemes
The interFoam solver uses the multidimensional universal limiter for explicit solution
(MULES) method, created by OpenCFD, to maintain boundedness of the phase fraction
independent of underlying numerical scheme, mesh structure, etc. The choice of schemes
for convection are therfore not restricted to those that are strongly stable or bounded,
e.g. upwind diﬀerencing.
The convection schemes settings are made in the divSchemes sub-dictionary of the
fvSchemes dictionary. In this example, the convection term in the momentum equation
(∇ • (ρUU)), denoted by the div(rho*phi,U) keyword, uses Gauss limitedLinearV
1.0 to produce good accuracy. The limited linear schemes require a coeﬃcient φ as
described in section 4.4.1. Here, we have opted for best stability with φ = 1.0. The
Open∇FOAM-2.2.0
2.3 Breaking of a dam U-61
∇ • (Uα1) term, represented by the div(phi,alpha) keyword uses the vanLeer scheme.
The ∇ • (Urbα1) term, represented by the div(phirb,alpha) keyword, can similarly use
the vanLeer scheme, but generally produces smoother interfaces using the specialised
interfaceCompression scheme.
The other discretised terms use commonly employed schemes so that the fvSchemes
dictionary entries should therefore be:
17
18 ddtSchemes
19 {
20 default Euler;
21 }
22
23 gradSchemes
24 {
25 default Gauss linear;
26 }
27
28 divSchemes
29 {
30 div(rho*phi,U) Gauss limitedLinearV 1;
31 div(phi,alpha) Gauss vanLeer;
32 div(phirb,alpha) Gauss interfaceCompression;
33 div((muEff*dev(T(grad(U))))) Gauss linear;
34 }
35
36 laplacianSchemes
37 {
38 default Gauss linear corrected;
39 }
40
41 interpolationSchemes
42 {
43 default linear;
44 }
45
46 snGradSchemes
47 {
48 default corrected;
49 }
50
51 fluxRequired
52 {
53 default no;
54 p_rgh;
55 pcorr;
56 alpha1;
57 }
58
59
60 // ************************************************************************* //
2.3.8 Linear-solver control
In the fvSolution, the PISO sub-dictionary contains elements that are speciﬁc to interFoam.
There are the usual correctors to the momentum equation but also correctors to a PISO
loop around the α1 phase equation. Of particular interest are the nAlphaSubCycles and
cAlpha keywords. nAlphaSubCycles represents the number of sub-cycles within the α1
equation; sub-cycles are additional solutions to an equation within a given time step. It
is used to enable the solution to be stable without reducing the time step and vastly
increasing the solution time. Here we specify 2 sub-cycles, which means that the α1
equation is solved in 2× half length time steps within each actual time step.
The cAlpha keyword is a factor that controls the compression of the interface where: 0
corresponds to no compression; 1 corresponds to conservative compression; and, anything
larger than 1, relates to enhanced compression of the interface. We generally recommend
a value of 1.0 which is employed in this example.
Open∇FOAM-2.2.0
U-62 Tutorials
2.3.9 Running the code
Running of the code has been described in detail in previous tutorials. Try the following,
that uses tee, a command that enables output to be written to both standard output and
ﬁles:
cd $FOAM RUN/tutorials/multiphase/interFoam/laminar/damBreak
interFoam | tee log
The code will now be run interactively, with a copy of output stored in the log ﬁle.
2.3.10 Post-processing
Post-processing of the results can now be done in the usual way. The user can monitor
the development of the phase fraction alpha1 in time, e.g. see Figure 2.22.
2.3.11 Running in parallel
The results from the previous example are generated using a fairly coarse mesh. We now
wish to increase the mesh resolution and re-run the case. The new case will typically
take a few hours to run with a single processor so, should the user have access to multiple
processors, we can demonstrate the parallel processing capability of OpenFOAM.
The user should ﬁrst make a copy of the damBreak case, e.g. by
cd $FOAM RUN/tutorials/multiphase/interFoam/laminar
mkdir damBreakFine
cp -r damBreak/0 damBreakFine
cp -r damBreak/system damBreakFine
cp -r damBreak/constant damBreakFine
Enter the new case directory and change the blocks description in the blockMeshDict
dictionary to
blocks
(
hex (0 1 5 4 12 13 17 16) (46 10 1) simpleGrading (1 1 1)
hex (2 3 7 6 14 15 19 18) (40 10 1) simpleGrading (1 1 1)
hex (4 5 9 8 16 17 21 20) (46 76 1) simpleGrading (1 2 1)
hex (5 6 10 9 17 18 22 21) (4 76 1) simpleGrading (1 2 1)
hex (6 7 11 10 18 19 23 22) (40 76 1) simpleGrading (1 2 1)
);
Here, the entry is presented as printed from the blockMeshDict ﬁle; in short the user must
change the mesh densities, e.g. the 46 10 1 entry, and some of the mesh grading entries
to 1 2 1. Once the dictionary is correct, generate the mesh.
As the mesh has now changed from the damBreak example, the user must re-initialise
the phase ﬁeld alpha1 in the 0 time directory since it contains a number of elements that
is inconsistent with the new mesh. Note that there is no need to change the U and p rgh
ﬁelds since they are speciﬁed as uniform which is independent of the number of elements
in the ﬁeld. We wish to initialise the ﬁeld with a sharp interface, i.e. it elements would
have α1 = 1 or α1 = 0. Updating the ﬁeld with mapFields may produce interpolated
Open∇FOAM-2.2.0
2.3 Breaking of a dam U-63
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
(a) At t = 0.25 s.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
(b) At t = 0.50 s.
Figure 2.22: Snapshots of phase α1.
Open∇FOAM-2.2.0
U-64 Tutorials
values 0 < α1 < 1 at the interface, so it is better to rerun the setFields utility. There is a
backup copy of the initial uniform α1 ﬁeld named 0/alpha1.org that the user should copy
to 0/alpha1 before running setFields:
cd $FOAM RUN/tutorials/multiphase/interFoam/laminar/damBreakFine
cp -r 0/alpha1.org 0/alpha1
setFields
The method of parallel computing used by OpenFOAM is known as domain de-
composition, in which the geometry and associated ﬁelds are broken into pieces and
allocated to separate processors for solution. The ﬁrst step required to run a parallel
case is therefore to decompose the domain using the decomposePar utility. There is a
dictionary associated with decomposePar named decomposeParDict which is located in
the system directory of the tutorial case; also, like with many utilities, a default dic-
tionary can be found in the directory of the source code of the speciﬁc utility, i.e. in
$FOAM UTILITIES/parallelProcessing/decomposePar for this case.
The ﬁrst entry is numberOfSubdomains which speciﬁes the number of subdomains into
which the case will be decomposed, usually corresponding to the number of processors
available for the case.
In this tutorial, the method of decomposition should be simple and the corresponding
simpleCoeffs should be edited according to the following criteria. The domain is split
into pieces, or subdomains, in the x, y and z directions, the number of subdomains in
each direction being given by the vector n. As this geometry is 2 dimensional, the 3rd
direction, z, cannot be split, hence nz must equal 1. The nx and ny components of n
split the domain in the x and y directions and must be speciﬁed so that the number
of subdomains speciﬁed by nx and ny equals the speciﬁed numberOfSubdomains, i.e.
nxny = numberOfSubdomains. It is beneﬁcial to keep the number of cell faces adjoining
the subdomains to a minimum so, for a square geometry, it is best to keep the split
between the x and y directions should be fairly even. The delta keyword should be set
to 0.001.
For example, let us assume we wish to run on 4 processors. We would set number-
OfSubdomains to 4 and n = (2, 2, 1). When running decomposePar, we can see from the
screen messages that the decomposition is distributed fairly even between the processors.
The user should consult section 3.4 for details of how to run a case in parallel; in
this tutorial we merely present an example of running in parallel. We use the openMPI
implementation of the standard message-passing interface (MPI). As a test here, the user
can run in parallel on a single node, the local host only, by typing:
mpirun -np 4 interFoam -parallel > log &
The user may run on more nodes over a network by creating a ﬁle that lists the host
names of the machines on which the case is to be run as described in section 3.4.2. The
case should run in the background and the user can follow its progress by monitoring the
log ﬁle as usual.
2.3.12 Post-processing a case run in parallel
Once the case has completed running, the decomposed ﬁelds and mesh must be reassem-
bled for post-processing using the reconstructPar utility. Simply execute it from the com-
mand line. The results from the ﬁne mesh are shown in Figure 2.24. The user can see
that the resolution of interface has improved signiﬁcantly compared to the coarse mesh.
Open∇FOAM-2.2.0
2.3 Breaking of a dam U-65
Figure 2.23: Mesh of processor 2 in parallel processed case.
The user may also post-process a segment of the decomposed domain individually by
simply treating the individual processor directory as a case in its own right. For example
if the user starts paraFoam by
paraFoam -case processor1
then processor1 will appear as a case module in ParaView. Figure 2.23 shows the mesh
from processor 1 following the decomposition of the domain using the simple method.
Open∇FOAM-2.2.0
U-66 Tutorials
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
(a) At t = 0.25 s.
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
Phase fraction, α1
(b) At t = 0.50 s.
Figure 2.24: Snapshots of phase α1 with reﬁned mesh.
Open∇FOAM-2.2.0
Chapter 3
Applications and libraries
We should reiterate from the outset that OpenFOAM is a C++ library used primarily to
create executables, known as applications. OpenFOAM is distributed with a large set of
precompiled applications but users also have the freedom to create their own or modify
existing ones. Applications are split into two main categories:
solvers that are each designed to solve a speciﬁc problem in computational continuum
mechanics;
utilities that perform simple pre-and post-processing tasks, mainly involving data ma-
nipulation and algebraic calculations.
OpenFOAM is divided into a set of precompiled libraries that are dynamically linked
during compilation of the solvers and utilities. Libraries such as those for physical models
are supplied as source code so that users may conveniently add their own models to the
libraries. This chapter gives an overview of solvers, utilities and libraries, their creation,
modiﬁcation, compilation and execution.
3.1 The programming language of OpenFOAM
In order to understand the way in which the OpenFOAM library works, some background
knowledge of C++, the base language of OpenFOAM, is required; the necessary infor-
mation will be presented in this chapter. Before doing so, it is worthwhile addressing the
concept of language in general terms to explain some of the ideas behind object-oriented
programming and our choice of C++ as the main programming language of OpenFOAM.
3.1.1 Language in general
The success of verbal language and mathematics is based on eﬃciency, especially in
expressing abstract concepts. For example, in ﬂuid ﬂow, we use the term “velocity ﬁeld”,
which has meaning without any reference to the nature of the ﬂow or any speciﬁc velocity
data. The term encapsulates the idea of movement with direction and magnitude and
relates to other physical properties. In mathematics, we can represent velocity ﬁeld by
a single symbol, e.g. U, and express certain concepts using symbols, e.g. “the ﬁeld of
velocity magnitude” by |U|. The advantage of mathematics over verbal language is its
greater eﬃciency, making it possible to express complex concepts with extreme clarity.
The problems that we wish to solve in continuum mechanics are not presented in
terms of intrinsic entities, or types, known to a computer, e.g. bits, bytes, integers. They
are usually presented ﬁrst in verbal language, then as partial diﬀerential equations in 3
U-68 Applications and libraries
dimensions of space and time. The equations contain the following concepts: scalars,
vectors, tensors, and ﬁelds thereof; tensor algebra; tensor calculus; dimensional units.
The solution to these equations involves discretisation procedures, matrices, solvers, and
solution algorithms.
3.1.2 Object-orientation and C++
Progamming languages that are object-oriented, such as C++, provide the mechanism
— classes — to declare types and associated operations that are part of the verbal and
mathematical languages used in science and engineering. Our velocity ﬁeld introduced
earlier can be represented in programming code by the symbol U and “the ﬁeld of velocity
magnitude” can be mag(U). The velocity is a vector ﬁeld for which there should exist,
in an object-oriented code, a vectorField class. The velocity ﬁeld U would then be an
instance, or object, of the vectorField class; hence the term object-oriented.
The clarity of having objects in programming that represent physical objects and
abstract entities should not be underestimated. The class structure concentrates code
development to contained regions of the code, i.e. the classes themselves, thereby making
the code easier to manage. New classes can be derived or inherit properties from other
classes, e.g. the vectorField can be derived from a vector class and a Field class. C++
provides the mechanism of template classes such that the template class Field<Type> can
represent a ﬁeld of any <Type>, e.g.scalar, vector, tensor. The general features of the
template class are passed on to any class created from the template. Templating and
inheritance reduce duplication of code and create class hierarchies that impose an overall
structure on the code.
3.1.3 Equation representation
A central theme of the OpenFOAM design is that the solver applications, written using the
OpenFOAM classes, have a syntax that closely resembles the partial diﬀerential equations
being solved. For example the equation
∂ρU
∂t
+ ∇ • φU − ∇ • µ∇U = −∇p
is represented by the code
solve
(
fvm::ddt(rho, U)
+ fvm::div(phi, U)
- fvm::laplacian(mu, U)
==
- fvc::grad(p)
);
This and other requirements demand that the principal programming language of Open-
FOAM has object-oriented features such as inheritance, template classes, virtual functions
and operator overloading. These features are not available in many languages that pur-
port to be object-orientated but actually have very limited object-orientated capability,
such as FORTRAN-90. C++, however, possesses all these features while having the ad-
ditional advantage that it is widely used with a standard speciﬁcation so that reliable
compilers are available that produce eﬃcient executables. It is therefore the primary
language of OpenFOAM.
Open∇FOAM-2.2.0
3.2 Compiling applications and libraries U-69
3.1.4 Solver codes
Solver codes are largely procedural since they are a close representation of solution algo-
rithms and equations, which are themselves procedural in nature. Users do not need a
deep knowledge of object-orientation and C++ programming to write a solver but should
know the principles behind object-orientation and classes, and to have a basic knowledge
of some C++ code syntax. An understanding of the underlying equations, models and
solution method and algorithms is far more important.
There is often little need for a user to immerse themselves in the code of any of the
OpenFOAM classes. The essence of object-orientation is that the user should not have
to; merely the knowledge of the class’ existence and its functionality are suﬃcient to use
the class. A description of each class, its functions etc. is supplied with the OpenFOAM
distribution in HTML documentation generated with Doxygen at $WM PROJECT DIR/-
doc/Doxygen/html/index.html.
3.2 Compiling applications and libraries
Compilation is an integral part of application development that requires careful man-
agement since every piece of code requires its own set instructions to access dependent
components of the OpenFOAM library. In UNIX/Linux systems these instructions are of-
ten organised and delivered to the compiler using the standard UNIXmake utility. Open-
FOAM, however, is supplied with the wmake compilation script that is based on make but
is considerably more versatile and easier to use; wmake can, in fact, be used on any code,
not simply the OpenFOAM library. To understand the compilation process, we ﬁrst need
to explain certain aspects of C++ and its ﬁle structure, shown schematically in Figure 3.1.
A class is deﬁned through a set of instructions such as object construction, data storage
and class member functions. The ﬁle containing the class deﬁnition takes a .C extension,
e.g. a class nc would be written in the ﬁle nc.C. This ﬁle can be compiled independently
of other code into a binary executable library ﬁle known as a shared object library with
the .so ﬁle extension, i.e.nc.so. When compiling a piece of code, say newApp.C, that uses
the nc class, nc.C need not be recompiled, rather newApp.C calls nc.so at runtime. This
is known as dynamic linking.
int main()
...
...
return(0);
{
}
nc.so
Library
option-I#include "nc.H"
Main code
Code...
Compiled
nc.H
nc.C
#include "nc.H"
nc class
Definition...
Compiled
Executable
Header ﬁle
Linked
option-l
newApp.C
newApp
Figure 3.1: Header ﬁles, source ﬁles, compilation and linking
Open∇FOAM-2.2.0
U-70 Applications and libraries
3.2.1 Header .H ﬁles
As a means of checking errors, the piece of code being compiled must know that the classes
it uses and the operations they perform actually exist. Therefore each class requires a
class declaration, contained in a header ﬁle with a .H ﬁle extension, e.g.nc.H, that includes
the names of the class and its functions. This ﬁle is included at the beginning of any piece
of code using the class, including the class declaration code itself. Any piece of .C code
can resource any number of classes and must begin with all the .H ﬁles required to declare
these classes. The classes in turn can resource other classes and begin with the relevant
.H ﬁles. By searching recursively down the class hierarchy we can produce a complete list
of header ﬁles for all the classes on which the top level .C code ultimately depends; these
.H ﬁles are known as the dependencies. With a dependency list, a compiler can check
whether the source ﬁles have been updated since their last compilation and selectively
compile only those that need to be.
Header ﬁles are included in the code using # include statements, e.g.
# include "otherHeader.H";
causes the compiler to suspend reading from the current ﬁle to read the ﬁle speciﬁed.
Any self-contained piece of code can be put into a header ﬁle and included at the rel-
evant location in the main code in order to improve code readability. For example, in
most OpenFOAM applications the code for creating ﬁelds and reading ﬁeld input data is
included in a ﬁle createFields.H which is called at the beginning of the code. In this way,
header ﬁles are not solely used as class declarations. It is wmake that performs the task
of maintaining ﬁle dependency lists amongst other functions listed below.
• Automatic generation and maintenance of ﬁle dependency lists, i.e. lists of ﬁles
which are included in the source ﬁles and hence on which they depend.
• Multi-platform compilation and linkage, handled through appropriate directory
structure.
• Multi-language compilation and linkage, e.g. C, C++, Java.
• Multi-option compilation and linkage, e.g. debug, optimised, parallel and proﬁling.
• Support for source code generation programs, e.g. lex, yacc, IDL, MOC.
• Simple syntax for source ﬁle lists.
• Automatic creation of source ﬁle lists for new codes.
• Simple handling of multiple shared or static libraries.
• Extensible to new machine types.
• Extremely portable, works on any machine with: make; sh, ksh or csh; lex, cc.
• Has been tested on Apollo, SUN, SGI, HP (HPUX), Compaq (DEC), IBM (AIX),
Cray, Ardent, Stardent, PC Linux, PPC Linux, NEC, SX4, Fujitsu VP1000.
Open∇FOAM-2.2.0
3.2 Compiling applications and libraries U-71
3.2.2 Compiling with wmake
OpenFOAM applications are organised using a standard convention that the source code
of each application is placed in a directory whose name is that of the application. The
top level source ﬁle takes the application name with the .C extension. For example, the
source code for an application called newApp would reside is a directory newApp and the
top level ﬁle would be newApp.C as shown in Figure 3.2. The directory must also contain
newApp
newApp.C
otherHeader.H
Make
ﬁles
options
Figure 3.2: Directory structure for an application
a Make subdirectory containing 2 ﬁles, options and ﬁles, that are described in the following
sections.
3.2.2.1 Including headers
The compiler searches for the included header ﬁles in the following order, speciﬁed with
the -I option in wmake:
1. the $WM PROJECT DIR/src/OpenFOAM/lnInclude directory;
2. a local lnInclude directory, i.e.newApp/lnInclude;
3. the local directory, i.e.newApp;
4. platform dependent paths set in ﬁles in the $WM PROJECT DIR/wmake/rules/-
$WM ARCH/ directory, e.g./usr/X11/include and $(MPICH ARCH PATH)/include;
5. other directories speciﬁed explicitly in the Make/options ﬁle with the -I option.
The Make/options ﬁle contains the full directory paths to locate header ﬁles using the
syntax:
EXE INC = \
-I<directoryPath1> \
-I<directoryPath2> \
... \
-I<directoryPathN>
Notice ﬁrst that the directory names are preceeded by the -I ﬂag and that the syntax
uses the \ to continue the EXE INC across several lines, with no \ after the ﬁnal entry.
Open∇FOAM-2.2.0
U-72 Applications and libraries
3.2.2.2 Linking to libraries
The compiler links to shared object library ﬁles in the following directory paths, speciﬁed
with the -L option in wmake:
1. the $FOAM LIBBIN directory;
2. platform dependent paths set in ﬁles in the $WM DIR/rules/$WM ARCH/ directory,
e.g./usr/X11/lib and $(MPICH ARCH PATH)/lib;
3. other directories speciﬁed in the Make/options ﬁle.
The actual library ﬁles to be linked must be speciﬁed using the -l option and removing
the lib preﬁx and .so extension from the library ﬁle name, e.g.libnew.so is included with
the ﬂag -lnew. By default, wmake loads the following libraries:
1. the libOpenFOAM.so library from the $FOAM LIBBIN directory;
2. platform dependent libraries speciﬁed in set in ﬁles in the $WM DIR/rules/$WM ARCH/
directory, e.g.libm.so from /usr/X11/lib and liblam.so from $(LAM ARCH PATH)/lib;
3. other libraries speciﬁed in the Make/options ﬁle.
The Make/options ﬁle contains the full directory paths and library names using the syntax:
EXE LIBS = \
-L<libraryPath1> \
-L<libraryPath2> \
... \
-L<libraryPathN> \
-l<library1> \
-l<library2> \
... \
-l<libraryN>
Let us reiterate that the directory paths are preceeded by the -L ﬂag, the library names
are preceeded by the -l ﬂag.
3.2.2.3 Source ﬁles to be compiled
The compiler requires a list of .C source ﬁles that must be compiled. The list must contain
the main .C ﬁle but also any other source ﬁles that are created for the speciﬁc application
but are not included in a class library. For example, users may create a new class or
some new functionality to an existing class for a particular application. The full list of
.C source ﬁles must be included in the Make/ﬁles ﬁle. As might be expected, for many
applications the list only includes the name of the main .C ﬁle, e.g.newApp.C in the case
of our earlier example.
The Make/ﬁles ﬁle also includes a full path and name of the compiled executable,
speciﬁed by the EXE = syntax. Standard convention stipulates the name is that of the ap-
plication, i.e.newApp in our example. The OpenFOAM release oﬀers two useful choices for
path: standard release applications are stored in $FOAM APPBIN; applications developed
by the user are stored in $FOAM USER APPBIN.
If the user is developing their own applications, we recommend they create an appli-
cations subdirectory in their $WM PROJECT USER DIR directory containing the source
Open∇FOAM-2.2.0
3.2 Compiling applications and libraries U-73
code for personal OpenFOAM applications. As with standard applications, the source
code for each OpenFOAM application should be stored within its own directory. The
only diﬀerence between a user application and one from the standard release is that the
Make/ﬁles ﬁle should specify that the user’s executables are written into their $FOAM -
USER APPBIN directory. The Make/ﬁles ﬁle for our example would appear as follows:
newApp.C
EXE = $(FOAM_USER_APPBIN)/newApp
3.2.2.4 Running wmake
The wmake script is executed by typing:
wmake <optionalArguments> <optionalDirectory>
The <optionalDirectory> is the directory path of the application that is being com-
piled. Typically, wmake is executed from within the directory of the application being
compiled, in which case <optionalDirectory> can be omitted.
If a user wishes to build an application executable, then no <optionalArguments>
are required. However <optionalArguments> may be speciﬁed for building libraries etc.
as described in Table 3.1.
Argument Type of compilation
lib Build a statically-linked library
libso Build a dynamically-linked library
libo Build a statically-linked object ﬁle library
jar Build a JAVA archive
exe Build an application independent of the speciﬁed project
Table 3.1: Optional compilation arguments to wmake.
3.2.2.5 wmake environment variables
For information, the environment variable settings used by wmake are listed in Table 3.2.
3.2.3 Removing dependency lists: wclean and rmdepall
On execution, wmake builds a dependency list ﬁle with a .dep ﬁle extension, e.g.newApp.dep
in our example, and a list of ﬁles in a Make/$WM OPTIONS directory. If the user wishes
to remove these ﬁles, perhaps after making code changes, the user can run the wclean
script by typing:
wclean <optionalArguments> <optionalDirectory>
Again, the <optionalDirectory> is a path to the directory of the application that is
being compiled. Typically, wclean is executed from within the directory of the application,
in which case the path can be omitted.
Open∇FOAM-2.2.0
U-74 Applications and libraries
Main paths
$WM PROJECT INST DIR Full path to installation directory,
e.g.$HOME/OpenFOAM
$WM PROJECT Name of the project being compiled: OpenFOAM
$WM PROJECT VERSION Version of the project being compiled: 2.2.0
$WM PROJECT DIR Full path to locate binary executables of OpenFOAM
release, e.g.$HOME/OpenFOAM/OpenFOAM-2.2.0
$WM PROJECT USER DIR Full path to locate binary executables of the user
e.g.$HOME/OpenFOAM/${USER}-2.2.0
Other paths/settings
$WM ARCH Machine architecture: Linux, SunOS
$WM ARCH OPTION 32 or 64 bit architecture
$WM COMPILER Compiler being used: Gcc43 - gcc 4.4.3, ICC - Intel
$WM COMPILER DIR Compiler installation directory
$WM COMPILER BIN Compiler installation binaries $WM COMPILER BIN/bin
$WM COMPILER LIB Compiler installation libraries $WM COMPILER BIN/lib
$WM COMPILE OPTION Compilation option: Debug - debugging, Opt optimisa-
tion.
$WM DIR Full path of the wmake directory
$WM MPLIB Parallel communications library: LAM, MPI, MPICH, PVM
$WM OPTIONS = $WM ARCH$WM COMPILER...
...$WM COMPILE OPTION$WM MPLIB
e.g.linuxGcc3OptMPICH
$WM PRECISION OPTION Precision of the compiled binares, SP, single precision or
DP, double precision
Table 3.2: Environment variable settings for wmake.
If a user wishes to remove the dependency ﬁles and ﬁles from the Make directory, then
no <optionalArguments> are required. However if lib is speciﬁed in <optionalArguments>
a local lnInclude directory will be deleted also.
An additional script, rmdepall removes all dependency .dep ﬁles recursively down the
directory tree from the point at which it is executed. This can be useful when updating
OpenFOAM libraries.
3.2.4 Compilation example: the pisoFoam application
The source code for application pisoFoam is in the $FOAM APP/solvers/incompressible/pisoFoam
directory and the top level source ﬁle is named pisoFoam.C. The pisoFoam.C source code
is:
1 /*---------------------------------------------------------------------------*\
2 ========= |
3 \\ / F ield | OpenFOAM: The Open Source CFD Toolbox
4 \\ / O peration |
5 \\ / A nd | Copyright (C) 2011-2012 OpenFOAM Foundation
6 \\/ M anipulation |
7 -------------------------------------------------------------------------------
8 License
9 This file is part of OpenFOAM.
10
11 OpenFOAM is free software: you can redistribute it and/or modify it
12 under the terms of the GNU General Public License as published by
Open∇FOAM-2.2.0
3.2 Compiling applications and libraries U-75
13 the Free Software Foundation, either version 3 of the License, or
14 (at your option) any later version.
15
16 OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
17 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
18 FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
19 for more details.
20
21 You should have received a copy of the GNU General Public License
22 along with OpenFOAM. If not, see <http://www.gnu.org/licenses/>.
23
24 Application
25 pisoFoam
26
27 Description
28 Transient solver for incompressible flow.
29
30 Turbulence modelling is generic, i.e. laminar, RAS or LES may be selected.
31
32 \*---------------------------------------------------------------------------*/
33
34 #include "fvCFD.H"
35 #include "singlePhaseTransportModel.H"
36 #include "turbulenceModel.H"
37
38 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
39
40 int main(int argc, char *argv[])
41 {
42 #include "setRootCase.H"
43
44 #include "createTime.H"
45 #include "createMesh.H"
46 #include "createFields.H"
47 #include "initContinuityErrs.H"
48
49 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
50
51 Info<< "\nStarting time loop\n" << endl;
52
53 while (runTime.loop())
54 {
55 Info<< "Time = " << runTime.timeName() << nl << endl;
56
57 #include "readPISOControls.H"
58 #include "CourantNo.H"
59
60 // Pressure-velocity PISO corrector
61 {
62 // Momentum predictor
63
64 fvVectorMatrix UEqn
65 (
66 fvm::ddt(U)
67 + fvm::div(phi, U)
68 + turbulence->divDevReff(U)
69 );
70
71 UEqn.relax();
72
73 if (momentumPredictor)
74 {
75 solve(UEqn == -fvc::grad(p));
76 }
77
78 // --- PISO loop
79
80 for (int corr=0; corr<nCorr; corr++)
81 {
82 volScalarField rAU(1.0/UEqn.A());
83
84 volVectorField HbyA("HbyA", U);
85 HbyA = rAU*UEqn.H();
86 surfaceScalarField phiHbyA
87 (
88 "phiHbyA",
89 (fvc::interpolate(HbyA) & mesh.Sf())
90 + fvc::ddtPhiCorr(rAU, U, phi)
91 );
92
93 adjustPhi(phiHbyA, U, p);
94
95 // Non-orthogonal pressure corrector loop
96 for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
Open∇FOAM-2.2.0
U-76 Applications and libraries
97 {
98 // Pressure corrector
99
100 fvScalarMatrix pEqn
101 (
102 fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
103 );
104
105 pEqn.setReference(pRefCell, pRefValue);
106
107 if
108 (
109 corr == nCorr-1
110 && nonOrth == nNonOrthCorr
111 )
112 {
113 pEqn.solve(mesh.solver("pFinal"));
114 }
115 else
116 {
117 pEqn.solve();
118 }
119
120 if (nonOrth == nNonOrthCorr)
121 {
122 phi = phiHbyA - pEqn.flux();
123 }
124 }
125
126 #include "continuityErrs.H"
127
128 U = HbyA - rAU*fvc::grad(p);
129 U.correctBoundaryConditions();
130 }
131 }
132
133 turbulence->correct();
134
135 runTime.write();
136
137 Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
138 << " ClockTime = " << runTime.elapsedClockTime() << " s"
139 << nl << endl;
140 }
141
142 Info<< "End\n" << endl;
143
144 return 0;
145 }
146
147
148 // ************************************************************************* //
The code begins with a brief description of the application contained within comments
over 1 line (//) and multiple lines (/*...*/). Following that, the code contains several
# include statements, e.g.# include "fvCFD.H", which causes the compiler to suspend
reading from the current ﬁle, pisoFoam.C to read the fvCFD.H.
pisoFoam resources the incompressibleRASModels, incompressibleLESModels and incom-
pressibleTransportModels libraries and therefore requires the necessary header ﬁles, spec-
iﬁed by the EXE INC = -I... option, and links to the libraries with the EXE LIBS =
-l... option. The Make/options therefore contains the following:
1 EXE_INC = \
2 -I$(LIB_SRC)/turbulenceModels/incompressible/turbulenceModel \
3 -I$(LIB_SRC)/transportModels \
4 -I$(LIB_SRC)/transportModels/incompressible/singlePhaseTransportModel \
5 -I$(LIB_SRC)/finiteVolume/lnInclude
6
7 EXE_LIBS = \
8 -lincompressibleTurbulenceModel \
9 -lincompressibleRASModels \
10 -lincompressibleLESModels \
11 -lincompressibleTransportModels \
12 -lfiniteVolume \
13 -lmeshTools
Open∇FOAM-2.2.0
3.2 Compiling applications and libraries U-77
pisoFoam contains only the pisoFoam.C source and the executable is written to the $FOAM APPBIN
directory as all standard applications are. The Make/ﬁles therefore contains:
1 pisoFoam.C
2
3 EXE = $(FOAM_APPBIN)/pisoFoam
The user can compile pisoFoam by going to the $FOAM SOLVERS/incompressible/pisoFoam
directory and typing:
wmake
The code should compile and produce a message similar to the following
Making dependency list for source file pisoFoam.C
SOURCE DIR=.
SOURCE=pisoFoam.C ;
g++ -DFOAM EXCEPTION -Dlinux -DlinuxOptMPICH
-DscalarMachine -DoptSolvers -DPARALLEL -DUSEMPI -Wall -O2 -DNoRepository
-ftemplate-depth-17 -I.../OpenFOAM/OpenFOAM-2.2.0/src/OpenFOAM/lnInclude
-IlnInclude
-I.
......
-lmpich -L/usr/X11/lib -lm
-o .../OpenFOAM/OpenFOAM-2.2.0/applications/bin/linuxOptMPICH/pisoFoam
The user can now try recompiling and will receive a message similar to the following to
say that the executable is up to date and compiling is not necessary:
make: Nothing to be done for `allFiles'.
make: `Make/linuxOptMPICH/dependencies' is up to date.
make: `.../OpenFOAM/OpenFOAM-2.2.0/applications/bin/linuxOptMPICH/pisoFoam'
is up to date.
The user can compile the application from scratch by removing the dependency list with
wclean
and running wmake.
3.2.5 Debug messaging and optimisation switches
OpenFOAM provides a system of messaging that is written during runtime, most of
which are to help debugging problems encountered during running of a OpenFOAM
case. The switches are listed in the $WM PROJECT DIR/etc/controlDict ﬁle; should the
user wish to change the settings they should make a copy to their $HOME directory,
i.e.$HOME/.OpenFOAM/2.2.0/controlDict ﬁle. The list of possible switches is extensive
and can be viewed by running the foamDebugSwitches application. Most of the switches
correspond to a class or range of functionality and can be switched on by their inclusion
in the controlDict ﬁle, and by being set to 1. For example, OpenFOAM can perform the
checking of dimensional units in all calculations by setting the dimensionSet switch to
1. There are some switches that control messaging at a higher level than most, listed in
Table 3.3.
Open∇FOAM-2.2.0
U-78 Applications and libraries
In addition, there are some switches that control certain operational and optimisa-
tion issues. These switches are also listed in Table 3.3. Of particular importance is
fileModificationSkew. OpenFOAM scans the write time of data ﬁles to check for mod-
iﬁcation. When running over a NFS with some disparity in the clock settings on diﬀerent
machines, ﬁeld data ﬁles appear to be modiﬁed ahead of time. This can cause a problem
if OpenFOAM views the ﬁles as newly modiﬁed and attempting to re-read this data. The
fileModificationSkew keyword is the time in seconds that OpenFOAM will subtract
from the ﬁle write time when assessing whether the ﬁle has been newly modiﬁed.
High level debugging switches - sub-dictionary DebugSwitches
level Overall level of debugging messaging for OpenFOAM- - 3 levels 0,
1, 2
lduMatrix Messaging for solver convergence during a run - 3 levels 0, 1, 2
Optimisation switches - sub-dictionary OptimisationSwitches
fileModific-
ationSkew
A time in seconds that should be set higher than the maximum
delay in NFS updates and clock diﬀerence for running OpenFOAM
over a NFS.
fileModific-
ationChecking
Method of checking whether ﬁles have been modiﬁed during a
simulation, either reading the timeStamp or using inotify; ver-
sions that read only master-node data exist, timeStampMaster,
inotifyMaster.
commsType Parallel communications type: nonBlocking, scheduled,
blocking.
floatTransfer If 1, will compact numbers to float precision before transfer; de-
fault is 0
nProcsSimpleSum Optimises global sum for parallel processing; sets number of pro-
cessors above which hierarchical sum is performed rather than a
linear sum (default 16)
Table 3.3: Runtime message switches.
3.2.6 Linking new user-deﬁned libraries to existing applications
The situation may arise that a user creates a new library, say new, and wishes the features
within that library to be available across a range of applications. For example, the
user may create a new boundary condition, compiled into new, that would need to be
recognised by a range of solver applications, pre- and post-processing utilities, mesh tools,
etc. Under normal circumstances, the user would need to recompile every application with
the new linked to it.
Instead there is a simple mechanism to link one or more shared object libraries dy-
namically at run-time in OpenFOAM. Simply add the optional keyword entry libs to
the controlDict ﬁle for a case and enter the full names of the libraries within a list (as
quoted string entries). For example, if a user wished to link the libraries new1 and new2
at run-time, they would simply need to add the following to the case controlDict ﬁle:
libs
(
"libnew1.so"
"libnew2.so"
Open∇FOAM-2.2.0
3.3 Running applications U-79
);
3.3 Running applications
Each application is designed to be executed from a terminal command line, typically
reading and writing a set of data ﬁles associated with a particular case. The data ﬁles
for a case are stored in a directory named after the case as described in section 4.1; the
directory name with full path is here given the generic name <caseDir>.
For any application, the form of the command line entry for any can be found by
simply entering the application name at the command line with the -help option, e.g.
typing
blockMesh -help
returns the usage
Usage: blockMesh [-region region name] [-case dir] [-blockTopology]
[-help] [-doc] [-srcDoc]
The arguments in square brackets, [ ], are optional ﬂags. If the application is exe-
cuted from within a case directory, it will operate on that case. Alternatively, the -case
<caseDir> option allows the case to be speciﬁed directly so that the application can be
executed from anywhere in the ﬁling system.
Like any UNIX/Linux executable, applications can be run as a background process,
i.e. one which does not have to be completed before the user can give the shell additional
commands. If the user wished to run the blockMesh example as a background process
and output the case progress to a log ﬁle, they could enter:
blockMesh > log &
3.4 Running applications in parallel
This section describes how to run OpenFOAM in parallel on distributed processors. The
method of parallel computing used by OpenFOAM is known as domain decomposition, in
which the geometry and associated ﬁelds are broken into pieces and allocated to separate
processors for solution. The process of parallel computation involves: decomposition of
mesh and ﬁelds; running the application in parallel; and, post-processing the decomposed
case as described in the following sections. The parallel running uses the public domain
openMPI implementation of the standard message passing interface (MPI).
3.4.1 Decomposition of mesh and initial ﬁeld data
The mesh and ﬁelds are decomposed using the decomposePar utility. The underlying
aim is to break up the domain with minimal eﬀort but in such a way to guarantee a
fairly economic solution. The geometry and ﬁelds are broken up according to a set of
parameters speciﬁed in a dictionary named decomposeParDict that must be located in
the system directory of the case of interest. An example decomposeParDict dictionary can
be copied from the interFoam/damBreak tutorial if the user requires one; the dictionary
entries within it are reproduced below:
Open∇FOAM-2.2.0
U-80 Applications and libraries
17
18 numberOfSubdomains 4;
19
20 method simple;
21
22 simpleCoeffs
23 {
24 n ( 2 2 1 );
25 delta 0.001;
26 }
27
28 hierarchicalCoeffs
29 {
30 n ( 1 1 1 );
31 delta 0.001;
32 order xyz;
33 }
34
35 manualCoeffs
36 {
37 dataFile "";
38 }
39
40 distributed no;
41
42 roots ( );
43
44
45 // ************************************************************************* //
The user has a choice of four methods of decomposition, speciﬁed by the method keyword
as described below.
simple Simple geometric decomposition in which the domain is split into pieces by di-
rection, e.g. 2 pieces in the x direction, 1 in y etc.
hierarchical Hierarchical geometric decomposition which is the same as simple except
the user speciﬁes the order in which the directional split is done, e.g. ﬁrst in the
y-direction, then the x-direction etc.
scotch Scotch decomposition which requires no geometric input from the user and at-
tempts to minimise the number of processor boundaries. The user can specify a
weighting for the decomposition between processors, through an optional process-
orWeights keyword which can be useful on machines with diﬀering performance
between processors. There is also an optional keyword entry strategy that con-
trols the decomposition strategy through a complex string supplied to Scotch. For
more information, see the source code ﬁle: $FOAM SRC/decompositionMethods/-
decompositionMethods/scotchDecomp/scotchDecomp.C
manual Manual decomposition, where the user directly speciﬁes the allocation of each
cell to a particular processor.
For each method there are a set of coeﬃcients speciﬁed in a sub-dictionary of decom-
positionDict, named <method>Coeﬀs as shown in the dictionary listing. The full set of
keyword entries in the decomposeParDict dictionary are explained in Table 3.4.
The decomposePar utility is executed in the normal manner by typing
decomposePar
On completion, a set of subdirectories will have been created, one for each processor, in
the case directory. The directories are named processorN where N = 0, 1, . . . represents a
processor number and contains a time directory, containing the decomposed ﬁeld descrip-
tions, and a constant/polyMesh directory containing the decomposed mesh description.
Open∇FOAM-2.2.0
3.4 Running applications in parallel U-81
Compulsory entries
numberOfSubdomains Total number of subdomains N
method Method of decomposition simple/
hierarchical/
scotch/ metis/
manual/
simpleCoeffs entries
n Number of subdomains in x, y, z (nx ny nz)
delta Cell skew factor Typically, 10−3
hierarchicalCoeffs entries
n Number of subdomains in x, y, z (nx ny nz)
delta Cell skew factor Typically, 10−3
order Order of decomposition xyz/xzy/yxz. . .
scotchCoeffs entries
processorWeights
(optional)
List of weighting factors for allocation
of cells to processors; <wt1> is the
weighting factor for processor 1, etc.;
weights are normalised so can take any
range of values.
(<wt1>...<wtN>)
strategy Decomposition strategy (optional); de-
faults to "b"
manualCoeffs entries
dataFile Name of ﬁle containing data of alloca-
tion of cells to processors
"<fileName>"
Distributed data entries (optional) — see section 3.4.3
distributed Is the data distributed across several
disks?
yes/no
roots Root paths to case directories; <rt1>
is the root path for node 1, etc.
(<rt1>...<rtN>)
Table 3.4: Keywords in decompositionDict dictionary.
3.4.2 Running a decomposed case
A decomposed OpenFOAM case is run in parallel using the openMPI implementation of
MPI.
openMPI can be run on a local multiprocessor machine very simply but when run-
ning on machines across a network, a ﬁle must be created that contains the host names
of the machines. The ﬁle can be given any name and located at any path. In the fol-
lowing description we shall refer to such a ﬁle by the generic name, including full path,
<machines>.
The <machines> ﬁle contains the names of the machines listed one machine per line.
The names must correspond to a fully resolved hostname in the /etc/hosts ﬁle of the
machine on which the openMPI is run. The list must contain the name of the machine
running the openMPI. Where a machine node contains more than one processor, the node
Open∇FOAM-2.2.0
U-82 Applications and libraries
name may be followed by the entry cpu=n where n is the number of processors openMPI
should run on that node.
For example, let us imagine a user wishes to run openMPI from machine aaa on the
following machines: aaa; bbb, which has 2 processors; and ccc. The <machines> would
contain:
aaa
bbb cpu=2
ccc
An application is run in parallel using mpirun.
mpirun --hostfile <machines> -np <nProcs>
<foamExec> <otherArgs> -parallel > log &
where: <nProcs> is the number of processors; <foamExec> is the executable, e.g.icoFoam;
and, the output is redirected to a ﬁle named log. For example, if icoFoam is run on 4
nodes, speciﬁed in a ﬁle named machines, on the cavity tutorial in the $FOAM RUN/-
tutorials/incompressible/icoFoam directory, then the following command should be exe-
cuted:
mpirun --hostfile machines -np 4 icoFoam -parallel > log &
3.4.3 Distributing data across several disks
Data ﬁles may need to be distributed if, for example, if only local disks are used in
order to improve performance. In this case, the user may ﬁnd that the root path to the
case directory may diﬀer between machines. The paths must then be speciﬁed in the
decomposeParDict dictionary using distributed and roots keywords. The distributed
entry should read
distributed yes;
and the roots entry is a list of root paths, <root0>, <root1>, . . . , for each node
roots
<nRoots>
(
"<root0>"
"<root1>"
...
);
where <nRoots> is the number of roots.
Each of the processorN directories should be placed in the case directory at each of
the root paths speciﬁed in the decomposeParDict dictionary. The system directory and
ﬁles within the constant directory must also be present in each case directory. Note: the
ﬁles in the constant directory are needed, but the polyMesh directory is not.
Open∇FOAM-2.2.0
3.5 Standard solvers U-83
3.4.4 Post-processing parallel processed cases
When post-processing cases that have been run in parallel the user has two options:
• reconstruction of the mesh and ﬁeld data to recreate the complete domain and ﬁelds,
which can be post-processed as normal;
• post-processing each segment of decomposed domain individually.
3.4.4.1 Reconstructing mesh and data
After a case has been run in parallel, it can be reconstructed for post-processing. The case
is reconstructed by merging the sets of time directories from each processorN directory into
a single set of time directories. The reconstructPar utility performs such a reconstruction
by executing the command:
reconstructPar
When the data is distributed across several disks, it must be ﬁrst copied to the local case
directory for reconstruction.
3.4.4.2 Post-processing decomposed cases
The user may post-process decomposed cases using the paraFoam post-processor, de-
scribed in section 6.1. The whole simulation can be post-processed by reconstructing the
case or alternatively it is possible to post-process a segment of the decomposed domain
individually by simply treating the individual processor directory as a case in its own
right.
3.5 Standard solvers
The solvers with the OpenFOAM distribution are in the $FOAM SOLVERS directory,
reached quickly by typing app at the command line. This directory is further subdivided
into several directories by category of continuum mechanics, e.g. incompressible ﬂow,
combustion and solid body stress analysis. Each solver is given a name that is reasonably
descriptive, e.g.icoFoam solves incompressible, laminar ﬂow. The current list of solvers
distributed with OpenFOAM is given in Table 3.5.
‘Basic’ CFD codes
laplacianFoam Solves a simple Laplace equation, e.g. for thermal diﬀusion
in a solid
potentialFoam Simple potential ﬂow solver which can be used to generate
starting ﬁelds for full Navier-Stokes codes
scalarTransportFoam Solves a transport equation for a passive scalar
Incompressible ﬂow
adjointShapeOptimiz-
ationFoam
Steady-state solver for incompressible, turbulent ﬂow of non-
Newtonian ﬂuids with optimisation of duct shape by applying
”blockage” in regions causing pressure loss as estimated using
an adjoint formulation
Continued on next page
Open∇FOAM-2.2.0
U-84 Applications and libraries
Continued from previous page
boundaryFoam Steady-state solver for incompressible, 1D turbulent ﬂow, typ-
ically to generate boundary layer conditions at an inlet, for
use in a simulation
icoFoam Transient solver for incompressible, laminar ﬂow of Newtonian
ﬂuids
nonNewtonianIcoFoam Transient solver for incompressible, laminar ﬂow of non-
Newtonian ﬂuids
pimpleDyMFoam Transient solver for incompressible, ﬂow of Newtonian ﬂu-
ids on a moving mesh using the PIMPLE (merged PISO-
SIMPLE) algorithm
pimpleFoam Large time-step transient solver for incompressible, ﬂow using
the PIMPLE (merged PISO-SIMPLE) algorithm
pisoFoam Transient solver for incompressible ﬂow
porousSimpleFoam Steady-state solver for incompressible, turbulent ﬂow with im-
plicit or explicit porosity treatment
potentialFreeSurfaceFoamIncompressible Navier-Stokes solver with inclusion of a wave
height ﬁeld to enable single-phase free-surface approximations
shallowWaterFoam Transient solver for inviscid shallow-water equations with ro-
tation
simpleFoam Steady-state solver for incompressible, turbulent ﬂow
SRFSimpleFoam Steady-state solver for incompressible, turbulent ﬂow of non-
Newtonian ﬂuids in a single rotating frame
SRFPimpleFoam Large time-step transient solver for incompressible, ﬂow in
a single rotating frame using the PIMPLE (merged PISO-
SIMPLE) algorithm.
Compressible ﬂow
rhoCentralDyMFoam Density-based compressible ﬂow solver based on central-
upwind schemes of Kurganov and Tadmor with moving mesh
capability and turbulence modelling
rhoCentralFoam Density-based compressible ﬂow solver based on central-
upwind schemes of Kurganov and Tadmor
rhoLTSPimpleFoam Transient solver for laminar or turbulent ﬂow of compress-
ible ﬂuids with support for run-time selectable ﬁnite volume
options, e.g. MRF, explicit porosity
rhoPimplecFoam Transient solver for laminar or turbulent ﬂow of compressible
ﬂuids for HVAC and similar applications
rhoPimpleFoam Transient solver for laminar or turbulent ﬂow of compressible
ﬂuids for HVAC and similar applications
rhoPorousSimpleFoam Steady-state solver for turbulent ﬂow of compressible ﬂuids
with RANS turbulence modelling, implicit or explicit porosity
treatment and run-time selectable ﬁnite volume sources
rhoSimplecFoam Steady-state SIMPLEC solver for laminar or turbulent RANS
ﬂow of compressible ﬂuids
rhoSimpleFoam Steady-state SIMPLE solver for laminar or turbulent RANS
ﬂow of compressible ﬂuids
sonicDyMFoam Transient solver for trans-sonic/supersonic, laminar or turbu-
lent ﬂow of a compressible gas with mesh motion
Continued on next page
Open∇FOAM-2.2.0
3.5 Standard solvers U-85
Continued from previous page
sonicFoam Transient solver for trans-sonic/supersonic, laminar or turbu-
lent ﬂow of a compressible gas
sonicLiquidFoam Transient solver for trans-sonic/supersonic, laminar ﬂow of a
compressible liquid
Multiphase ﬂow
cavitatingDyMFoam Transient cavitation code based on the homogeneous equi-
librium model from which the compressibility of the liq-
uid/vapour ”mixture” is obtained, with optional mesh motion
and mesh topology changes including adaptive re-meshing
cavitatingFoam Transient cavitation code based on the homogeneous equi-
librium model from which the compressibility of the liq-
uid/vapour ”mixture” is obtained
compressibleInterDyMFoamSolver for 2 compressible, non-isothermal immiscible ﬂuids us-
ing a VOF (volume of ﬂuid) phase-fraction based interface
capturing approach, with optional mesh motion and mesh
topology changes including adaptive re-meshing
compressibleInterFoam Solver for 2 compressible, isothermal immiscible ﬂuids using
a VOF (volume of ﬂuid) phase-fraction based interface cap-
turing approach
interFoam Solver for 2 incompressible, isothermal immiscible ﬂuids us-
ing a VOF (volume of ﬂuid) phase-fraction based interface
capturing approach
interDyMFoam Solver for 2 incompressible, isothermal immiscible ﬂuids using
a VOF (volume of ﬂuid) phase-fraction based interface captur-
ing approach, with optional mesh motion and mesh topology
changes including adaptive re-meshing.
interMixingFoam Solver for 3 incompressible ﬂuids, two of which are miscible,
using a VOF method to capture the interface
interPhaseChangeFoam Solver for 2 incompressible, isothermal immiscible ﬂuids with
phase-change (e.g. cavitation). Uses a VOF (volume of ﬂuid)
phase-fraction based interface capturing approach
LTSInterFoam Local time stepping (LTS, steady-state) solver for 2 incom-
pressible, isothermal immiscible ﬂuids using a VOF (volume
of ﬂuid) phase-fraction based interface capturing approach
MRFInterFoam Multiple reference frame (MRF) solver for 2 incompressible,
isothermal immiscible ﬂuids using a VOF (volume of ﬂuid)
phase-fraction based interface capturing approach
MRFMultiphaseInter-
Foam
Multiple reference frame (MRF) solver for n incompressible
ﬂuids which captures the interfaces and includes surface-
tension and contact-angle eﬀects for each phase
multiphaseEulerFoam Solver for a system of many compressible ﬂuid phases includ-
ing heat-transfer
multiphaseInterFoam Solver for n incompressible ﬂuids which captures the interfaces
and includes surface-tension and contact-angle eﬀects for each
phase
porousInterFoam Solver for 2 incompressible, isothermal immiscible ﬂuids us-
ing a VOF (volume of ﬂuid) phase-fraction based interface
capturing approach, with explicit handling of porous zones
Continued on next page
Open∇FOAM-2.2.0
U-86 Applications and libraries
Continued from previous page
settlingFoam Solver for 2 incompressible ﬂuids for simulating the settling
of the dispersed phase
twoLiquidMixingFoam Solver for mixing 2 incompressible ﬂuids
twoPhaseEulerFoam Solver for a system of 2 incompressible ﬂuid phases with one
phase dispersed, e.g. gas bubbles in a liquid
Direct numerical simulation (DNS)
dnsFoam Direct numerical simulation solver for boxes of isotropic tur-
bulence
Combustion
chemFoam Solver for chemistry problems - designed for use on single cell
cases to provide comparison against other chemistry solvers -
single cell mesh created on-the-ﬂy - ﬁelds created on the ﬂy
from the initial conditions
coldEngineFoam Solver for cold-ﬂow in internal combustion engines
engineFoam Solver for internal combustion engines
ﬁreFoam Transient Solver for Fires and turbulent diﬀusion ﬂames
PDRFoam Solver for compressible premixed/partially-premixed combus-
tion with turbulence modelling
reactingFoam Solver for combustion with chemical reactions
solverIndexrhoReactingBuoyantFoamSolver for combustion with chemical reactions using density
based thermodynamics package, using enahanced buoyancy
treatment
rhoReactingFoam Solver for combustion with chemical reactions using density
based thermodynamics package
XiFoam Solver for compressible premixed/partially-premixed combus-
tion with turbulence modelling
Heat transfer and buoyancy-driven ﬂows
buoyantBoussinesqPim-
pleFoam
Transient solver for buoyant, turbulent ﬂow of incompressible
ﬂuids
buoyantBoussinesqSim-
pleFoam
Steady-state solver for buoyant, turbulent ﬂow of incompress-
ible ﬂuids
buoyantPimpleFoam Transient solver for buoyant, turbulent ﬂow of compressible
ﬂuids for ventilation and heat-transfer
buoyantSimpleFoam Steady-state solver for buoyant, turbulent ﬂow of compressible
ﬂuids
chtMultiRegionFoam Combination of heatConductionFoam and buoyantFoam for
conjugate heat transfer between a solid region and ﬂuid re-
gion
chtMultiRegionSimpleFoamSteady-state version of chtMultiRegionFoam
Particle-tracking ﬂows
coalChemistryFoam Transient solver for: - compressible, - turbulent ﬂow, with -
coal and limestone parcel injections, - energy source, and -
combustion
icoUncoupledKinem-
aticParcelDyMFoam
Transient solver for the passive transport of a single kinematic
particle could
Continued on next page
Open∇FOAM-2.2.0
3.5 Standard solvers U-87
Continued from previous page
icoUncoupledKinem-
aticParcelFoam
Transient solver for the passive transport of a single kinematic
particle could
LTSReactingParcelFoam Local time stepping (LTS) solver for steady, compressible,
laminar or turbulent reacting and non-reacting ﬂow with mul-
tiphase Lagrangian parcels and porous media, including ex-
plicit sources for mass, momentum and energy
reactingParcelFilmFoam Transient PISO solver for compressible, laminar or turbulent
ﬂow with reacting Lagrangian parcels, and surface ﬁlm mod-
elling
reactingParcelFoam Transient PIMPLE solver for compressible, laminar or tur-
bulent ﬂow with reacting multiphase Lagrangian parcels, in-
cluding run-time selectable ﬁnite volume options, e.g. sources,
constraints
simpleReactingParcelFoamSteady state SIMPLE solver for compressible, laminar or tur-
bulent ﬂow with reacting multiphase Lagrangian parcels, in-
cluding run-time selectable ﬁnite volume options, e.g. sources,
constraints
sprayEngineFoam Transient PIMPLE solver for compressible, laminar or turbu-
lent engine ﬂow swith spray parcels
sprayFoam Transient PIMPLE solver for compressible, laminar or turbu-
lent ﬂow with spray parcels
uncoupledKinematic-
ParcelFoam
Transient solver for the passive transport of a single kinematic
particle could
Molecular dynamics methods
mdEquilibrationFoam Equilibrates and/or preconditions molecular dynamics sys-
tems
mdFoam Molecular dynamics solver for ﬂuid dynamics
Direct simulation Monte Carlo methods
dsmcFoam Direct simulation Monte Carlo (DSMC) solver for 3D, tran-
sient, multi- species ﬂows
Electromagnetics
electrostaticFoam Solver for electrostatics
magneticFoam Solver for the magnetic ﬁeld generated by permanent magnets
mhdFoam Solver for magnetohydrodynamics (MHD): incompressible,
laminar ﬂow of a conducting ﬂuid under the inﬂuence of a
magnetic ﬁeld
Stress analysis of solids
solidDisplacement-
Foam
Transient segregated ﬁnite-volume solver of linear-elastic,
small-strain deformation of a solid body, with optional ther-
mal diﬀusion and thermal stresses
solidEquilibriumDis-
placementFoam
Steady-state segregated ﬁnite-volume solver of linear-elastic,
small-strain deformation of a solid body, with optional ther-
mal diﬀusion and thermal stresses
Continued on next page
Open∇FOAM-2.2.0
U-88 Applications and libraries
Continued from previous page
Finance
ﬁnancialFoam Solves the Black-Scholes equation to price commodities
Table 3.5: Standard library solvers.
3.6 Standard utilities
The utilities with the OpenFOAM distribution are in the $FOAM UTILITIES directory,
reached quickly by typing util at the command line. Again the names are reasonably
descriptive, e.g.ideasToFoam converts mesh data from the format written by I-DEAS to
the OpenFOAM format. The current list of utilities distributed with OpenFOAM is given
in Table 3.6.
Pre-processing
applyBoundaryLayer Apply a simpliﬁed boundary-layer model to the velocity and
turbulence ﬁelds based on the 1/7th power-law
applyWallFunction-
BoundaryConditions
Updates OpenFOAM RAS cases to use the new (v1.6) wall
function framework
boxTurb Makes a box of turbulence which conforms to a given energy
spectrum and is divergence free
changeDictionary Utility to change dictionary entries, e.g. can be used to change
the patch type in the ﬁeld and polyMesh/boundary ﬁles
dsmcInitialise Initialise a case for dsmcFoam by reading the initialisation
dictionary system/dsmcInitialise
engineSwirl Generates a swirling ﬂow for engine calulations
faceAgglomerate Agglomerate boundary faces for use with the view factor ra-
diation model. Writes a map from the ﬁne to the coarse grid.
foamUpgradeCyclics Tool to upgrade mesh and ﬁelds for split cyclics
foamUpgradeFvSolution Simple tool to upgrade the syntax of system/fvSolution::solvers
mapFields Maps volume ﬁelds from one mesh to another, reading and
interpolating all ﬁelds present in the time directory of both
cases. Parallel and non-parallel cases are handled without the
need to reconstruct them ﬁrst
mdInitialise Initialises ﬁelds for a molecular dynamics (MD) simulation
setFields Set values on a selected set of cells/patchfaces through a dic-
tionary
viewFactorsGen Calculates view factors based on agglomerated faces (faceAg-
glomerat) for view factor radiation model.
wallFunctionTable Generates a table suitable for use by tabulated wall functions
Mesh generation
blockMesh A multi-block mesh generator
extrudeMesh Extrude mesh from existing patch (by default outwards facing
normals; optional ﬂips faces) or from patch read from ﬁle.
extrude2DMesh Takes 2D mesh (all faces 2 points only, no front and back
faces) and creates a 3D mesh by extruding with speciﬁed
thickness
Continued on next page
Open∇FOAM-2.2.0
3.6 Standard utilities U-89
Continued from previous page
extrudeToRegionMesh Extrude faceZones into separate mesh (as a diﬀerent region),
e.g. for creating liquid ﬁlm regions
snappyHexMesh Automatic split hex mesher. Reﬁnes and snaps to surface
Mesh conversion
ansysToFoam Converts an ANSYS input mesh ﬁle, exported from I-DEAS,
to OpenFOAM format
cfx4ToFoam Converts a CFX 4 mesh to OpenFOAM format
datToFoam Reads in a datToFoam (.dat) mesh ﬁle and outputs a points
ﬁle. Used in conjunction with blockMesh
ﬂuent3DMeshToFoam Converts a Fluent mesh to OpenFOAM format
ﬂuentMeshToFoam Converts a Fluent mesh to OpenFOAM format including mul-
tiple region and region boundary handling
foamMeshToFluent Writes out the OpenFOAM mesh in Fluent mesh format
foamToStarMesh Reads an OpenFOAM mesh and writes a PROSTAR (v4)
bnd/cel/vrt format
foamToSurface Reads an OpenFOAM mesh and writes the boundaries in a
surface format
gambitToFoam Converts a GAMBIT mesh to OpenFOAM format
gmshToFoam Reads .msh ﬁle as written by Gmsh
ideasUnvToFoam I-Deas unv format mesh conversion
kivaToFoam Converts a KIVA grid to OpenFOAM format
mshToFoam Converts .msh ﬁle generated by the Adventure system
netgenNeutralToFoam Converts neutral ﬁle format as written by Netgen v4.4
plot3dToFoam Plot3d mesh (ascii/formatted format) converter
sammToFoam Converts a STAR-CD (v3) SAMM mesh to OpenFOAM format
star3ToFoam Converts a STAR-CD (v3) PROSTAR mesh into OpenFOAM
format
star4ToFoam Converts a STAR-CD (v4) PROSTAR mesh into OpenFOAM
format
tetgenToFoam Converts .ele and .node and .face ﬁles, written by tetgen
writeMeshObj For mesh debugging: writes mesh as three separate OBJ ﬁles
which can be viewed with e.g. javaview
Mesh manipulation
attachMesh Attach topologically detached mesh using prescribed mesh
modiﬁers
autoPatch Divides external faces into patches based on (user supplied)
feature angle
checkMesh Checks validity of a mesh
createBaﬄes Makes internal faces into boundary faces. Does not duplicate
points, unlike mergeOrSplitBaﬄes
createPatch Utility to create patches out of selected boundary faces. Faces
come either from existing patches or from a faceSet
deformedGeom Deforms a polyMesh using a displacement ﬁeld U and a scaling
factor supplied as an argument
ﬂattenMesh Flattens the front and back planes of a 2D cartesian mesh
insideCells Picks up cells with cell centre ’inside’ of surface. Requires
surface to be closed and singly connected
Continued on next page
Open∇FOAM-2.2.0
U-90 Applications and libraries
Continued from previous page
mergeMeshes Merges two meshes
mergeOrSplitBaﬄes Detects faces that share points (baﬄes). Either merge them
or duplicate the points
mirrorMesh Mirrors a mesh around a given plane
moveDynamicMesh Mesh motion and topological mesh changes utility
moveEngineMesh Solver for moving meshes for engine calculations
moveMesh Solver for moving meshes
objToVTK Read obj line (not surface!) ﬁle and convert into vtk
polyDualMesh Calculates the dual of a polyMesh. Adheres to all the feature
and patch edges
reﬁneMesh Utility to reﬁne cells in multiple directions
renumberMesh Renumbers the cell list in order to reduce the bandwidth,
reading and renumbering all ﬁelds from all the time directories
rotateMesh Rotates the mesh and ﬁelds from the direcion n1 to the direc-
tion n2
setSet Manipulate a cell/face/point/ set or zone interactively
setsToZones Add pointZones/faceZones/cellZones to the mesh from similar
named pointSets/faceSets/cellSets
singleCellMesh Reads all ﬁelds and maps them to a mesh with all internal
faces removed (singleCellFvMesh) which gets written to region
singleMesh. Used to generate mesh and ﬁelds that can be
used for boundary-only data. Might easily result in illegal
mesh though so only look at boundaries in paraview
splitMesh Splits mesh by making internal faces external. Uses attachDe-
tach
splitMeshRegions Splits mesh into multiple regions
stitchMesh ’Stitches’ a mesh
subsetMesh Selects a section of mesh based on a cellSet
topoSet Operates on cellSets/faceSets/pointSets through a dictionary
transformPoints Transforms the mesh points in the polyMesh directory accord-
ing to the translate, rotate and scale options
zipUpMesh Reads in a mesh with hanging vertices and zips up the cells
to guarantee that all polyhedral cells of valid shape are closed
Other mesh tools
autoReﬁneMesh Utility to reﬁne cells near to a surface
collapseEdges Collapses short edges and combines edges that are in line
combinePatchFaces Checks for multiple patch faces on same cell and combines
them. Multiple patch faces can result from e.g. removal of
reﬁned neighbouring cells, leaving 4 exposed faces with same
owner.
modifyMesh Manipulates mesh elements
PDRMesh Mesh and ﬁeld preparation utility for PDR type simulations
reﬁneHexMesh Reﬁnes a hex mesh by 2x2x2 cell splitting
reﬁnementLevel Tries to ﬁgure out what the reﬁnement level is on reﬁned
cartesian meshes. Run before snapping
reﬁneWallLayer Utility to reﬁne cells next to patches
removeFaces Utility to remove faces (combines cells on both sides)
selectCells Select cells in relation to surface
Continued on next page
Open∇FOAM-2.2.0
3.6 Standard utilities U-91
Continued from previous page
splitCells Utility to split cells with ﬂat faces
Post-processing graphics
ensightFoamReader EnSight library module to read OpenFOAM data directly
without translation
Post-processing data converters
foamDataToFluent Translates OpenFOAM data to Fluent format
foamToEnsight Translates OpenFOAM data to EnSight format
foamToEnsightParts Translates OpenFOAM data to Ensight format. An Ensight
part is created for each cellZone and patch
foamToGMV Translates foam output to GMV readable ﬁles
foamToTecplot360 Tecplot binary ﬁle format writer
foamToVTK Legacy VTK ﬁle format writer
smapToFoam Translates a STAR-CD SMAP data ﬁle into OpenFOAM ﬁeld
format
Post-processing velocity ﬁelds
Co Calculates and writes the Courant number obtained from ﬁeld
phi as a volScalarField.
enstrophy Calculates and writes the enstrophy of the velocity ﬁeld U
ﬂowType Calculates and writes the ﬂowType of velocity ﬁeld U
Lambda2 Calculates and writes the second largest eigenvalue of the sum
of the square of the symmetrical and anti-symmetrical parts
of the velocity gradient tensor
Mach Calculates and optionally writes the local Mach number from
the velocity ﬁeld U at each time
Pe Calculates and writes the Pe number as a surfaceScalar-
Field obtained from ﬁeld phi
Q Calculates and writes the second invariant of the velocity gra-
dient tensor
streamFunction Calculates and writes the stream function of velocity ﬁeld U
at each time
uprime Calculates and writes the scalar ﬁeld of uprime ( 2k/3)
vorticity Calculates and writes the vorticity of velocity ﬁeld U
Post-processing stress ﬁelds
stressComponents Calculates and writes the scalar ﬁelds of the six components
of the stress tensor sigma for each time
Post-processing scalar ﬁelds
pPrime2 Calculates and writes the scalar ﬁeld of pPrime2 ([p − p]2
) at
each time
Post-processing at walls
wallGradU Calculates and writes the gradient of U at the wall.
wallHeatFlux Calculates and writes the heat ﬂux for all patches as the
boundary ﬁeld of a volScalarField and also prints the inte-
grated ﬂux for all wall patches.
Continued on next page
Open∇FOAM-2.2.0
U-92 Applications and libraries
Continued from previous page
wallShearStress Calculates and writes the wall shear stress, for the speciﬁed
times when using RAS turbulence models.
yPlusLES Calculates and reports yPlus for all wall patches, for the spec-
iﬁed times when using LES turbulence models.
yPlusRAS Calculates and reports yPlus for all wall patches, for the spec-
iﬁed times when using RAS turbulence models.
Post-processing turbulence
createTurbulenceFields Creates a full set of turbulence ﬁelds
R Calculates and writes the Reynolds stress R for the current
time step
Post-processing patch data
patchAverage Calculates the average of the speciﬁed ﬁeld over the speciﬁed
patch
patchIntegrate Calculates the integral of the speciﬁed ﬁeld over the speciﬁed
patch
Post-processing Lagrangian simulation
particleTracks Generates a VTK ﬁle of particle tracks for cases that were
computed using a tracked-parcel-type cloud
steadyParticleTracks Generates a VTK ﬁle of particle tracks for cases that were
computed using a steady-state cloud NOTE: case must be
re-constructed (if running in parallel) before use
Sampling post-processing
probeLocations Probe locations
sample Sample ﬁeld data with a choice of interpolation schemes, sam-
pling options and write formats
Miscellaneous post-processing
dsmcFieldsCalc Calculate intensive ﬁelds (U and T) from averaged extensive
ﬁelds from a DSMC calculation
engineCompRatio Calculate the geometric compression ratio. Note that if you
have valves and/or extra volumes it will not work, since it
calculates the volume at BDC and TCD
execFlowFunctionObjects Execute the set of functionObjects speciﬁed in the selected
dictionary (which defaults to system/controlDict) for the se-
lected set of times. Alternative dictionaries should be placed
in the system/ folder
foamCalc Generic utility for simple ﬁeld calculations at speciﬁed times
foamListTimes List times using timeSelector
pdfPlot Generates a graph of a probability distribution function
postChannel Post-processes data from channel ﬂow calculations
ptot For each time: calculate the total pressure
wdot Calculates and writes wdot for each time
writeCellCentres Write the three components of the cell centres as volScalar-
Fields so they can be used in postprocessing in thresholding
Continued on next page
Open∇FOAM-2.2.0
3.6 Standard utilities U-93
Continued from previous page
Surface mesh (e.g. STL) tools
surfaceAdd Add two surfaces. Does geometric merge on points. Does not
check for overlapping/intersecting triangles
surfaceAutoPatch Patches surface according to feature angle. Like autoPatch
surfaceCheck Checking geometric and topological quality of a surface.
surfaceClean - removes baﬄes - collapses small edges, removing triangles.
- converts sliver triangles into split edges by projecting point
onto base of triangle
surfaceCoarsen Surface coarsening using ’bunnylod’.
surfaceConvert Converts from one surface mesh format to another
surfaceFeatureConvert Convert between edgeMesh formats
surfaceFeatureExtract Extracts and writes surface features to ﬁle
surfaceFind Finds nearest face and vertex
surfaceInertia Calculates the inertia tensor, principal axes and moments of
a command line speciﬁed triSurface. Inertia can either be of
the solid body or of a thin shell
surfaceMeshConvert Converts between surface formats with optional scaling or
transformations (rotate/translate) on a coordinateSystem
surfaceMeshConvert-
Testing
Converts from one surface mesh format to another, but pri-
marily used for testing functionality
surfaceMeshExport Export from surfMesh to various third-party surface formats
with optional scaling or transformations (rotate/translate) on
a coordinateSystem
surfaceMeshImport Import from various third-party surface formats into surfMesh
with optional scaling or transformations (rotate/translate) on
a coordinateSystem
surfaceMeshInfo Miscellaneous information about surface meshes
surfaceMeshTriangulate Extracts triSurface from a polyMesh. Depending on output
surface format triangulates faces. Region numbers on trian-
gles are the patch numbers of the polyMesh. Optionally only
triangulates named patches
surfaceOrient Set normal consistent with respect to a user provided ’outside’
point. If the -inside is used the point is considered inside.
surfacePointMerge Merges points on surface if they are within absolute distance.
Since absolute distance use with care!
surfaceRedistributePar (Re)distribution of triSurface. Either takes an undecomposed
surface or an already decomposed surface and redistributes it
so that each processor has all triangles that overlap its mesh.
surfaceReﬁneRedGreen Reﬁne by splitting all three edges of triangle (’red’ reﬁne-
ment). Neighbouring triangles (which are not marked for re-
ﬁnement get split in half (’green’ reﬁnement). (R. Verfuerth,
”A review of a posteriori error estimation and adaptive mesh
reﬁnement techniques”, Wiley-Teubner, 1996)
surfaceSmooth Example of a simple laplacian smoother
surfaceSplitByPatch Writes regions of triSurface to separate ﬁles
Continued on next page
Open∇FOAM-2.2.0
U-94 Applications and libraries
Continued from previous page
surfaceSplitNonMani-
folds
Takes multiply connected surface and tries to split surface at
multiply connected edges by duplicating points. Introduces
concept of - borderEdge. Edge with 4 faces connected to it.
- borderPoint. Point connected to exactly 2 borderEdges. -
borderLine. Connected list of borderEdges
surfaceSubset A surface analysis tool which sub-sets the triSurface to choose
only a part of interest. Based on subsetMesh
surfaceToPatch Reads surface and applies surface regioning to a mesh. Uses
boundaryMesh to do the hard work
surfaceTransformPoints Transform (scale/rotate) a surface. Like transformPoints but
for surfaces
Parallel processing
decomposePar Automatically decomposes a mesh and ﬁelds of a case for
parallel execution of OpenFOAM.
reconstructPar Reconstructs a mesh and ﬁelds of a case that is decomposed
for parallel execution of OpenFOAM.
reconstructParMesh Reconstructs a mesh using geometric information only.
Thermophysical-related utilities
adiabaticFlameT Calculates the adiabatic ﬂame temperature for a given fuel
over a range of unburnt temperatures and equivalence ratios
chemkinToFoam Converts CHEMKIN 3 thermodynamics and reaction data ﬁles
into OpenFOAM format
equilibriumCO Calculates the equilibrium level of carbon monoxide
equilibriumFlameT Calculates the equilibrium ﬂame temperature for a given fuel
and pressure for a range of unburnt gas temperatures and
equivalence ratios; the eﬀects of dissociation on O2, H2O and
CO2 are included
mixtureAdiabaticFlameT Calculates the adiabatic ﬂame temperature for a given mix-
ture at a given temperature
Miscellaneous utilities
expandDictionary Read the dictionary provided as an argument, expand the
macros etc. and write the resulting dictionary to standard
output
foamDebugSwitches Write out all library debug switches
foamFormatConvert Converts all IOobjects associated with a case into the format
speciﬁed in the controlDict
foamInfoExec Interrogates a case and prints information to stdout
patchSummary Writes ﬁelds and boundary condition info for each patch at
each requested time instance
Table 3.6: Standard library utilities.
Open∇FOAM-2.2.0
3.7 Standard libraries U-95
3.7 Standard libraries
The libraries with the OpenFOAM distribution are in the $FOAM LIB/$WM OPTIONS
directory, reached quickly by typing lib at the command line. Again, the names are
preﬁxed by lib and reasonably descriptive, e.g. incompressibleTransportModels contains
the library of incompressible transport models. For ease of presentation, the libraries are
separated into two types:
General libraries those that provide general classes and associated functions listed in
Table 3.7;
Model libraries those that specify models used in computational continuum mechanics,
listed in Table 3.8, Table 3.9 and Table 3.10.
Library of basic OpenFOAM tools — OpenFOAM
algorithms Algorithms
containers Container classes
db Database classes
dimensionedTypes dimensioned<Type> class and derivatives
dimensionSet dimensionSet class
ﬁelds Field classes
global Global settings
graph graph class
interpolations Interpolation schemes
matrices Matrix classes
memory Memory management tools
meshes Mesh classes
primitives Primitive classes
Finite volume method library — ﬁniteVolume
cfdTools CFD tools
ﬁelds Volume, surface and patch ﬁeld classes; includes boundary
conditions
ﬁniteVolume Finite volume discretisation
fvMatrices Matrices for ﬁnite volume solution
fvMesh Meshes for ﬁnite volume discretisation
interpolation Field interpolation and mapping
surfaceMesh Mesh surface data for ﬁnite volume discretisation
volMesh Mesh volume (cell) data for ﬁnite volume discretisation
Post-processing libraries
ﬁeldFunctionObjects Field function objects including ﬁeld averaging, min/max, etc.
foamCalcFunctions Functions for the foamCalc utility
forces Tools for post-processing force/lift/drag data with function
objects
jobControl Tools for controlling job running with a function object
postCalc For using functionality of a function object as a post-
processing activity
sampling Tools for sampling ﬁeld data at prescribed locations in a do-
main
Continued on next page
Open∇FOAM-2.2.0
U-96 Applications and libraries
Continued from previous page
systemCall General function object for making system calls while running
a case
utilityFunctionObjects Utility function objects
Solution and mesh manipulation libraries
autoMesh Library of functionality for the snappyHexMesh utility
blockMesh Library of functionality for the blockMesh utility
dynamicMesh For solving systems with moving meshes
dynamicFvMesh Library for a ﬁnite volume mesh that can move and undergo
topological changes
edgeMesh For handling edge-based mesh descriptions
fvMotionSolvers Finite volume mesh motion solvers
ODE Solvers for ordinary diﬀerential equations
meshTools Tools for handling a OpenFOAM mesh
surfMesh Library for handling surface meshes of diﬀerent formats
triSurface For handling standard triangulated surface-based mesh de-
scriptions
topoChangerFvMesh Topological changes functionality (largely redundant)
Lagrangian particle tracking libraries
coalCombustion Coal dust combustion modelling
dieselSpray Diesel spray and injection modelling
distributionModels Particle distribution function modelling
dsmc Direct simulation Monte Carlo method modelling
lagrangian Basic Lagrangian, or particle-tracking, solution scheme
lagrangianIntermediate Particle-tracking kinematics, thermodynamics, multispecies
reactions, particle forces, etc.
potential Intermolecular potentials for molecular dynamics
molecule Molecule classes for molecular dynamics
molecularMeasurements For making measurements in molecular dynamics
solidParticle Solid particle implementation
Miscellaneous libraries
conversion Tools for mesh and data conversions
decompositionMethods Tools for domain decomposition
engine Tools for engine calculations
ﬁleFormats Core routines for reading/writing data in some third-party
formats
genericFvPatchField A generic patch ﬁeld
MGridGenGAMG-
Agglomeration
Library for cell agglomeration using the MGridGen algorithm
pairPatchAgglom-
eration
Primitive pair patch agglomeration method
OSspeciﬁc Operating system speciﬁc functions
randomProcesses Tools for analysing and generating random processes
Parallel libraries
distributed Tools for searching and IO on distributed surfaces
reconstruct Mesh/ﬁeld reconstruction library
Continued on next page
Open∇FOAM-2.2.0
3.7 Standard libraries U-97
Continued from previous page
scotchDecomp Scotch domain decomposition library
ptsotchDecomp PTScotch domain decomposition library
Table 3.7: Shared object libraries for general use.
Basic thermophysical models — basicThermophysicalModels
hPsiThermo General thermophysical model calculation based on en-
thalpy h and compressibility ψ
hsPsiThermo General thermophysical model calculation based on sensi-
ble enthalpy hs and compressibility ψ
ePsiThermo General thermophysical model calculation based on inter-
nal energy e and compressibility ψ
hRhoThermo General thermophysical model calculation based on en-
thalpy h
hsRhoThermo General thermophysical model calculation based on sensi-
ble enthalpy hs
pureMixture General thermophysical model calculation for passive gas
mixtures
Reaction models — reactionThermophysicalModels
hPsiMixtureThermo Calculates enthalpy for combustion mixture based on en-
thalpy h and ψ
hsPsiMixtureThermo Calculates enthalpy for combustion mixture based on sen-
sible enthalpy hs and ψ
hRhoMixtureThermo Calculates enthalpy for combustion mixture based on en-
thalpy h and ρ
hsRhoMixtureThermo Calculates enthalpy for combustion mixture based on sen-
sible enthalpy hs and ρ
hhuMixtureThermo Calculates enthalpy for unburnt gas and combustion mix-
ture
homogeneousMixture Combustion mixture based on normalised fuel mass frac-
tion b
inhomogeneousMixture Combustion mixture based on b and total fuel mass fraction
ft
veryInhomogeneousMixture Combustion mixture based on b, ft and unburnt fuel mass
fraction fu
dieselMixture Combustion mixture based on ft and fu
basicMultiComponent-
Mixture
Basic mixture based on multiple components
multiComponentMixture Derived mixture based on multiple components
reactingMixture Combustion mixture using thermodynamics and reaction
schemes
egrMixture Exhaust gas recirculation mixture
Continued on next page
Open∇FOAM-2.2.0
U-98 Applications and libraries
Continued from previous page
Radiation models — radiationModels
P1 P1 model
fvDOM Finite volume discrete ordinate method
viewFactor View factor radiation model
Laminar ﬂame speed models — laminarFlameSpeedModels
constLaminarFlameSpeed Constant laminar ﬂame speed
GuldersLaminarFlameSpeed Gulder’s laminar ﬂame speed model
GuldersEGRLaminar-
FlameSpeed
Gulder’s laminar ﬂame speed model with exhaust gas re-
circulation modelling
Barotropic compressibility models — barotropicCompressibilityModels
linear Linear compressibility model
Chung Chung compressibility model
Wallis Wallis compressibility model
Thermophysical properties of gaseous species — specie
icoPolynomial Incompressible polynomial equation of state, e.g. for liquids
perfectGas Perfect gas equation of state
eConstThermo Constant speciﬁc heat cp model with evaluation of internal
energy e and entropy s
hConstThermo Constant speciﬁc heat cp model with evaluation of enthalpy
h and entropy s
hPolynomialThermo cp evaluated by a function with coeﬃcients from polynomi-
als, from which h, s are evaluated
janafThermo cp evaluated by a function with coeﬃcients from JANAF
thermodynamic tables, from which h, s are evaluated
specieThermo Thermophysical properties of species, derived from cp, h
and/or s
constTransport Constant transport properties
polynomialTransport Polynomial based temperature-dependent transport prop-
erties
sutherlandTransport Sutherland’s formula for temperature-dependent transport
properties
Functions/tables of thermophysical properties — thermophysicalFunctions
NSRDSfunctions National Standard Reference Data System (NSRDS) -
American Institute of Chemical Engineers (AICHE) data
compilation tables
APIfunctions American Petroleum Institute (API) function for vapour
mass diﬀusivity
Chemistry model — chemistryModel
chemistryModel Chemical reaction model
chemistrySolver Chemical reaction solver
Other libraries
liquidProperties Thermophysical properties of liquids
Continued on next page
Open∇FOAM-2.2.0
3.7 Standard libraries U-99
Continued from previous page
liquidMixtureProperties Thermophysical properties of liquid mixtures
basicSolidThermo Thermophysical models of solids
solid Thermodynamics of solid species
SLGThermo Thermodynamic package for solids, liquids and gases
solidProperties Thermophysical properties of solids
solidMixtureProperties Thermophysical properties of solid mixtures
thermalPorousZone Porous zone deﬁnition based on cell zones that includes
terms for energy equations
Table 3.8: Libraries of thermophysical models.
RAS turbulence models for incompressible ﬂuids — incompressibleRASModels
laminar Dummy turbulence model for laminar ﬂow
kEpsilon Standard high-Re k − ε model
kOmega Standard high-Re k − ω model
kOmegaSST k − ω-SST model
RNGkEpsilon RNG k − ε model
NonlinearKEShih Non-linear Shih k − ε model
LienCubicKE Lien cubic k − ε model
qZeta q − ζ model
LaunderSharmaKE Launder-Sharma low-Re k − ε model
LamBremhorstKE Lam-Bremhorst low-Re k − ε model
LienCubicKELowRe Lien cubic low-Re k − ε model
LienLeschzinerLowRe Lien-Leschziner low-Re k − ε model
LRR Launder-Reece-Rodi RSTM
LaunderGibsonRSTM Launder-Gibson RSTM with wall-reﬂection terms
realizableKE Realizable k − ε model
SpalartAllmaras Spalart-Allmaras 1-eqn mixing-length model
RAS turbulence models for compressible ﬂuids — compressibleRASModels
laminar Dummy turbulence model for laminar ﬂow
kEpsilon Standard k − ε model
kOmegaSST k − ω − SST model
RNGkEpsilon RNG k − ε model
LaunderSharmaKE Launder-Sharma low-Re k − ε model
LRR Launder-Reece-Rodi RSTM
LaunderGibsonRSTM Launder-Gibson RSTM
realizableKE Realizable k − ε model
SpalartAllmaras Spalart-Allmaras 1-eqn mixing-length model
Large-eddy simulation (LES) ﬁlters — LESﬁlters
laplaceFilter Laplace ﬁlters
simpleFilter Simple ﬁlter
anisotropicFilter Anisotropic ﬁlter
Large-eddy simulation deltas — LESdeltas
PrandtlDelta Prandtl delta
cubeRootVolDelta Cube root of cell volume delta
Continued on next page
Open∇FOAM-2.2.0
U-100 Applications and libraries
Continued from previous page
maxDeltaxyz Maximum of x, y and z; for structured hex cells only
smoothDelta Smoothing of delta
Incompressible LES turbulence models — incompressibleLESModels
Smagorinsky Smagorinsky model
Smagorinsky2 Smagorinsky model with 3-D ﬁlter
dynSmagorinsky Dynamic Smagorinsky
homogenousDynSmag-
orinsky
Homogeneous dynamic Smagorinsky model
dynLagrangian Lagrangian two equation eddy-viscosity model
scaleSimilarity Scale similarity model
mixedSmagorinsky Mixed Smagorinsky/scale similarity model
dynMixedSmagorinsky Dynamic mixed Smagorinsky/scale similarity model
kOmegaSSTSAS k − ω-SST scale adaptive simulation (SAS) model
oneEqEddy k-equation eddy-viscosity model
dynOneEqEddy Dynamic k-equation eddy-viscosity model
locDynOneEqEddy Localised dynamic k-equation eddy-viscosity model
spectEddyVisc Spectral eddy viscosity model
LRDDiﬀStress LRR diﬀerential stress model
DeardorﬀDiﬀStress Deardorﬀ diﬀerential stress model
SpalartAllmaras Spalart-Allmaras model
SpalartAllmarasDDES Spalart-Allmaras delayed detached eddy simulation
(DDES) model
SpalartAllmarasIDDES Spalart-Allmaras improved DDES (IDDES) model
Compressible LES turbulence models — compressibleLESModels
Smagorinsky Smagorinsky model
oneEqEddy k-equation eddy-viscosity model
dynOneEqEddy Dynamic k-equation eddy-viscosity model
lowReOneEqEddy Low-Re k-equation eddy-viscosity model
DeardorﬀDiﬀStress Deardorﬀ diﬀerential stress model
SpalartAllmaras Spalart-Allmaras 1-eqn mixing-length model
Table 3.9: Libraries of RAS and LES turbulence models.
Transport models for incompressible ﬂuids — incompressibleTransportModels
Newtonian Linear viscous ﬂuid model
CrossPowerLaw Cross Power law nonlinear viscous model
BirdCarreau Bird-Carreau nonlinear viscous model
HerschelBulkley Herschel-Bulkley nonlinear viscous model
powerLaw Power-law nonlinear viscous model
interfaceProperties Models for the interface, e.g. contact angle, in multiphase
simulations
Miscellaneous transport modelling libraries
interfaceProperties Calculation of interface properties
twoPhaseInterfacePropertiesTwo phase interface properties models, including boundary
conditions
Continued on next page
Open∇FOAM-2.2.0
3.7 Standard libraries U-101
Continued from previous page
surfaceFilmModels Surface ﬁlm models
Table 3.10: Shared object libraries of transport models.
Open∇FOAM-2.2.0
U-102 Applications and libraries
Open∇FOAM-2.2.0
Chapter 4
OpenFOAM cases
This chapter deals with the ﬁle structure and organisation of OpenFOAM cases. Nor-
mally, a user would assign a name to a case, e.g. the tutorial case of ﬂow in a cavity
is simply named cavity. This name becomes the name of a directory in which all the
case ﬁles and subdirectories are stored. The case directories themselves can be located
anywhere but we recommend they are within a run subdirectory of the user’s project
directory, i.e.$HOME/OpenFOAM/${USER}-2.2.0 as described at the beginning of chap-
ter 2. One advantage of this is that the $FOAM RUN environment variable is set to
$HOME/OpenFOAM/${USER}-2.2.0/run by default; the user can quickly move to that
directory by executing a preset alias, run, at the command line.
The tutorial cases that accompany the OpenFOAM distribution provide useful exam-
ples of the case directory structures. The tutorials are located in the $FOAM TUTORIALS
directory, reached quickly by executing the tut alias at the command line. Users can view
tutorial examples at their leisure while reading this chapter.
4.1 File structure of OpenFOAM cases
The basic directory structure for a OpenFOAM case, that contains the minimum set of
ﬁles required to run an application, is shown in Figure 4.1 and described as follows:
<case>
system
controlDict
fvSchemes
polyMesh
points
cells
faces
...Properties
boundary
constant
time directories
fvSolution
see section 4.3
see section 4.4
see section 4.5
see section 5.1.2
see section 4.2.8
see chapter 7
Figure 4.1: Case directory structure
U-104 OpenFOAM cases
A constant directory that contains a full description of the case mesh in a subdirec-
tory polyMesh and ﬁles specifying physical properties for the application concerned,
e.g.transportProperties.
A system directory for setting parameters associated with the solution procedure itself.
It contains at least the following 3 ﬁles: controlDict where run control parameters are
set including start/end time, time step and parameters for data output; fvSchemes
where discretisation schemes used in the solution may be selected at run-time; and,
fvSolution where the equation solvers, tolerances and other algorithm controls are
set for the run.
The ‘time’ directories containing individual ﬁles of data for particular ﬁelds. The
data can be: either, initial values and boundary conditions that the user must
specify to deﬁne the problem; or, results written to ﬁle by OpenFOAM. Note that
the OpenFOAM ﬁelds must always be initialised, even when the solution does not
strictly require it, as in steady-state problems. The name of each time directory is
based on the simulated time at which the data is written and is described fully in
section 4.3. It is suﬃcient to say now that since we usually start our simulations
at time t = 0, the initial conditions are usually stored in a directory named 0 or
0.000000e+00, depending on the name format speciﬁed. For example, in the cavity
tutorial, the velocity ﬁeld U and pressure ﬁeld p are initialised from ﬁles 0/U and
0/p respectively.
4.2 Basic input/output ﬁle format
OpenFOAM needs to read a range of data structures such as strings, scalars, vectors,
tensors, lists and ﬁelds. The input/output (I/O) format of ﬁles is designed to be extremely
ﬂexible to enable the user to modify the I/O in OpenFOAM applications as easily as
possible. The I/O follows a simple set of rules that make the ﬁles extremely easy to
understand, in contrast to many software packages whose ﬁle format may not only be
diﬃcult to understand intuitively but also not be published anywhere. The OpenFOAM
ﬁle format is described in the following sections.
4.2.1 General syntax rules
The format follows some general principles of C++ source code.
• Files have free form, with no particular meaning assigned to any column and no
need to indicate continuation across lines.
• Lines have no particular meaning except to a // comment delimiter which makes
OpenFOAM ignore any text that follows it until the end of line.
• A comment over multiple lines is done by enclosing the text between /* and */
delimiters.
4.2.2 Dictionaries
OpenFOAM uses dictionaries as the most common means of specifying data. A dictionary
is an entity that contains data entries that can be retrieved by the I/O by means of
keywords. The keyword entries follow the general format
Open∇FOAM-2.2.0
4.2 Basic input/output ﬁle format U-105
<keyword> <dataEntry1> ... <dataEntryN>;
Most entries are single data entries of the form:
<keyword> <dataEntry>;
Most OpenFOAM data ﬁles are themselves dictionaries containing a set of keyword en-
tries. Dictionaries provide the means for organising entries into logical categories and can
be speciﬁed hierarchically so that any dictionary can itself contain one or more dictionary
entries. The format for a dictionary is to specify the dictionary name followed by keyword
entries enclosed in curly braces {} as follows
<dictionaryName>
{
... keyword entries ...
}
4.2.3 The data ﬁle header
All data ﬁles that are read and written by OpenFOAM begin with a dictionary named
FoamFile containing a standard set of keyword entries, listed in Table 4.1. The table
Keyword Description Entry
version I/O format version 2.0
format Data format ascii / binary
location Path to the ﬁle, in "..." (optional)
class OpenFOAM class constructed from the
data ﬁle concerned
typically dictionary or a
ﬁeld, e.g.volVectorField
object Filename e.g.controlDict
Table 4.1: Header keywords entries for data ﬁles.
provides brief descriptions of each entry, which is probably suﬃcient for most entries with
the notable exception of class. The class entry is the name of the C++ class in the
OpenFOAM library that will be constructed from the data in the ﬁle. Without knowledge
of the underlying code which calls the ﬁle to be read, and knowledge of the OpenFOAM
classes, the user will probably be unable to surmise the class entry correctly. However,
most data ﬁles with simple keyword entries are read into an internal dictionary class and
therefore the class entry is dictionary in those cases.
The following example shows the use of keywords to provide data for a case using the
types of entry described so far. The extract, from an fvSolution dictionary ﬁle, contains
2 dictionaries, solvers and PISO. The solvers dictionary contains multiple data entries for
solver and tolerances for each of the pressure and velocity equations, represented by the
p and U keywords respectively; the PISO dictionary contains algorithm controls.
17
18 solvers
19 {
20 p
21 {
22 solver PCG;
23 preconditioner DIC;
24 tolerance 1e-06;
Open∇FOAM-2.2.0
U-106 OpenFOAM cases
25 relTol 0;
26 }
27
28 U
29 {
30 solver PBiCG;
31 preconditioner DILU;
32 tolerance 1e-05;
33 relTol 0;
34 }
35 }
36
37 PISO
38 {
39 nCorrectors 2;
40 nNonOrthogonalCorrectors 0;
41 pRefCell 0;
42 pRefValue 0;
43 }
44
45
46 // ************************************************************************* //
4.2.4 Lists
OpenFOAM applications contain lists, e.g. a list of vertex coordinates for a mesh de-
scription. Lists are commonly found in I/O and have a format of their own in which the
entries are contained within round braces ( ). There is also a choice of format preceeding
the round braces:
simple the keyword is followed immediately by round braces
<listName>
(
... entries ...
);
numbered the keyword is followed by the number of elements <n> in the list
<listName>
<n>
(
... entries ...
);
token identiﬁer the keyword is followed by a class name identiﬁer Label<Type> where
<Type> states what the list contains, e.g. for a list of scalar elements is
<listName>
List<scalar>
<n> // optional
(
... entries ...
);
Note that <scalar> in List<scalar> is not a generic name but the actual text that
should be entered.
The simple format is a convenient way of writing a list. The other formats allow
the code to read the data faster since the size of the list can be allocated to memory
in advance of reading the data. The simple format is therefore preferred for short lists,
where read time is minimal, and the other formats are preferred for long lists.
Open∇FOAM-2.2.0
4.2 Basic input/output ﬁle format U-107
4.2.5 Scalars, vectors and tensors
A scalar is a single number represented as such in a data ﬁle. A vector is a VectorSpace
of rank 1 and dimension 3, and since the number of elements is always ﬁxed to 3, the
simple List format is used. Therefore a vector (1.0, 1.1, 1.2) is written:
(1.0 1.1 1.2)
In OpenFOAM, a tensor is a VectorSpace of rank 2 and dimension 3 and therefore the
data entries are always ﬁxed to 9 real numbers. Therefore the identity tensor can be
written:
(
1 0 0
0 1 0
0 0 1
)
This example demonstrates the way in which OpenFOAM ignores the line return is so
that the entry can be written over multiple lines. It is treated no diﬀerently to listing the
numbers on a single line:
( 1 0 0 0 1 0 0 0 1 )
4.2.6 Dimensional units
In continuum mechanics, properties are represented in some chosen units, e.g. mass in
kilograms (kg), volume in cubic metres (m3
), pressure in Pascals (kg m−1
s−2
). Algebraic
operations must be performed on these properties using consistent units of measurement;
in particular, addition, subtraction and equality are only physically meaningful for prop-
erties of the same dimensional units. As a safeguard against implementing a meaningless
operation, OpenFOAM attaches dimensions to ﬁeld data and physical properties and
performs dimension checking on any tensor operation.
The I/O format for a dimensionSet is 7 scalars delimited by square brackets, e.g.
[0 2 -1 0 0 0 0]
No. Property SI unit USCS unit
1 Mass kilogram (kg) pound-mass (lbm)
2 Length metre (m) foot (ft)
3 Time — — — — second (s) — — — —
4 Temperature Kelvin (K) degree Rankine (◦
R)
5 Quantity kilogram-mole (kgmol) pound-mole (lbmol)
6 Current — — — — ampere (A) — — — —
7 Luminous intensity — — — — candela (cd) — — — —
Table 4.2: Base units for SI and USCS
where each of the values corresponds to the power of each of the base units of measure-
ment listed in Table 4.2. The table gives the base units for the Syst`eme International
(SI) and the United States Customary System (USCS) but OpenFOAM can be used
Open∇FOAM-2.2.0
U-108 OpenFOAM cases
with any system of units. All that is required is that the input data is correct for the
chosen set of units. It is particularly important to recognise that OpenFOAM requires
some dimensioned physical constants, e.g. the Universal Gas Constant R, for certain cal-
culations, e.g. thermophysical modelling. These dimensioned constants are speciﬁed in
a DimensionedConstant sub-dictionary of main controlDict ﬁle of the OpenFOAM instal-
lation ($WM PROJECT DIR/etc/controlDict). By default these constants are set in SI
units. Those wishing to use the USCS or any other system of units should modify these
constants to their chosen set of units accordingly.
4.2.7 Dimensioned types
Physical properties are typically speciﬁed with their associated dimensions. These entries
have the format that the following example of a dimensionedScalar demonstrates:
nu nu [0 2 -1 0 0 0 0] 1;
The ﬁrst nu is the keyword; the second nu is the word name stored in class word, usually
chosen to be the same as the keyword; the next entry is the dimensionSet and the ﬁnal
entry is the scalar value.
4.2.8 Fields
Much of the I/O data in OpenFOAM are tensor ﬁelds, e.g. velocity, pressure data, that
are read from and written into the time directories. OpenFOAM writes ﬁeld data using
keyword entries as described in Table 4.3.
Keyword Description Example
dimensions Dimensions of ﬁeld [1 1 -2 0 0 0 0]
internalField Value of internal ﬁeld uniform (1 0 0)
boundaryField Boundary ﬁeld see ﬁle listing in section 4.2.8
Table 4.3: Main keywords used in ﬁeld dictionaries.
The data begins with an entry for its dimensions. Following that, is the internalField,
described in one of the following ways.
Uniform ﬁeld a single value is assigned to all elements within the ﬁeld, taking the form:
internalField uniform <entry>;
Nonuniform ﬁeld each ﬁeld element is assigned a unique value from a list, taking the
following form where the token identiﬁer form of list is recommended:
internalField nonuniform <List>;
The boundaryField is a dictionary containing a set of entries whose names correspond
to each of the names of the boundary patches listed in the boundary ﬁle in the polyMesh
directory. Each patch entry is itself a dictionary containing a list of keyword entries.
The compulsory entry, type, describes the patch ﬁeld condition speciﬁed for the ﬁeld.
The remaining entries correspond to the type of patch ﬁeld condition selected and can
Open∇FOAM-2.2.0
4.2 Basic input/output ﬁle format U-109
typically include ﬁeld data specifying initial conditions on patch faces. A selection of
patch ﬁeld conditions available in OpenFOAM are listed in Table 5.3 and Table 5.4 with
a description and the data that must be speciﬁed with it. Example ﬁeld dictionary entries
for velocity U are shown below:
17 dimensions [0 1 -1 0 0 0 0];
18
19 internalField uniform (0 0 0);
20
21 boundaryField
22 {
23 movingWall
24 {
25 type fixedValue;
26 value uniform (1 0 0);
27 }
28
29 fixedWalls
30 {
31 type fixedValue;
32 value uniform (0 0 0);
33 }
34
35 frontAndBack
36 {
37 type empty;
38 }
39 }
40
41 // ************************************************************************* //
4.2.9 Directives and macro substitutions
There is additional ﬁle syntax that oﬀers great ﬂexibility for the setting up of OpenFOAM
case ﬁles, namely directives and macro substitutions. Directives are commands that can
be contained within case ﬁles that begin with the hash (#) symbol. Macro substitutions
begin with the dollar ($) symbol.
At present there are 4 directive commands available in OpenFOAM:
#include "<fileName>" (or #includeIfPresent "<fileName>" reads the ﬁle of name
<ﬁleName>;
#inputMode has two options: merge, which merges keyword entries in successive dictio-
naries, so that a keyword entry speciﬁed in one place will be overridden by a later
speciﬁcation of the same keyword entry; overwrite, which overwrites the contents
of an entire dictionary; generally, use merge;
#remove <keywordEntry> removes any included keyword entry; can take a word or
regular expression;
#codeStream followed by verbatim C++ code, compiles, loads and executes the code
on-the-ﬂy to generate the entry.
4.2.10 The #include and #inputMode directives
For example, let us say a user wishes to set an initial value of pressure once to be used
as the internal ﬁeld and initial value at a boundary. We could create a ﬁle, e.g. named
initialConditions, which contains the following entries:
pressure 1e+05;
#inputMode merge
Open∇FOAM-2.2.0
U-110 OpenFOAM cases
In order to use this pressure for both the internal and initial boundary ﬁelds, the user
would simply include the following macro substitutions in the pressure ﬁeld ﬁle p:
#include "initialConditions"
internalField uniform $pressure;
boundaryField
{
patch1
{
type fixedValue;
value $internalField;
}
}
This is a fairly trivial example that simply demonstrates how this functionality works.
However, the functionality can be used in many, more powerful ways particularly as a
means of generalising case data to suit the user’s needs. For example, if a user has a set
of cases that require the same RAS turbulence model settings, a single ﬁle can be created
with those settings which is simply included in the RASProperties ﬁle of each case. Macro
substitutions can extend well beyond a single value so that, for example, sets of boundary
conditions can be predeﬁned and called by a single macro. The extent to which such
functionality can be used is almost endless.
4.2.11 The #codeStream directive
The #codeStream directive takes C++ code which is compiled and executed to deliver
the dictionary entry. The code and compilation instructions are speciﬁed through the
following keywords.
• code: speciﬁes the code, called with arguments OStream& os and const dictionary&
dict which the user can use in the code, e.g. to lookup keyword entries from within
the current case dictionary (ﬁle).
• codeInclude (optional): speciﬁes additional C++ #include statements to include
OpenFOAM ﬁles.
• codeOptions (optional): speciﬁes any extra compilation ﬂags to be added to EXE INC
in Make/options.
• codeLibs (optional): speciﬁes any extra compilation ﬂags to be added to LIB LIBS
in Make/options.
Code, like any string, can be written across multiple lines by enclosing it within hash-
bracket delimiters, i.e. #{...#}. Anything in between these two delimiters becomes a
string with all newlines, quotes, etc. preserved.
An example of #codeStream is given below. The code in the controlDict ﬁle looks up
dictionary entries and does a simple calculation for the write interval:
startTime 0;
endTime 100;
...
writeInterval #codeStream
{
code
#{
Open∇FOAM-2.2.0
4.3 Time and data input/output control U-111
scalar start = readScalar(dict.lookup("startTime"));
scalar end = readScalar(dict.lookup("endTime"));
label nDumps = 5;
os << ((end - start)/nDumps);
#};
};
4.3 Time and data input/output control
The OpenFOAM solvers begin all runs by setting up a database. The database controls
I/O and, since output of data is usually requested at intervals of time during the run, time
is an inextricable part of the database. The controlDict dictionary sets input parameters
essential for the creation of the database. The keyword entries in controlDict are listed
in Table 4.4. Only the time control and writeInterval entries are truly compulsory,
with the database taking default values indicated by † in Table 4.4 for any of the optional
entries that are omitted.
Time control
startFrom Controls the start time of the simulation.
- firstTime Earliest time step from the set of time directories.
- startTime Time speciﬁed by the startTime keyword entry.
- latestTime Most recent time step from the set of time directories.
startTime Start time for the simulation with startFrom startTime;
stopAt Controls the end time of the simulation.
- endTime Time speciﬁed by the endTime keyword entry.
- writeNow Stops simulation on completion of current time step and writes
data.
- noWriteNow Stops simulation on completion of current time step and does not
write out data.
- nextWrite Stops simulation on completion of next scheduled write time, spec-
iﬁed by writeControl.
endTime End time for the simulation when stopAt endTime; is speciﬁed.
deltaT Time step of the simulation.
Data writing
writeControl Controls the timing of write output to ﬁle.
- timeStep† Writes data every writeInterval time steps.
- runTime Writes data every writeInterval seconds of simulated time.
- adjustableRunTime Writes data every writeInterval seconds of simulated time,
adjusting the time steps to coincide with the writeInterval if
necessary — used in cases with automatic time step adjustment.
- cpuTime Writes data every writeInterval seconds of CPU time.
- clockTime Writes data out every writeInterval seconds of real time.
writeInterval Scalar used in conjunction with writeControl described above.
Continued on next page
Open∇FOAM-2.2.0
U-112 OpenFOAM cases
Continued from previous page
purgeWrite Integer representing a limit on the number of time directories that
are stored by overwriting time directories on a cyclic basis. Exam-
ple of t0 = 5s, ∆t = 1s and purgeWrite 2;: data written into 2
directories, 6 and 7, before returning to write the data at 8 s in 6,
data at 9 s into 7, etc.
To disable the time directory limit, specify purgeWrite 0;†
For steady-state solutions, results from previous iterations can be
continuously overwritten by specifying purgeWrite 1;
writeFormat Speciﬁes the format of the data ﬁles.
- ascii† ASCII format, written to writePrecision signiﬁcant ﬁgures.
- binary Binary format.
writePrecision Integer used in conjunction with writeFormat described above, 6†
by default
writeCompression Speciﬁes the compression of the data ﬁles.
- uncompressed No compression.†
- compressed gzip compression.
timeFormat Choice of format of the naming of the time directories.
- fixed ±m.dddddd where the number of ds is set by timePrecision.
- scientific ±m.dddddde±xx where the number of ds is set by timePrecision.
- general† Speciﬁes scientific format if the exponent is less than -4 or
greater than or equal to that speciﬁed by timePrecision.
timePrecision Integer used in conjunction with timeFormat described above, 6†
by default
graphFormat Format for graph data written by an application.
- raw† Raw ASCII format in columns.
- gnuplot Data in gnuplot format.
- xmgr Data in Grace/xmgr format.
- jplot Data in jPlot format.
Adjustable time step
adjustTimeStep yes†/no switch for OpenFOAM to adjust the time step during
the simulation, usually according to. . .
maxCo Maximum Courant number, e.g. 0.5
Data reading
runTimeModifiable yes†/no switch for whether dictionaries, e.g.controlDict, are re-
read by OpenFOAM at the beginning of each time step.
Run-time loadable functionality
libs List of additional libraries (on $LD LIBRARY PATH) to be loaded
at run-time, e.g.( "libUser1.so" "libUser2.so" )
Continued on next page
Open∇FOAM-2.2.0
4.4 Numerical schemes U-113
Continued from previous page
functions List of functions, e.g. probes to be loaded at run-time; see examples
in $FOAM TUTORIALS
† denotes default entry if associated keyword is omitted.
Table 4.4: Keyword entries in the controlDict dictionary.
Example entries from a controlDict dictionary are given below:
17
18 application icoFoam;
19
20 startFrom startTime;
21
22 startTime 0;
23
24 stopAt endTime;
25
26 endTime 0.5;
27
28 deltaT 0.005;
29
30 writeControl timeStep;
31
32 writeInterval 20;
33
34 purgeWrite 0;
35
36 writeFormat ascii;
37
38 writePrecision 6;
39
40 writeCompression off;
41
42 timeFormat general;
43
44 timePrecision 6;
45
46 runTimeModifiable true;
47
48
49 // ************************************************************************* //
4.4 Numerical schemes
The fvSchemes dictionary in the system directory sets the numerical schemes for terms,
such as derivatives in equations, that appear in applications being run. This section
describes how to specify the schemes in the fvSchemes dictionary.
The terms that must typically be assigned a numerical scheme in fvSchemes range from
derivatives, e.g. gradient ∇, and interpolations of values from one set of points to another.
The aim in OpenFOAM is to oﬀer an unrestricted choice to the user. For example, while
linear interpolation is eﬀective in many cases, OpenFOAM oﬀers complete freedom to
choose from a wide selection of interpolation schemes for all interpolation terms.
The derivative terms further exemplify this freedom of choice. The user ﬁrst has a
choice of discretisation practice where standard Gaussian ﬁnite volume integration is the
common choice. Gaussian integration is based on summing values on cell faces, which
must be interpolated from cell centres. The user again has a completely free choice
of interpolation scheme, with certain schemes being speciﬁcally designed for particular
derivative terms, especially the convection divergence ∇ • terms.
The set of terms, for which numerical schemes must be speciﬁed, are subdivided within
the fvSchemes dictionary into the categories listed in Table 4.5. Each keyword in Table 4.5
is the name of a sub-dictionary which contains terms of a particular type, e.g.gradSchemes
Open∇FOAM-2.2.0
U-114 OpenFOAM cases
contains all the gradient derivative terms such as grad(p) (which represents ∇p). Further
examples can be seen in the extract from an fvSchemes dictionary below:
Keyword Category of mathematical terms
interpolationSchemes Point-to-point interpolations of values
snGradSchemes Component of gradient normal to a cell face
gradSchemes Gradient ∇
divSchemes Divergence ∇ •
laplacianSchemes Laplacian ∇2
timeScheme First and second time derivatives ∂/∂t, ∂2
/∂2
t
fluxRequired Fields which require the generation of a ﬂux
Table 4.5: Main keywords used in fvSchemes.
17
18 ddtSchemes
19 {
20 default Euler;
21 }
22
23 gradSchemes
24 {
25 default Gauss linear;
26 grad(p) Gauss linear;
27 }
28
29 divSchemes
30 {
31 default none;
32 div(phi,U) Gauss linear;
33 }
34
35 laplacianSchemes
36 {
37 default none;
38 laplacian(nu,U) Gauss linear orthogonal;
39 laplacian((1|A(U)),p) Gauss linear orthogonal;
40 }
41
42 interpolationSchemes
43 {
44 default linear;
45 interpolate(HbyA) linear;
46 }
47
48 snGradSchemes
49 {
50 default orthogonal;
51 }
52
53 fluxRequired
54 {
55 default no;
56 p ;
57 }
58
59
60 // ************************************************************************* //
The example shows that the fvSchemes dictionary contains the following:
• 6 . . . Schemes subdictionaries containing keyword entries for each term speciﬁed
within including: a default entry; other entries whose names correspond to a word
identiﬁer for the particular term speciﬁed, e.g.grad(p) for ∇p
• a ﬂuxRequired sub-dictionary containing ﬁelds for which the ﬂux is generated in the
application, e.g.p in the example.
Open∇FOAM-2.2.0
4.4 Numerical schemes U-115
If a default scheme is speciﬁed in a particular . . . Schemes sub-dictionary, it is assigned
to all of the terms to which the sub-dictionary refers, e.g. specifying a default in grad-
Schemes sets the scheme for all gradient terms in the application, e.g. ∇p, ∇U. When
a default is speciﬁed, it is not necessary to specify each speciﬁc term itself in that sub-
dictionary, i.e. the entries for grad(p), grad(U) in this example. However, if any of these
terms are included, the speciﬁed scheme overrides the default scheme for that term.
Alternatively the user may insist on no default scheme by the none entry. In this
instance the user is obliged to specify all terms in that sub-dictionary individually. Setting
default to none may appear superﬂuous since default can be overridden. However,
specifying none forces the user to specify all terms individually which can be useful to
remind the user which terms are actually present in the application.
The following sections describe the choice of schemes for each of the categories of
terms in Table 4.5.
4.4.1 Interpolation schemes
The interpolationSchemes sub-dictionary contains terms that are interpolations of val-
ues typically from cell centres to face centres. A selection of interpolation schemes in
OpenFOAM are listed in Table 4.6, being divided into 4 categories: 1 category of gen-
eral schemes; and, 3 categories of schemes used primarily in conjunction with Gaussian
discretisation of convection (divergence) terms in ﬂuid ﬂow, described in section 4.4.5.
It is highly unlikely that the user would adopt any of the convection-speciﬁc schemes
for general ﬁeld interpolations in the interpolationSchemes sub-dictionary, but, as valid
interpolation schemes, they are described here rather than in section 4.4.5. Note that
additional schemes such as UMIST are available in OpenFOAM but only those schemes
that are generally recommended are listed in Table 4.6.
A general scheme is simply speciﬁed by quoting the keyword and entry, e.g. a linear
scheme is speciﬁed as default by:
default linear;
The convection-speciﬁc schemes calculate the interpolation based on the ﬂux of the
ﬂow velocity. The speciﬁcation of these schemes requires the name of the ﬂux ﬁeld
on which the interpolation is based; in most OpenFOAM applications this is phi, the
name commonly adopted for the surfaceScalarField velocity ﬂux φ. The 3 categories of
convection-speciﬁc schemes are referred to in this text as: general convection; normalised
variable (NV); and, total variation diminishing (TVD). With the exception of the blended
scheme, the general convection and TVD schemes are speciﬁed by the scheme and ﬂux,
e.g. an upwind scheme based on a ﬂux phi is speciﬁed as default by:
default upwind phi;
Some TVD/NVD schemes require a coeﬃcient ψ, 0 ≤ ψ ≤ 1 where ψ = 1 corresponds
to TVD conformance, usually giving best convergence and ψ = 0 corresponds to best
accuracy. Running with ψ = 1 is generally recommended. A limitedLinear scheme
based on a ﬂux phi with ψ = 1.0 is speciﬁed as default by:
default limitedLinear 1.0 phi;
Open∇FOAM-2.2.0
U-116 OpenFOAM cases
4.4.1.1 Schemes for strictly bounded scalar ﬁelds
There are enhanced versions of some of the limited schemes for scalars that need to be
strictly bounded. To bound between user-speciﬁed limits, the scheme name should be
preceded by the word limited and followed by the lower and upper limits respectively.
For example, to bound the vanLeer scheme strictly between -2 and 3, the user would
specify:
default limitedVanLeer -2.0 3.0;
There are specialised versions of these schemes for scalar ﬁelds that are commonly bounded
between 0 and 1. These are selected by adding 01 to the name of the scheme. For example,
to bound the vanLeer scheme strictly between 0 and 1, the user would specify:
default vanLeer01;
Strictly bounded versions are available for the following schemes: limitedLinear, vanLeer,
Gamma, limitedCubic, MUSCL and SuperBee.
4.4.1.2 Schemes for vector ﬁelds
There are improved versions of some of the limited schemes for vector ﬁelds in which
the limiter is formulated to take into account the direction of the ﬁeld. These schemes
are selected by adding V to the name of the general scheme, e.g.limitedLinearV for
limitedLinear. ‘V’ versions are available for the following schemes: limitedLinearV,
vanLeerV, GammaV, limitedCubicV and SFCDV.
Centred schemes
linear Linear interpolation (central diﬀerencing)
cubicCorrection Cubic scheme
midPoint Linear interpolation with symmetric weighting
Upwinded convection schemes
upwind Upwind diﬀerencing
linearUpwind Linear upwind diﬀerencing
skewLinear Linear with skewness correction
filteredLinear2 Linear with ﬁltering for high-frequency ringing
TVD schemes
limitedLinear limited linear diﬀerencing
vanLeer van Leer limiter
MUSCL MUSCL limiter
limitedCubic Cubic limiter
NVD schemes
SFCD Self-ﬁltered central diﬀerencing
Gamma ψ Gamma diﬀerencing
Table 4.6: Interpolation schemes.
Open∇FOAM-2.2.0
4.4 Numerical schemes U-117
4.4.2 Surface normal gradient schemes
The snGradSchemes sub-dictionary contains surface normal gradient terms. A surface
normal gradient is evaluated at a cell face; it is the component, normal to the face, of the
gradient of values at the centres of the 2 cells that the face connects. A surface normal
gradient may be speciﬁed in its own right and is also required to evaluate a Laplacian
term using Gaussian integration.
The available schemes are listed in Table 4.7 and are speciﬁed by simply quoting the
keyword and entry, with the exception of limited which requires a coeﬃcient ψ, 0 ≤ ψ ≤
1 where
ψ =



0 corresponds to uncorrected,
0.333 non-orthogonal correction ≤ 0.5 × orthogonal part,
0.5 non-orthogonal correction ≤ orthogonal part,
1 corresponds to corrected.
(4.1)
A limited scheme with ψ = 0.5 is therefore speciﬁed as default by:
default limited 0.5;
Scheme Description
corrected Explicit non-orthogonal correction
uncorrected No non-orthogonal correction
limited ψ Limited non-orthogonal correction
bounded Bounded correction for positive scalars
fourth Fourth order
Table 4.7: Surface normal gradient schemes.
4.4.3 Gradient schemes
The gradSchemes sub-dictionary contains gradient terms. The discretisation scheme for
each term can be selected from those listed in Table 4.8.
Discretisation scheme Description
Gauss <interpolationScheme> Second order, Gaussian integration
leastSquares Second order, least squares
fourth Fourth order, least squares
cellLimited <gradScheme> Cell limited version of one of the above schemes
faceLimited <gradScheme> Face limited version of one of the above schemes
Table 4.8: Discretisation schemes available in gradSchemes.
The discretisation scheme is suﬃcient to specify the scheme completely in the cases
of leastSquares and fourth, e.g.
grad(p) leastSquares;
Open∇FOAM-2.2.0
U-118 OpenFOAM cases
The Gauss keyword speciﬁes the standard ﬁnite volume discretisation of Gaussian
integration which requires the interpolation of values from cell centres to face centres.
Therefore, the Gauss entry must be followed by the choice of interpolation scheme from
Table 4.6. It would be extremely unusual to select anything other than general interpo-
lation schemes and in most cases the linear scheme is an eﬀective choice, e.g.
grad(p) Gauss linear;
Limited versions of any of the 3 base gradient schemes — Gauss, leastSquares and
fourth — can be selected by preceding the discretisation scheme by cellLimited (or
faceLimited), e.g. a cell limited Gauss scheme
grad(p) cellLimited Gauss linear 1;
4.4.4 Laplacian schemes
The laplacianSchemes sub-dictionary contains Laplacian terms. Let us discuss the syntax
of the entry in reference to a typical Laplacian term found in ﬂuid dynamics, ∇ • (ν∇U),
given the word identiﬁer laplacian(nu,U). The Gauss scheme is the only choice of dis-
cretisation and requires a selection of both an interpolation scheme for the diﬀusion
coeﬃcient, i.e. ν in our example, and a surface normal gradient scheme, i.e. ∇U. To
summarise, the entries required are:
Gauss <interpolationScheme> <snGradScheme>
The interpolation scheme is selected from Table 4.6, the typical choices being from the
general schemes and, in most cases, linear. The surface normal gradient scheme is
selected from Table 4.7; the choice of scheme determines numerical behaviour as described
in Table 4.9. A typical entry for our example Laplacian term would be:
laplacian(nu,U) Gauss linear corrected;
Scheme Numerical behaviour
corrected Unbounded, second order, conservative
uncorrected Bounded, ﬁrst order, non-conservative
limited ψ Blend of corrected and uncorrected
bounded First order for bounded scalars
fourth Unbounded, fourth order, conservative
Table 4.9: Behaviour of surface normal schemes used in laplacianSchemes.
4.4.5 Divergence schemes
The divSchemes sub-dictionary contains divergence terms. Let us discuss the syntax of
the entry in reference to a typical convection term found in ﬂuid dynamics ∇ • (ρUU),
which in OpenFOAM applications is commonly given the identiﬁer div(phi,U), where
phi refers to the ﬂux φ = ρU.
The Gauss scheme is the only choice of discretisation and requires a selection of the
interpolation scheme for the dependent ﬁeld, i.e. U in our example. To summarise, the
entries required are:
Open∇FOAM-2.2.0
4.4 Numerical schemes U-119
Gauss <interpolationScheme>
The interpolation scheme is selected from the full range of schemes in Table 4.6, both
general and convection-speciﬁc. The choice critically determines numerical behaviour as
described in Table 4.10. The syntax here for specifying convection-speciﬁc interpolation
schemes does not include the ﬂux as it is already known for the particular term, i.e. for
div(phi,U), we know the ﬂux is phi so specifying it in the interpolation scheme would
only invite an inconsistency. Speciﬁcation of upwind interpolation in our example would
therefore be:
div(phi,U) Gauss upwind;
Scheme Numerical behaviour
linear Second order, unbounded
skewLinear Second order, (more) unbounded, skewness correction
cubicCorrected Fourth order, unbounded
upwind First order, bounded
linearUpwind First/second order, bounded
QUICK First/second order, bounded
TVD schemes First/second order, bounded
SFCD Second order, bounded
NVD schemes First/second order, bounded
Table 4.10: Behaviour of interpolation schemes used in divSchemes.
4.4.6 Time schemes
The ﬁrst time derivative (∂/∂t) terms are speciﬁed in the ddtSchemes sub-dictionary. The
discretisation scheme for each term can be selected from those listed in Table 4.11.
There is an oﬀ-centering coeﬃcient ψ with the CrankNicholson scheme that blends
it with the Euler scheme. A coeﬃcient of ψ = 1 corresponds to pure CrankNicholson
and and ψ = 0 corresponds to pure Euler. The blending coeﬃcient can help to improve
stability in cases where pure CrankNicholson are unstable.
Scheme Description
Euler First order, bounded, implicit
localEuler Local-time step, ﬁrst order, bounded, implicit
CrankNicholson ψ Second order, bounded, implicit
backward Second order, implicit
steadyState Does not solve for time derivatives
Table 4.11: Discretisation schemes available in ddtSchemes.
When specifying a time scheme it must be noted that an application designed for
transient problems will not necessarily run as steady-state and visa versa. For example
the solution will not converge if steadyState is speciﬁed when running icoFoam, the
transient, laminar incompressible ﬂow code; rather, simpleFoam should be used for steady-
state, incompressible ﬂow.
Open∇FOAM-2.2.0
U-120 OpenFOAM cases
Any second time derivative (∂2
/∂t2
) terms are speciﬁed in the d2dt2Schemes sub-
dictionary. Only the Euler scheme is available for d2dt2Schemes.
4.4.7 Flux calculation
The ﬂuxRequired sub-dictionary lists the ﬁelds for which the ﬂux is generated in the
application. For example, in many ﬂuid dynamics applications the ﬂux is generated after
solving a pressure equation, in which case the ﬂuxRequired sub-dictionary would simply
be entered as follows, p being the word identiﬁer for pressure:
fluxRequired
{
p;
}
4.5 Solution and algorithm control
The equation solvers, tolerances and algorithms are controlled from the fvSolution dic-
tionary in the system directory. Below is an example set of entries from the fvSolution
dictionary required for the icoFoam solver.
17
18 solvers
19 {
20 p
21 {
22 solver PCG;
23 preconditioner DIC;
24 tolerance 1e-06;
25 relTol 0;
26 }
27
28 U
29 {
30 solver PBiCG;
31 preconditioner DILU;
32 tolerance 1e-05;
33 relTol 0;
34 }
35 }
36
37 PISO
38 {
39 nCorrectors 2;
40 nNonOrthogonalCorrectors 0;
41 pRefCell 0;
42 pRefValue 0;
43 }
44
45
46 // ************************************************************************* //
fvSolution contains a set of subdictionaries that are speciﬁc to the solver being run. How-
ever, there is a small set of standard subdictionaries that cover most of those used by
the standard solvers. These subdictionaries include solvers, relaxationFactors, PISO and
SIMPLE which are described in the remainder of this section.
4.5.1 Linear solver control
The ﬁrst sub-dictionary in our example, and one that appears in all solver applications,
is solvers. It speciﬁes each linear-solver that is used for each discretised equation; it
is emphasised that the term linear-solver refers to the method of number-crunching to
solve the set of linear equations, as opposed to application solver which describes the set
Open∇FOAM-2.2.0
4.5 Solution and algorithm control U-121
of equations and algorithms to solve a particular problem. The term ‘linear-solver’ is
abbreviated to ‘solver’ in much of the following discussion; we hope the context of the
term avoids any ambiguity.
The syntax for each entry within solvers uses a keyword that is the word relating to the
variable being solved in the particular equation. For example, icoFoam solves equations
for velocity U and pressure p, hence the entries for U and p. The keyword is followed
by a dictionary containing the type of solver and the parameters that the solver uses.
The solver is selected through the solver keyword from the choice in OpenFOAM, listed
in Table 4.12. The parameters, including tolerance, relTol, preconditioner, etc. are
described in following sections.
Solver Keyword
Preconditioned (bi-)conjugate gradient PCG/PBiCG†
Solver using a smoother smoothSolver
Generalised geometric-algebraic multi-grid GAMG
Diagonal solver for explicit systems diagonal
†PCG for symmetric matrices, PBiCG for asymmetric
Table 4.12: Linear solvers.
The solvers distinguish between symmetric matrices and asymmetric matrices. The
symmetry of the matrix depends on the structure of the equation being solved and, while
the user may be able to determine this, it is not essential since OpenFOAM will produce
an error message to advise the user if an inappropriate solver has been selected, e.g.
--> FOAM FATAL IO ERROR : Unknown asymmetric matrix solver PCG
Valid asymmetric matrix solvers are :
3
(
PBiCG
smoothSolver
GAMG
)
4.5.1.1 Solution tolerances
The sparse matrix solvers are iterative, i.e. they are based on reducing the equation
residual over a succession of solutions. The residual is ostensibly a measure of the error
in the solution so that the smaller it is, the more accurate the solution. More precisely,
the residual is evaluated by substituting the current solution into the equation and taking
the magnitude of the diﬀerence between the left and right hand sides; it is also normalised
to make it independent of the scale of the problem being analysed.
Before solving an equation for a particular ﬁeld, the initial residual is evaluated based
on the current values of the ﬁeld. After each solver iteration the residual is re-evaluated.
The solver stops if either of the following conditions are reached:
• the residual falls below the solver tolerance, tolerance;
• the ratio of current to initial residuals falls below the solver relative tolerance,
relTol;
• the number of iterations exceeds a maximum number of iterations, maxIter;
Open∇FOAM-2.2.0
U-122 OpenFOAM cases
The solver tolerance should represent the level at which the residual is small enough
that the solution can be deemed suﬃciently accurate. The solver relative tolerance limits
the relative improvement from initial to ﬁnal solution. In transient simulations, it is usual
to set the solver relative tolerance to 0 to force the solution to converge to the solver
tolerance in each time step. The tolerances, tolerance and relTol must be speciﬁed in
the dictionaries for all solvers; maxIter is optional.
4.5.1.2 Preconditioned conjugate gradient solvers
There are a range of options for preconditioning of matrices in the conjugate gradient
solvers, represented by the preconditioner keyword in the solver dictionary. The pre-
conditioners are listed in Table 4.13.
Preconditioner Keyword
Diagonal incomplete-Cholesky (symmetric) DIC
Faster diagonal incomplete-Cholesky (DIC with caching) FDIC
Diagonal incomplete-LU (asymmetric) DILU
Diagonal diagonal
Geometric-algebraic multi-grid GAMG
No preconditioning none
Table 4.13: Preconditioner options.
4.5.1.3 Smooth solvers
The solvers that use a smoother require the smoother to be speciﬁed. The smoother
options are listed in Table 4.14. Generally GaussSeidel is the most reliable option, but for
bad matrices DIC can oﬀer better convergence. In some cases, additional post-smoothing
using GaussSeidel is further beneﬁcial, i.e. the method denoted as DICGaussSeidel
Smoother Keyword
Gauss-Seidel GaussSeidel
Diagonal incomplete-Cholesky (symmetric) DIC
Diagonal incomplete-Cholesky with Gauss-Seidel (symmetric) DICGaussSeidel
Table 4.14: Smoother options.
The user must also pecify the number of sweeps, by the nSweeps keyword, before the
residual is recalculated, following the tolerance parameters.
4.5.1.4 Geometric-algebraic multi-grid solvers
The generalised method of geometric-algebraic multi-grid (GAMG) uses the principle of:
generating a quick solution on a mesh with a small number of cells; mapping this solution
onto a ﬁner mesh; using it as an initial guess to obtain an accurate solution on the ﬁne
mesh. GAMG is faster than standard methods when the increase in speed by solving ﬁrst
on coarser meshes outweighs the additional costs of mesh reﬁnement and mapping of ﬁeld
data. In practice, GAMG starts with the mesh speciﬁed by the user and coarsens/reﬁnes
the mesh in stages. The user is only required to specify an approximate mesh size at the
most coarse level in terms of the number of cells nCoarsestCells.
Open∇FOAM-2.2.0
4.5 Solution and algorithm control U-123
The agglomeration of cells is performed by the algorithm speciﬁed by the agglomerator
keyword. Presently we recommend the faceAreaPair method. It is worth noting there is
an MGridGen option that requires an additional entry specifying the shared object library
for MGridGen:
geometricGamgAgglomerationLibs ("libMGridGenGamgAgglomeration.so");
In the experience of OpenCFD, the MGridGen method oﬀers no obvious beneﬁt over the
faceAreaPair method. For all methods, agglomeration can be optionally cached by the
cacheAgglomeration switch.
Smoothing is speciﬁed by the smoother as described in section 4.5.1.3. The number
of sweeps used by the smoother at diﬀerent levels of mesh density are speciﬁed by the
nPreSweeps, nPostSweeps and nFinestSweeps keywords. The nPreSweeps entry is used
as the algorithm is coarsening the mesh, nPostSweeps is used as the algorithm is reﬁning,
and nFinestSweeps is used when the solution is at its ﬁnest level.
The mergeLevels keyword controls the speed at which coarsening or reﬁnement levels
is performed. It is often best to do so only at one level at a time, i.e. set mergeLevels
1. In some cases, particularly for simple meshes, the solution can be safely speeded up
by coarsening/reﬁning two levels at a time, i.e. setting mergeLevels 2.
4.5.2 Solution under-relaxation
A second sub-dictionary of fvSolution that is often used in OpenFOAM is relaxationFactors
which controls under-relaxation, a technique used for improving stability of a computa-
tion, particularly in solving steady-state problems. Under-relaxation works by limiting
the amount which a variable changes from one iteration to the next, either by modifying
the solution matrix and source prior to solving for a ﬁeld or by modifying the ﬁeld di-
rectly. An under-relaxation factor α, 0 < α ≤ 1 speciﬁes the amount of under-relaxation,
ranging from none at all for α = 1 and increasing in strength as α → 0. The limiting case
where α = 0 represents a solution which does not change at all with successive iterations.
An optimum choice of α is one that is small enough to ensure stable computation but
large enough to move the iterative process forward quickly; values of α as high as 0.9
can ensure stability in some cases and anything much below, say, 0.2 are prohibitively
restrictive in slowing the iterative process.
The user can specify the relaxation factor for a particular ﬁeld by specifying ﬁrst the
word associated with the ﬁeld, then the factor. The user can view the relaxation factors
used in a tutorial example of simpleFoam for incompressible, laminar, steady-state ﬂows.
17
18 solvers
19 {
20 p
21 {
22 solver PCG;
23 preconditioner DIC;
24 tolerance 1e-06;
25 relTol 0.01;
26 }
27
28 U
29 {
30 solver PBiCG;
31 preconditioner DILU;
32 tolerance 1e-05;
33 relTol 0.1;
34 }
35
36 k
37 {
38 solver PBiCG;
Open∇FOAM-2.2.0
U-124 OpenFOAM cases
39 preconditioner DILU;
40 tolerance 1e-05;
41 relTol 0.1;
42 }
43
44 epsilon
45 {
46 solver PBiCG;
47 preconditioner DILU;
48 tolerance 1e-05;
49 relTol 0.1;
50 }
51
52 R
53 {
54 solver PBiCG;
55 preconditioner DILU;
56 tolerance 1e-05;
57 relTol 0.1;
58 }
59
60 nuTilda
61 {
62 solver PBiCG;
63 preconditioner DILU;
64 tolerance 1e-05;
65 relTol 0.1;
66 }
67 }
68
69 SIMPLE
70 {
71 nNonOrthogonalCorrectors 0;
72
73 residualControl
74 {
75 p 1e-2;
76 U 1e-3;
77 "(k|epsilon|omega)" 1e-3;
78 }
79 }
80
81 relaxationFactors
82 {
83 fields
84 {
85 p 0.3;
86 }
87 equations
88 {
89 U 0.7;
90 k 0.7;
91 epsilon 0.7;
92 R 0.7;
93 nuTilda 0.7;
94 }
95 }
96
97
98 // ************************************************************************* //
4.5.3 PISO and SIMPLE algorithms
Most ﬂuid dynamics solver applications in OpenFOAM use the pressure-implicit split-
operator (PISO) or semi-implicit method for pressure-linked equations (SIMPLE) algo-
rithms. These algorithms are iterative procedures for solving equations for velocity and
pressure, PISO being used for transient problems and SIMPLE for steady-state.
Both algorithms are based on evaluating some initial solutions and then correcting
them. SIMPLE only makes 1 correction whereas PISO requires more than 1, but typically
not more than 4. The user must therefore specify the number of correctors in the PISO
dictionary by the nCorrectors keyword as shown in the example on page U-120.
An additional correction to account for mesh non-orthogonality is available in both
SIMPLE and PISO in the standard OpenFOAM solver applications. A mesh is orthogonal
if, for each face within it, the face normal is parallel to the vector between the centres of
the cells that the face connects, e.g. a mesh of hexahedral cells whose faces are aligned
Open∇FOAM-2.2.0
4.5 Solution and algorithm control U-125
with a Cartesian coordinate system. The number of non-orthogonal correctors is speciﬁed
by the nNonOrthogonalCorrectors keyword as shown in the examples above and on
page U-120. The number of non-orthogonal correctors should correspond to the mesh for
the case being solved, i.e. 0 for an orthogonal mesh and increasing with the degree of
non-orthogonality up to, say, 20 for the most non-orthogonal meshes.
4.5.3.1 Pressure referencing
In a closed incompressible system, pressure is relative: it is the pressure range that matters
not the absolute values. In these cases, the solver sets a reference level of pRefValue in
cell pRefCell where p is the name of the pressure solution variable. Where the pressure
is p rgh, the names are p rhgRefValue and p rhgRefCell respectively. These entries are
generally stored in the PISO/SIMPLE sub-dictionary and are used by those solvers that
require them when the case demands it. If ommitted, the solver will not run, but give a
message to alert the user to the problem.
4.5.4 Other parameters
The fvSolutions dictionaries in the majority of standard OpenFOAM solver applications
contain no other entries than those described so far in this section. However, in general
the fvSolution dictionary may contain any parameters to control the solvers, algorithms,
or in fact anything. For a given solver, the user can look at the source code to ﬁnd the
parameters required. Ultimately, if any parameter or sub-dictionary is missing when an
solver is run, it will terminate, printing a detailed error message. The user can then add
missing parameters accordingly.
Open∇FOAM-2.2.0
U-126 OpenFOAM cases
Open∇FOAM-2.2.0
Chapter 5
Mesh generation and conversion
This chapter describes all topics relating to the creation of meshes in OpenFOAM: sec-
tion 5.1 gives an overview of the ways a mesh may be described in OpenFOAM; section 5.3
covers the blockMesh utility for generating simple meshes of blocks of hexahedral cells;
section 5.4 covers the snappyHexMesh utility for generating complex meshes of hexahedral
and split-hexahedral cells automatically from triangulated surface geometries; section 5.5
describes the options available for conversion of a mesh that has been generated by a
third-party product into a format that OpenFOAM can read.
5.1 Mesh description
This section provides a speciﬁcation of the way the OpenFOAM C++ classes handle a
mesh. The mesh is an integral part of the numerical solution and must satisfy certain
criteria to ensure a valid, and hence accurate, solution. During any run, OpenFOAM
checks that the mesh satisﬁes a fairly stringent set of validity constraints and will cease
running if the constraints are not satisﬁed. The consequence is that a user may experience
some frustration in ‘correcting’ a large mesh generated by third-party mesh generators
before OpenFOAM will run using it. This is unfortunate but we make no apology for
OpenFOAM simply adopting good practice to ensure the mesh is valid; otherwise, the
solution is ﬂawed before the run has even begun.
By default OpenFOAM deﬁnes a mesh of arbitrary polyhedral cells in 3-D, bounded
by arbitrary polygonal faces, i.e. the cells can have an unlimited number of faces where,
for each face, there is no limit on the number of edges nor any restriction on its alignment.
A mesh with this general structure is known in OpenFOAM as a polyMesh. This type
of mesh oﬀers great freedom in mesh generation and manipulation in particular when
the geometry of the domain is complex or changes over time. The price of absolute
mesh generality is, however, that it can be diﬃcult to convert meshes generated using
conventional tools. The OpenFOAM library therefore provides cellShape tools to manage
conventional mesh formats based on sets of pre-deﬁned cell shapes.
5.1.1 Mesh speciﬁcation and validity constraints
Before describing the OpenFOAM mesh format, polyMesh, and the cellShape tools, we
will ﬁrst set out the validity constraints used in OpenFOAM. The conditions that a mesh
must satisfy are:
U-128 Mesh generation and conversion
5.1.1.1 Points
A point is a location in 3-D space, deﬁned by a vector in units of metres (m). The points
are compiled into a list and each point is referred to by a label, which represents its
position in the list, starting from zero. The point list cannot contain two diﬀerent points
at an exactly identical position nor any point that is not part at least one face.
5.1.1.2 Faces
A face is an ordered list of points, where a point is referred to by its label. The ordering
of point labels in a face is such that each two neighbouring points are connected by an
edge, i.e. you follow points as you travel around the circumference of the face. Faces are
compiled into a list and each face is referred to by its label, representing its position in
the list. The direction of the face normal vector is deﬁned by the right-hand rule, i.e.
looking towards a face, if the numbering of the points follows an anti-clockwise path, the
normal vector points towards you, as shown in Figure 5.1.
4
3
0
2
1
Sf
Figure 5.1: Face area vector from point numbering on the face
There are two types of face:
Internal faces Those faces that connect two cells (and it can never be more than two).
For each internal face, the ordering of the point labels is such that the face normal
points into the cell with the larger label, i.e. for cells 2 and 5, the normal points
into 5;
Boundary faces Those belonging to one cell since they coincide with the boundary
of the domain. A boundary face is therefore addressed by one cell(only) and a
boundary patch. The ordering of the point labels is such that the face normal
points outside of the computational domain.
Faces are generally expected to be convex; at the very least the face centre needs to
be inside the face. Faces are allowed to be warped, i.e. not all points of the face need to
be coplanar.
5.1.1.3 Cells
A cell is a list of faces in arbitrary order. Cells must have the properties listed below.
Contiguous The cells must completely cover the computational domain and must not
overlap one another.
Open∇FOAM-2.2.0
5.1 Mesh description U-129
Convex Every cell must be convex and its cell centre inside the cell.
Closed Every cell must be closed, both geometrically and topologically where:
• geometrical closedness requires that when all face area vectors are oriented to
point outwards of the cell, their sum should equal the zero vector to machine
accuracy;
• topological closedness requires that all the edges in a cell are used by exactly
two faces of the cell in question.
Orthogonality For all internal faces of the mesh, we deﬁne the centre-to-centre vector
as that connecting the centres of the 2 cells that it adjoins oriented from the cen-
tre of the cell with smaller label to the centre of the cell with larger label. The
orthogonality constraint requires that for each internal face, the angle between the
face area vector, oriented as described above, and the centre-to-centre vector must
always be less than 90◦
.
5.1.1.4 Boundary
A boundary is a list of patches, each of which is associated with a boundary condition.
A patch is a list of face labels which clearly must contain only boundary faces and no
internal faces. The boundary is required to be closed, i.e. the sum all boundary face area
vectors equates to zero to machine tolerance.
5.1.2 The polyMesh description
The constant directory contains a full description of the case polyMesh in a subdirectory
polyMesh. The polyMesh description is based around faces and, as already discussed,
internal faces connect 2 cells and boundary faces address a cell and a boundary patch.
Each face is therefore assigned an ‘owner’ cell and ‘neighbour’ cell so that the connectivity
across a given face can simply be described by the owner and neighbour cell labels. In
the case of boundaries, the connected cell is the owner and the neighbour is assigned the
label ‘-1’. With this in mind, the I/O speciﬁcation consists of the following ﬁles:
points a list of vectors describing the cell vertices, where the ﬁrst vector in the list repre-
sents vertex 0, the second vector represents vertex 1, etc.;
faces a list of faces, each face being a list of indices to vertices in the points list, where
again, the ﬁrst entry in the list represents face 0, etc.;
owner a list of owner cell labels, the index of entry relating directly to the index of the
face, so that the ﬁrst entry in the list is the owner label for face 0, the second entry
is the owner label for face 1, etc;
neighbour a list of neighbour cell labels;
boundary a list of patches, containing a dictionary entry for each patch, declared using
the patch name, e.g.
movingWall
{
type patch;
nFaces 20;
startFace 760;
Open∇FOAM-2.2.0
U-130 Mesh generation and conversion
}
The startFace is the index into the face list of the ﬁrst face in the patch, and
nFaces is the number of faces in the patch.
Note that if the user wishes to know how many cells are in their domain, there is a
note in the FoamFile header of the owner ﬁle that contains an entry for nCells.
5.1.3 The cellShape tools
We shall describe the alternative cellShape tools that may be used particularly when
converting some standard (simpler) mesh formats for the use with OpenFOAM library.
The vast majority of mesh generators and post-processing systems support only a
fraction of the possible polyhedral cell shapes in existence. They deﬁne a mesh in terms
of a limited set of 3D cell geometries, referred to as cell shapes. The OpenFOAM library
contains deﬁnitions of these standard shapes, to enable a conversion of such a mesh into
the polyMesh format described in the previous section.
The cellShape models supported by OpenFOAM are shown in Table 5.1. The shape is
deﬁned by the ordering of point labels in accordance with the numbering scheme contained
in the shape model. The ordering schemes for points, faces and edges are shown in
Table 5.1. The numbering of the points must not be such that the shape becomes twisted
or degenerate into other geometries, i.e. the same point label cannot be used more that
once is a single shape. Moreover it is unnecessary to use duplicate points in OpenFOAM
since the available shapes in OpenFOAM cover the full set of degenerate hexahedra.
The cell description consists of two parts: the name of a cell model and the ordered
list of labels. Thus, using the following list of points
8
(
(0 0 0)
(1 0 0)
(1 1 0)
(0 1 0)
(0 0 0.5)
(1 0 0.5)
(1 1 0.5)
(0 1 0.5)
)
A hexahedral cell would be written as:
(hex 8(0 1 2 3 4 5 6 7))
Here the hexahedral cell shape is declared using the keyword hex. Other shapes are
described by the keywords listed in Table 5.1.
5.1.4 1- and 2-dimensional and axi-symmetric problems
OpenFOAM is designed as a code for 3-dimensional space and deﬁnes all meshes as
such. However, 1- and 2- dimensional and axi-symmetric problems can be simulated
in OpenFOAM by generating a mesh in 3 dimensions and applying special boundary
conditions on any patch in the plane(s) normal to the direction(s) of interest. More
speciﬁcally, 1- and 2- dimensional problems use the empty patch type and axi-symmetric
problems use the wedge type. The use of both are described in section 5.2.2 and the
generation of wedge geometries for axi-symmetric problems is discussed in section 5.3.3.
Open∇FOAM-2.2.0
5.2 Boundaries U-131
Cell type Keyword Vertex numbering Face numbering Edge numbering
Hexahedron hex
2
7
3
10
4
6
5
0 1
2
3
5
4
0
1
2
3
4
5
6
7
8 9
1011
Wedge wedge
2
10
3 4
56
0
1
2
35
4
0
1
2
3
5
6
7
8
9
10
4
Prism prism
2
10
3 4
5
0
1
3
4
2
0
1
2
3
4
5
6 7
8
Pyramid pyr
2
10
4
3
0
2
34
1
0
1
2
3
4 5
67
Tetrahedron tet 0 1
2
3
1
2
3
0
0
1
2
3
4
5
Tet-wedge tetWedge
2
10
3 4
0
1
3
2
0
1
2
3
4
5
6
Table 5.1: Vertex, face and edge numbering for cellShapes.
Open∇FOAM-2.2.0
U-132 Mesh generation and conversion
5.2 Boundaries
In this section we discuss the way in which boundaries are treated in OpenFOAM. The
subject of boundaries is a little involved because their role in modelling is not simply that
of a geometric entity but an integral part of the solution and numerics through boundary
conditions or inter-boundary ‘connections’. A discussion of boundaries sits uncomfortably
between a discussion on meshes, ﬁelds, discretisation, computational processing etc. Its
placement in this Chapter on meshes is a choice of convenience.
We ﬁrst need to consider that, for the purpose of applying boundary conditions, a
boundary is generally broken up into a set of patches. One patch may include one or
more enclosed areas of the boundary surface which do not necessarily need to be physically
connected.
There are three attributes associated with a patch that are described below in their
natural hierarchy and Figure 5.2 shows the names of diﬀerent patch types introduced
at each level of the hierarchy. The hierarchy described below is very similar, but not
identical, to the class hierarchy used in the OpenFOAM library.
Base type The type of patch described purely in terms of geometry or a data ‘commu-
nication link’.
Primitive type The base numerical patch condition assigned to a ﬁeld variable on the
patch.
Derived type A complex patch condition, derived from the primitive type, assigned to
a ﬁeld variable on the patch.
Derived type
ﬁxedGradient
ﬁxedValue
Primitive type
calculated
mixed
directionMixed
zeroGradient
symmetry
empty
wedge
cyclicBase type
processor
patch
wall
e.g. inletOutlet
Figure 5.2: Patch attributes
5.2.1 Speciﬁcation of patch types in OpenFOAM
The patch types are speciﬁed in the mesh and ﬁeld ﬁles of a OpenFOAM case. More
precisely:
• the base type is speciﬁed under the type keyword for each patch in the boundary
ﬁle, located in the constant/polyMesh directory;
Open∇FOAM-2.2.0
5.2 Boundaries U-133
• the numerical patch type, be it a primitive or derived type, is speciﬁed under the
type keyword for each patch in a ﬁeld ﬁle.
An example boundary ﬁle is shown below for a sonicFoam case, followed by a pressure
ﬁeld ﬁle, p, for the same case:
17
18 6
19 (
20 inlet
21 {
22 type patch;
23 nFaces 50;
24 startFace 10325;
25 }
26 outlet
27 {
28 type patch;
29 nFaces 40;
30 startFace 10375;
31 }
32 bottom
33 {
34 type symmetryPlane;
35 inGroups 1(symmetryPlane);
36 nFaces 25;
37 startFace 10415;
38 }
39 top
40 {
41 type symmetryPlane;
42 inGroups 1(symmetryPlane);
43 nFaces 125;
44 startFace 10440;
45 }
46 obstacle
47 {
48 type patch;
49 nFaces 110;
50 startFace 10565;
51 }
52 defaultFaces
53 {
54 type empty;
55 inGroups 1(empty);
56 nFaces 10500;
57 startFace 10675;
58 }
59 )
60
61 // ************************************************************************* //
17 dimensions [1 -1 -2 0 0 0 0];
18
19 internalField uniform 1;
20
21 boundaryField
22 {
23 inlet
24 {
25 type fixedValue;
26 value uniform 1;
27 }
28
29 outlet
30 {
31 type waveTransmissive;
32 field p;
33 phi phi;
34 rho rho;
35 psi thermo:psi;
36 gamma 1.4;
37 fieldInf 1;
38 lInf 3;
39 value uniform 1;
40 }
41
42 bottom
43 {
44 type symmetryPlane;
45 }
46
47 top
Open∇FOAM-2.2.0
U-134 Mesh generation and conversion
48 {
49 type symmetryPlane;
50 }
51
52 obstacle
53 {
54 type zeroGradient;
55 }
56
57 defaultFaces
58 {
59 type empty;
60 }
61 }
62
63 // ************************************************************************* //
The type in the boundary ﬁle is patch for all patches except those that have some
geometrical constraint applied to them, i.e. the symmetryPlane and empty patches. The p
ﬁle includes primitive types applied to the inlet and bottom faces, and a more complex
derived type applied to the outlet. Comparison of the two ﬁles shows that the base
and numerical types are consistent where the base type is not a simple patch, i.e. for the
symmetryPlane and empty patches.
5.2.2 Base types
The base and geometric types are described below; the keywords used for specifying these
types in OpenFOAM are summarised in Table 5.2.
wedge aligned along
coordinate plane
<5◦ Axis of symmetry
wedge patch 1
wedge patch 2
Figure 5.3: Axi-symmetric geometry using the wedge patch type.
patch The basic patch type for a patch condition that contains no geometric or topological
information about the mesh (with the exception of wall), e.g. an inlet or an outlet.
wall There are instances where a patch that coincides with a wall needs to be identiﬁable
as such, particularly where specialist modelling is applied at wall boundaries. A
good example is wall turbulence modelling where a wall must be speciﬁed with a
wall patch type, so that the distance from the wall to the cell centres next to the
wall are stored as part of the patch.
symmetryPlane For a symmetry plane.
Open∇FOAM-2.2.0
5.2 Boundaries U-135
Selection Key Description
patch generic patch
symmetryPlane plane of symmetry
empty front and back planes of a 2D geometry
wedge wedge front and back for an axi-symmetric geometry
cyclic cyclic plane
wall wall — used for wall functions in turbulent ﬂows
processor inter-processor boundary
Table 5.2: Basic patch types.
empty While OpenFOAM always generates geometries in 3 dimensions, it can be in-
structed to solve in 2 (or 1) dimensions by specifying a special empty condition on
each patch whose plane is normal to the 3rd (and 2nd) dimension for which no
solution is required.
wedge For 2 dimensional axi-symmetric cases, e.g. a cylinder, the geometry is speciﬁed
as a wedge of small angle (e.g. < 5◦
) and 1 cell thick running along the plane of
symmetry, straddling one of the coordinate planes, as shown in Figure 5.3. The
axi-symmetric wedge planes must be speciﬁed as separate patches of wedge type.
The details of generating wedge-shaped geometries using blockMesh are described
in section 5.3.3.
cyclic Enables two patches to be treated as if they are physically connected; used for
repeated geometries, e.g. heat exchanger tube bundles. One cyclic patch is linked
to another through a neighbourPatch keyword in the boundary ﬁle. Each pair
of connecting faces must have similar area to within a tolerance given by the
matchTolerance keyword in the boundary ﬁle. Faces do not need to be of the
same orientation.
processor If a code is being run in parallel, on a number of processors, then the mesh
must be divided up so that each processor computes on roughly the same number
of cells. The boundaries between the diﬀerent parts of the mesh are called processor
boundaries.
5.2.3 Primitive types
The primitive types are listed in Table 5.3.
5.2.4 Derived types
There are numerous derived types of boundary conditions in OpenFOAM, too many to
list here. Instead a small selection is listed in Table 5.4. If the user wishes to obtain a
list of all available models, they should consult the OpenFOAM source code. Derived
boundary condition source code can be found at the following locations:
• in $FOAM SRC/ﬁniteVolume/ﬁelds/fvPatchFields/derived
• within certain model libraries, that can be located by typing the following command
in a terminal window
find $FOAM SRC -name "*derivedFvPatch*"
Open∇FOAM-2.2.0
U-136 Mesh generation and conversion
Type Description of condition for patch ﬁeld φ Data to specify
ﬁxedValue Value of φ is speciﬁed value
ﬁxedGradient Normal gradient of φ is speciﬁed gradient
zeroGradient Normal gradient of φ is zero —
calculated Boundary ﬁeld φ derived from other ﬁelds —
mixed Mixed ﬁxedValue/ ﬁxedGradient condition depend-
ing on the value in valueFraction
refValue,
refGradient,
valueFraction,
value
directionMixed A mixed condition with tensorial valueFraction,
e.g. for diﬀerent levels of mixing in normal and
tangential directions
refValue,
refGradient,
valueFraction,
value
Table 5.3: Primitive patch ﬁeld types.
• within certain solvers, that can be located by typing the following command in a
terminal window
find $FOAM SOLVERS -name "*fvPatch*"
5.3 Mesh generation with the blockMesh utility
This section describes the mesh generation utility, blockMesh, supplied with OpenFOAM.
The blockMesh utility creates parametric meshes with grading and curved edges.
The mesh is generated from a dictionary ﬁle named blockMeshDict located in the
constant/polyMesh directory of a case. blockMesh reads this dictionary, generates the
mesh and writes out the mesh data to points and faces, cells and boundary ﬁles in the
same directory.
The principle behind blockMesh is to decompose the domain geometry into a set of 1
or more three dimensional, hexahedral blocks. Edges of the blocks can be straight lines,
arcs or splines. The mesh is ostensibly speciﬁed as a number of cells in each direction of
the block, suﬃcient information for blockMesh to generate the mesh data.
Each block of the geometry is deﬁned by 8 vertices, one at each corner of a hexahedron.
The vertices are written in a list so that each vertex can be accessed using its label,
remembering that OpenFOAM always uses the C++ convention that the ﬁrst element of
the list has label ‘0’. An example block is shown in Figure 5.4 with each vertex numbered
according to the list. The edge connecting vertices 1 and 5 is curved to remind the reader
that curved edges can be speciﬁed in blockMesh.
It is possible to generate blocks with less than 8 vertices by collapsing one or more
pairs of vertices on top of each other, as described in section 5.3.3.
Each block has a local coordinate system (x1, x2, x3) that must be right-handed. A
right-handed set of axes is deﬁned such that to an observer looking down the Oz axis,
with O nearest them, the arc from a point on the Ox axis to a point on the Oy axis is in
a clockwise sense.
The local coordinate system is deﬁned by the order in which the vertices are presented
in the block deﬁnition according to:
• the axis origin is the ﬁrst entry in the block deﬁnition, vertex 0 in our example;
Open∇FOAM-2.2.0
5.3MeshgenerationwiththeblockMeshutilityU-137
Types derived from ﬁxedValue Data to specify
movingWallVelocity Replaces the normal of the patch value so the ﬂux across the patch is zero value
pressureInletVelocity When p is known at inlet, U is evaluated from the ﬂux, normal to the patch value
pressureDirectedInletVelocityWhen p is known at inlet, U is calculated from the ﬂux in the inletDirection value,
inletDirection
surfaceNormalFixedValue Speciﬁes a vector boundary condition, normal to the patch, by its magnitude; +ve
for vectors pointing out of the domain
value
totalPressure Total pressure p0 = p + 1
2
ρ|U|2
is ﬁxed; when U changes, p is adjusted accordingly p0
turbulentInlet Calculates a ﬂuctuating variable based on a scale of a mean value referenceField,
fluctuationScale
Types derived from ﬁxedGradient/zeroGradient
ﬂuxCorrectedVelocity Calculates normal component of U at inlet from ﬂux value
buoyantPressure Sets ﬁxedGradient pressure based on the atmospheric pressure gradient —
Types derived from mixed
inletOutlet Switches U and p between ﬁxedValue and zeroGradient depending on direction of U inletValue, value
outletInlet Switches U and p between ﬁxedValue and zeroGradient depending on direction of U outletValue,
value
pressureInletOutletVelocity Combination of pressureInletVelocity and inletOutlet value
pressureDirected-
InletOutletVelocity
Combination of pressureDirectedInletVelocity and inletOutlet value,
inletDirection
pressureTransmissive Transmits supersonic pressure waves to surrounding pressure p∞ pInf
supersonicFreeStream Transmits oblique shocks to surroundings at p∞, T∞, U∞ pInf, TInf, UInf
Other types
slip zeroGradient if φ is a scalar; if φ is a vector, normal component is ﬁxedValue zero,
tangential components are zeroGradient
—
partialSlip Mixed zeroGradient/ slip condition depending on the valueFraction; = 0 for slip valueFraction
Note: p is pressure, U is velocity
Table 5.4: Derived patch ﬁeld types.
Open∇FOAM-2.2.0
U-138 Mesh generation and conversion
• the x1 direction is described by moving from vertex 0 to vertex 1;
• the x2 direction is described by moving from vertex 1 to vertex 2;
• vertices 0, 1, 2, 3 deﬁne the plane x3 = 0;
• vertex 4 is found by moving from vertex 0 in the x3 direction;
• vertices 5,6 and 7 are similarly found by moving in the x3 direction from vertices
1,2 and 3 respectively.
3
9
1
2
x2
x3
x10
3
4
5
7 6
0
2
1
4 5
6
7
10
8
11
Figure 5.4: A single block
Keyword Description Example/selection
convertToMeters Scaling factor for the vertex
coordinates
0.001 scales to mm
vertices List of vertex coordinates (0 0 0)
edges Used to describe arc or
spline edges
arc 1 4 (0.939 0.342 -0.5)
block Ordered list of vertex labels
and mesh size
hex (0 1 2 3 4 5 6 7)
(10 10 1)
simpleGrading (1.0 1.0 1.0)
patches List of patches symmetryPlane base
( (0 1 2 3) )
mergePatchPairs List of patches to be merged see section 5.3.2
Table 5.5: Keywords used in blockMeshDict.
5.3.1 Writing a blockMeshDict ﬁle
The blockMeshDict ﬁle is a dictionary using keywords described in Table 5.5. The
convertToMeters keyword speciﬁes a scaling factor by which all vertex coordinates in
the mesh description are multiplied. For example,
Open∇FOAM-2.2.0
5.3 Mesh generation with the blockMesh utility U-139
convertToMeters 0.001;
means that all coordinates are multiplied by 0.001, i.e. the values quoted in the blockMesh-
Dict ﬁle are in mm.
5.3.1.1 The vertices
The vertices of the blocks of the mesh are given next as a standard list named vertices,
e.g. for our example block in Figure 5.4, the vertices are:
vertices
(
( 0 0 0 ) // vertex number 0
( 1 0 0.1) // vertex number 1
( 1.1 1 0.1) // vertex number 2
( 0 1 0.1) // vertex number 3
(-0.1 -0.1 1 ) // vertex number 4
( 1.3 0 1.2) // vertex number 5
( 1.4 1.1 1.3) // vertex number 6
( 0 1 1.1) // vertex number 7
);
5.3.1.2 The edges
Each edge joining 2 vertex points is assumed to be straight by default. However any edge
may be speciﬁed to be curved by entries in a list named edges. The list is optional; if
the geometry contains no curved edges, it may be omitted.
Each entry for a curved edge begins with a keyword specifying the type of curve from
those listed in Table 5.6.
Keyword selection Description Additional entries
arc Circular arc Single interpolation point
simpleSpline Spline curve List of interpolation points
polyLine Set of lines List of interpolation points
polySpline Set of splines List of interpolation points
line Straight line —
Table 5.6: Edge types available in the blockMeshDict dictionary.
The keyword is then followed by the labels of the 2 vertices that the edge connects.
Following that, interpolation points must be speciﬁed through which the edge passes.
For a arc, a single interpolation point is required, which the circular arc will intersect.
For simpleSpline, polyLine and polySpline, a list of interpolation points is required.
The line edge is directly equivalent to the option executed by default, and requires no
interpolation points. Note that there is no need to use the line edge but it is included
for completeness. For our example block in Figure 5.4 we specify an arc edge connecting
vertices 1 and 5 as follows through the interpolation point (1.1, 0.0, 0.5):
edges
(
Open∇FOAM-2.2.0
U-140 Mesh generation and conversion
arc 1 5 (1.1 0.0 0.5)
);
5.3.1.3 The blocks
The block deﬁnitions are contained in a list named blocks. Each block deﬁnition is a
compound entry consisting of a list of vertex labels whose order is described in section 5.3,
a vector giving the number of cells required in each direction, the type and list of cell
expansion ratio in each direction.
Then the blocks are deﬁned as follows:
blocks
(
hex (0 1 2 3 4 5 6 7) // vertex numbers
(10 10 10) // numbers of cells in each direction
simpleGrading (1 2 3) // cell expansion ratios
);
The deﬁnition of each block is as follows:
Vertex numbering The ﬁrst entry is the shape identiﬁer of the block, as deﬁned in
the .OpenFOAM-2.2.0/cellModels ﬁle. The shape is always hex since the blocks are
always hexahedra. There follows a list of vertex numbers, ordered in the manner
described on page U-136.
Number of cells The second entry gives the number of cells in each of the x1 x2 and
x3 directions for that block.
Cell expansion ratios The third entry gives the cell expansion ratios for each direction
in the block. The expansion ratio enables the mesh to be graded, or reﬁned, in
speciﬁed directions. The ratio is that of the width of the end cell δe along one edge
of a block to the width of the start cell δs along that edge, as shown in Figure 5.5.
Each of the following keywords specify one of two types of grading speciﬁcation
available in blockMesh.
simpleGrading The simple description speciﬁes uniform expansions in the local x1,
x2 and x3 directions respectively with only 3 expansion ratios, e.g.
simpleGrading (1 2 3)
edgeGrading The full cell expansion description gives a ratio for each edge of the
block, numbered according to the scheme shown in Figure 5.4 with the arrows
representing the direction ‘from ﬁrst cell. . . to last cell’ e.g. something like
edgeGrading (1 1 1 1 2 2 2 2 3 3 3 3)
This means the ratio of cell widths along edges 0-3 is 1, along edges 4-7 is 2
and along 8-11 is 3 and is directly equivalent to the simpleGrading example
given above.
Open∇FOAM-2.2.0
5.3 Mesh generation with the blockMesh utility U-141
δs
Expansion ratio =
δe
δs
δe
Expansion direction
Figure 5.5: Mesh grading along a block edge
5.3.1.4 The boundary
The boundary of the mesh is given in a list named boundary. The boundary is broken
into patches (regions), where each patch in the list has its name as the keyword, which
is the choice of the user, although we recommend something that conveniently identiﬁes
the patch, e.g.inlet; the name is used as an identiﬁer for setting boundary conditions in
the ﬁeld data ﬁles. The patch information is then contained in sub-dictionary with:
• type: the patch type, either a generic patch on which some boundary conditions
are applied or a particular geometric condition, as listed in Table 5.2 and described
in section 5.2.2;
• faces: a list of block faces that make up the patch and whose name is the choice of
the user, although we recommend something that conveniently identiﬁes the patch,
e.g.inlet; the name is used as an identiﬁer for setting boundary conditions in the
ﬁeld data ﬁles.
blockMesh collects faces from any boundary patch that is omitted from the boundary
list and assigns them to a default patch named defaultFaces of type empty. This means
that for a 2 dimensional geometry, the user has the option to omit block faces lying in
the 2D plane, knowing that they will be collected into an empty patch as required.
Returning to the example block in Figure 5.4, if it has an inlet on the left face, an
output on the right face and the four other faces are walls then the patches could be
deﬁned as follows:
boundary // keyword
(
inlet // patch name
{
type patch; // patch type for patch 0
faces
(
(0 4 7 3); // block face in this patch
);
} // end of 0th patch definition
outlet // patch name
{
type patch; // patch type for patch 1
faces
(
(1 2 6 5)
);
}
walls
Open∇FOAM-2.2.0
U-142 Mesh generation and conversion
{
type wall;
faces
(
(0 1 5 4)
(0 3 2 1)
(3 7 6 2)
(4 5 6 7)
);
}
);
Each block face is deﬁned by a list of 4 vertex numbers. The order in which the vertices
are given must be such that, looking from inside the block and starting with any vertex,
the face must be traversed in a clockwise direction to deﬁne the other vertices.
When specifying a cyclic patch in blockMesh, the user must specify the name of the
related cyclic patch through the neighbourPatch keyword. For example, a pair of cyclic
patches might be speciﬁed as follows:
left
{
type cyclic;
neighbourPatch right;
faces ((0 4 7 3));
}
right
{
type cyclic;
neighbourPatch left;
faces ((1 5 6 2));
}
5.3.2 Multiple blocks
A mesh can be created using more than 1 block. In such circumstances, the mesh is
created as has been described in the preceeding text; the only additional issue is the
connection between blocks, in which there are two distinct possibilities:
face matching the set of faces that comprise a patch from one block are formed from
the same set of vertices as a set of faces patch that comprise a patch from another
block;
face merging a group of faces from a patch from one block are connected to another
group of faces from a patch from another block, to create a new set of internal faces
connecting the two blocks.
To connect two blocks with face matching, the two patches that form the connection
should simply be ignored from the patches list. blockMesh then identiﬁes that the faces
do not form an external boundary and combines each collocated pair into a single internal
faces that connects cells from the two blocks.
The alternative, face merging, requires that the block patches to be merged are ﬁrst
deﬁned in the patches list. Each pair of patches whose faces are to be merged must then
Open∇FOAM-2.2.0
5.3 Mesh generation with the blockMesh utility U-143
be included in an optional list named mergePatchPairs. The format of mergePatchPairs
is:
mergePatchPairs
(
( <masterPatch> <slavePatch> ) // merge patch pair 0
( <masterPatch> <slavePatch> ) // merge patch pair 1
...
)
The pairs of patches are interpreted such that the ﬁrst patch becomes the master and
the second becomes the slave. The rules for merging are as follows:
• the faces of the master patch remain as originally deﬁned, with all vertices in their
original location;
• the faces of the slave patch are projected onto the master patch where there is some
separation between slave and master patch;
• the location of any vertex of a slave face might be adjusted by blockMesh to eliminate
any face edge that is shorter than a minimum tolerance;
• if patches overlap as shown in Figure 5.6, each face that does not merge remains as
an external face of the original patch, on which boundary conditions must then be
applied;
• if all the faces of a patch are merged, then the patch itself will contain no faces and
is removed.
patch 1
patch 2
region of internal connecting faces
region of external boundary faces
Figure 5.6: Merging overlapping patches
The consequence is that the original geometry of the slave patch will not necessarily be
completely preserved during merging. Therefore in a case, say, where a cylindrical block
is being connected to a larger block, it would be wise to the assign the master patch to the
cylinder, so that its cylindrical shape is correctly preserved. There are some additional
recommendations to ensure successful merge procedures:
Open∇FOAM-2.2.0
U-144 Mesh generation and conversion
• in 2 dimensional geometries, the size of the cells in the third dimension, i.e. out of
the 2D plane, should be similar to the width/height of cells in the 2D plane;
• it is inadvisable to merge a patch twice, i.e. include it twice in mergePatchPairs;
• where a patch to be merged shares a common edge with another patch to be merged,
both should be declared as a master patch.
5.3.3 Creating blocks with fewer than 8 vertices
It is possible to collapse one or more pair(s) of vertices onto each other in order to create
a block with fewer than 8 vertices. The most common example of collapsing vertices is
when creating a 6-sided wedge shaped block for 2-dimensional axi-symmetric cases that
use the wedge patch type described in section 5.2.2. The process is best illustrated by
using a simpliﬁed version of our example block shown in Figure 5.7. Let us say we wished
to create a wedge shaped block by collapsing vertex 7 onto 4 and 6 onto 5. This is simply
done by exchanging the vertex number 7 by 4 and 6 by 5 respectively so that the block
numbering would become:
hex (0 1 2 3 4 5 5 4)
0
3
4
7 6
5
1
2
Figure 5.7: Creating a wedge shaped block with 6 vertices
The same applies to the patches with the main consideration that the block face
containing the collapsed vertices, previously (4 5 6 7) now becomes (4 5 5 4). This
is a block face of zero area which creates a patch with no faces in the polyMesh, as the
user can see in a boundary ﬁle for such a case. The patch should be speciﬁed as empty
in the blockMeshDict and the boundary condition for any ﬁelds should consequently be
empty also.
5.3.4 Running blockMesh
As described in section 3.3, the following can be executed at the command line to run
blockMesh for a case in the <case> directory:
blockMesh -case <case>
The blockMeshDict ﬁle must exist in subdirectory constant/polyMesh.
Open∇FOAM-2.2.0
5.4 Mesh generation with the snappyHexMesh utility U-145
5.4 Mesh generation with the snappyHexMesh utility
This section describes the mesh generation utility, snappyHexMesh, supplied with Open-
FOAM. The snappyHexMesh utility generates 3-dimensional meshes containing hexahedra
(hex) and split-hexahedra (split-hex) automatically from triangulated surface geometries
in Stereolithography (STL) format. The mesh approximately conforms to the surface
by iteratively reﬁning a starting mesh and morphing the resulting split-hex mesh to the
surface. An optional phase will shrink back the resulting mesh and insert cell layers. The
speciﬁcation of mesh reﬁnement level is very ﬂexible and the surface handling is robust
with a pre-speciﬁed ﬁnal mesh quality. It runs in parallel with a load balancing step every
iteration.
STL surface
Figure 5.8: Schematic 2D meshing problem for snappyHexMesh
5.4.1 The mesh generation process of snappyHexMesh
The process of generating a mesh using snappyHexMesh will be described using the
schematic in Figure 5.8. The objective is to mesh a rectangular shaped region (shaded
grey in the ﬁgure) surrounding an object described by and STL surface, e.g. typical for
an external aerodynamics simulation. Note that the schematic is 2-dimensional to make
it easier to understand, even though the snappyHexMesh is a 3D meshing tool.
In order to run snappyHexMesh, the user requires the following:
• surface data ﬁles in STL format, either binary or ASCII, located in a constant/triSurface
sub-directory of the case directory;
• a background hex mesh which deﬁnes the extent of the computational domain and
a base level mesh density; typically generated using blockMesh, discussed in sec-
tion 5.4.2.
• a snappyHexMeshDict dictionary, with appropriate entries, located in the system
sub-directory of the case.
The snappyHexMeshDict dictionary includes: switches at the top level that control the
various stages of the meshing process; and, individual sub-directories for each process.
The entries are listed in Table 5.7.
All the geometry used by snappyHexMesh is speciﬁed in a geometry sub-dictionary
in the snappyHexMeshDict dictionary. The geometry can be speciﬁed through an STL
surface or bounding geometry entities in OpenFOAM. An example is given below:
Open∇FOAM-2.2.0
U-146 Mesh generation and conversion
Keyword Description Example
castellatedMesh Create the castellated mesh? true
snap Do the surface snapping stage? true
doLayers Add surface layers? true
mergeTolerance Merge tolerance as fraction of bounding box
of initial mesh
1e-06
debug Controls writing of intermediate meshes and
screen printing
— Write ﬁnal mesh only 0
— Write intermediate meshes 1
— Write volScalarField with cellLevel for
post-processing
2
— Write current intersections as .obj ﬁles 4
geometry Sub-dictionary of all surface geometry used
castellatedMeshControls Sub-dictionary of controls for castellated mesh
snapControls Sub-dictionary of controls for surface snapping
addLayersControls Sub-dictionary of controls for layer addition
meshQualityControls Sub-dictionary of controls for mesh quality
Table 5.7: Keywords at the top level of snappyHexMeshDict.
geometry
{
sphere.stl // STL filename
{
type triSurfaceMesh;
regions
{
secondSolid // Named region in the STL file
{
name mySecondPatch; // User-defined patch name
} // otherwise given sphere.stl_secondSolid
}
}
box1x1x1 // User defined region name
{
type searchableBox; // region defined by bounding box
min (1.5 1 -0.5);
max (3.5 2 0.5);
}
sphere2 // User defined region name
{
type searchableSphere; // region defined by bounding sphere
centre (1.5 1.5 1.5);
radius 1.03;
}
};
5.4.2 Creating the background hex mesh
Before snappyHexMesh is executed the user must create a background mesh of hexahedral
cells that ﬁlls the entire region within by the external boundary as shown in Figure 5.9.
This can be done simply using blockMesh. The following criteria must be observed when
creating the background mesh:
• the mesh must consist purely of hexes;
• the cell aspect ratio should be approximately 1, at least near surfaces at which
Open∇FOAM-2.2.0
5.4 Mesh generation with the snappyHexMesh utility U-147
Figure 5.9: Initial mesh generation in snappyHexMesh meshing process
the subsequent snapping procedure is applied, otherwise the convergence of the
snapping procedure is slow, possibly to the point of failure;
• there must be at least one intersection of a cell edge with the STL surface, i.e. a
mesh of one cell will not work.
Figure 5.10: Cell splitting by feature edge in snappyHexMesh meshing process
5.4.3 Cell splitting at feature edges and surfaces
Cell splitting is performed according to the speciﬁcation supplied by the user in the
castellatedMeshControls sub-dictionary in the snappyHexMeshDict. The entries for castel-
latedMeshControls are presented in Table 5.8.
The splitting process begins with cells being selected according to speciﬁed edge fea-
tures ﬁrst within the domain as illustrated in Figure 5.10. The features list in the
castellatedMeshControls sub-dictionary permits dictionary entries containing a name of an
edgeMesh ﬁle and the level of reﬁnement, e.g.:
features
(
{
file "features.eMesh"; // file containing edge mesh
level 2; // level of refinement
}
);
Open∇FOAM-2.2.0
U-148 Mesh generation and conversion
Keyword Description Example
locationInMesh Location vector inside the region to be meshed (5 0 0)
N.B. vector must not coincide with a cell face
either before or during reﬁnement
maxLocalCells Max number of cells per processor during re-
ﬁnement
1e+06
maxGlobalCells Overall cell limit during reﬁnement (i.e. before
removal)
2e+06
minRefinementCells If ≥ number of cells to be reﬁned, surface re-
ﬁnement stops
0
nCellsBetweenLevels Number of buﬀer layers of cells between dif-
ferent levels of reﬁnement
1
resolveFeatureAngle Applies maximum level of reﬁnement to cells
that can see intersections whose angle exceeds
this
30
features List of features for reﬁnement
refinementSurfaces Dictionary of surfaces for reﬁnement
refinementRegions Dictionary of regions for reﬁnement
Table 5.8: Keywords in the castellatedMeshControls sub-dictionary of snappyHexMeshDict.
The edgeMesh containing the features can be extracted from the STL geometry ﬁle using
surfaceFeatureExtract, e.g.
surfaceFeatureExtract -includedAngle 150 surface.stl features
Following feature reﬁnement, cells are selected for splitting in the locality of speciﬁed
surfaces as illustrated in Figure 5.11. The refinementSurfaces dictionary in castel-
latedMeshControls requires dictionary entries for each STL surface and a default level
speciﬁcation of the minimum and maximum reﬁnement in the form (<min> <max>).
The minimum level is applied generally across the surface; the maximum level is ap-
plied to cells that can see intersections that form an angle in excess of that speciﬁed by
resolveFeatureAngle.
The reﬁnement can optionally be overridden on one or more speciﬁc region of an STL
surface. The region entries are collected in a regions sub-dictionary. The keyword for
Figure 5.11: Cell splitting by surface in snappyHexMesh meshing process
Open∇FOAM-2.2.0
5.4 Mesh generation with the snappyHexMesh utility U-149
each region entry is the name of the region itself and the reﬁnement level is contained
within a further sub-dictionary. An example is given below:
refinementSurfaces
{
sphere.stl
{
level (2 2); // default (min max) refinement for whole surface
regions
{
secondSolid
{
level (3 3); // optional refinement for secondSolid region
}
}
}
}
5.4.4 Cell removal
Once the feature and surface splitting is complete a process of cell removal begins. Cell
removal requires one or more regions enclosed entirely by a bounding surface within the
domain. The region in which cells are retained are simply identiﬁed by a location vector
within that region, speciﬁed by the locationInMesh keyword in castellatedMeshControls.
Cells are retained if, approximately speaking, 50% or more of their volume lies within the
region. The remaining cells are removed accordingly as illustrated in Figure 5.12.
Figure 5.12: Cell removal in snappyHexMesh meshing process
5.4.5 Cell splitting in speciﬁed regions
Those cells that lie within one or more speciﬁed volume regions can be further split as il-
lustrated in Figure 5.13 by a rectangular region shown by dark shading. The refinement-
Regions sub-dictionary in castellatedMeshControls contains entries for reﬁnement of the
volume regions speciﬁed in the geometry sub-dictionary. A reﬁnement mode is applied to
each region which can be:
• inside reﬁnes inside the volume region;
• outside reﬁnes outside the volume region
• distance reﬁnes according to distance to the surface; and can accommodate diﬀer-
ent levels at multiple distances with the levels keyword.
Open∇FOAM-2.2.0
U-150 Mesh generation and conversion
For the refinementRegions, the reﬁnement level is speciﬁed by the levels list of entries
with the format(<distance> <level>). In the case of inside and outside reﬁnement,
the <distance> is not required so is ignored (but it must be speciﬁed). Examples are
shown below:
refinementRegions
{
box1x1x1
{
mode inside;
levels ((1.0 4)); // refinement level 4 (1.0 entry ignored)
}
sphere.stl
{ // refinement level 5 within 1.0 m
mode distance; // refinement level 3 within 2.0 m
levels ((1.0 5) (2.0 3)); // levels must be ordered nearest first
}
}
5.4.6 Snapping to surfaces
The next stage of the meshing process involves moving cell vertex points onto surface
geometry to remove the jagged castellated surface from the mesh. The process is:
1. displace the vertices in the castellated boundary onto the STL surface;
2. solve for relaxation of the internal mesh with the latest displaced boundary vertices;
3. ﬁnd the vertices that cause mesh quality parameters to be violated;
4. reduce the displacement of those vertices from their initial value (at 1) and repeat
from 2 until mesh quality is satisﬁed.
The method uses the settings in the snapControls sub-dictionary in snappyHexMeshDict,
listed in Table 5.9. An example is illustrated in the schematic in Figure 5.14 (albeit with
Keyword Description Example
nSmoothPatch Number of patch smoothing iterations before
ﬁnding correspondence to surface
3
tolerance Ratio of distance for points to be attracted
by surface feature point or edge, to local
maximum edge length
4.0
nSolveIter Number of mesh displacement relaxation it-
erations
30
nRelaxIter Maximum number of snapping relaxation it-
erations
5
Table 5.9: Keywords in the snapControls dictionary of snappyHexMeshDict.
mesh motion that looks slightly unrealistic).
5.4.7 Mesh layers
The mesh output from the snapping stage may be suitable for the purpose, although it
can produce some irregular cells along boundary surfaces. There is an optional stage of
the meshing process which introduces additional layers of hexahedral cells aligned to the
boundary surface as illustrated by the dark shaded cells in Figure 5.15.
Open∇FOAM-2.2.0
5.4 Mesh generation with the snappyHexMesh utility U-151
Figure 5.13: Cell splitting by region in snappyHexMesh meshing process
Figure 5.14: Surface snapping in snappyHexMesh meshing process
Figure 5.15: Layer addition in snappyHexMesh meshing process
Open∇FOAM-2.2.0
U-152 Mesh generation and conversion
The process of mesh layer addition involves shrinking the existing mesh from the
boundary and inserting layers of cells, broadly as follows:
1. the mesh is projected back from the surface by a speciﬁed thickness in the direction
normal to the surface;
2. solve for relaxation of the internal mesh with the latest projected boundary vertices;
3. check if validation criteria are satisﬁed otherwise reduce the projected thickness and
return to 2; if validation cannot be satisﬁed for any thickness, do not insert layers;
4. if the validation criteria can be satisﬁed, insert mesh layers;
5. the mesh is checked again; if the checks fail, layers are removed and we return to 2.
The layer addition procedure uses the settings in the addLayersControls sub-dictionary
in snappyHexMeshDict; entries are listed in Table 5.10. The layers sub-dictionary con-
Keyword Description Example
layers Dictionary of layers
relativeSizes Are layer thicknesses relative to undistorted cell
size outside layer or absolute?
true/false
expansionRatio Expansion factor for layer mesh 1.0
finalLayerThickness Thickness of layer furthest from the wall, ei-
ther relative or absolute according to the
relativeSizes entry
0.3
minThickness Minimum thickness of cell layer, either relative
or absolute (as above)
0.25
nGrow Number of layers of connected faces that are not
grown if points get not extruded; helps conver-
gence of layer addition close to features
1
featureAngle Angle above which surface is not extruded 60
nRelaxIter Maximum number of snapping relaxation itera-
tions
5
nSmoothSurfaceNormals Number of smoothing iterations of surface nor-
mals
1
nSmoothNormals Number of smoothing iterations of interior mesh
movement direction
3
nSmoothThickness Smooth layer thickness over surface patches 10
maxFaceThicknessRatio Stop layer growth on highly warped cells 0.5
maxThicknessTo-
MedialRatio
Reduce layer growth where ratio thickness to me-
dial distance is large
0.3
minMedianAxisAngle Angle used to pick up medial axis points 130
nBufferCellsNoExtrude Create buﬀer region for new layer terminations 0
nLayerIter Overall max number of layer addition iterations 50
nRelaxedIter Max number of iterations after which the
controls in the relaxed sub dictionary of
meshQuality are used
20
Table 5.10: Keywords in the addLayersControls sub-dictionary of snappyHexMeshDict.
tains entries for each patch on which the layers are to be applied and the number of
Open∇FOAM-2.2.0
5.5 Mesh conversion U-153
surface layers required. The patch name is used because the layers addition relates to the
existing mesh, not the surface geometry; hence applied to a patch, not a surface region.
An example layers entry is as follows:
layers
{
sphere.stl_firstSolid
{
nSurfaceLayers 1;
}
maxY
{
nSurfaceLayers 1;
}
}
Keyword Description Example
maxNonOrtho Maximum non-orthogonality allowed; 180 dis-
ables
65
maxBoundarySkewness Max boundary face skewness allowed; <0 dis-
ables
20
maxInternalSkewness Max internal face skewness allowed; <0 disables 4
maxConcave Max concaveness allowed; 180 disables 80
minFlatness Ratio of minimum projected area to actual area;
-1 disables
0.5
minVol Minimum pyramid volume; large negative num-
ber, e.g.-1e30 disables
1e-13
minArea Minimum face area; <0 disables -1
minTwist Minimum face twist; <-1 disables 0.05
minDeterminant Minimum normalised cell determinant; 1 = hex;
≤ 0 illegal cell
0.001
minFaceWeight 0→0.5 0.05
minVolRatio 0→1.0 0.01
minTriangleTwist >0 for Fluent compatability -1
nSmoothScale Number of error distribution iterations 4
errorReduction Amount to scale back displacement at error
points
0.75
relaxed Sub-dictionary that can include modiﬁed values
for the above keyword entries to be used when
nRelaxedIter is exceeded in the layer addition
process
relaxed
{
...
}
Table 5.11: Keywords in the meshQualityControls sub-dictionary of snappyHexMeshDict.
5.4.8 Mesh quality controls
The mesh quality is controlled by the entries in the meshQualityControls sub-dictionary
in snappyHexMeshDict; entries are listed in Table 5.11.
5.5 Mesh conversion
The user can generate meshes using other packages and convert them into the format
that OpenFOAM uses. There are numerous mesh conversion utilities listed in Table 3.6.
Open∇FOAM-2.2.0
U-154 Mesh generation and conversion
Some of the more popular mesh converters are listed below and their use is presented in
this section.
ﬂuentMeshToFoam reads a Fluent.msh mesh ﬁle, working for both 2-D and 3-D cases;
starToFoam reads STAR-CD/PROSTAR mesh ﬁles.
gambitToFoam reads a GAMBIT.neu neutral ﬁle;
ideasToFoam reads an I-DEAS mesh written in ANSYS.ans format;
cfx4ToFoam reads a CFX mesh written in .geo format;
5.5.1 ﬂuentMeshToFoam
Fluent writes mesh data to a single ﬁle with a .msh extension. The ﬁle must be written
in ASCII format, which is not the default option in Fluent. It is possible to convert
single-stream Fluent meshes, including the 2 dimensional geometries. In OpenFOAM, 2
dimensional geometries are currently treated by deﬁning a mesh in 3 dimensions, where
the front and back plane are deﬁned as the empty boundary patch type. When reading
a 2 dimensional Fluent mesh, the converter automatically extrudes the mesh in the third
direction and adds the empty patch, naming it frontAndBackPlanes.
The following features should also be observed.
• The OpenFOAM converter will attempt to capture the Fluent boundary condition
deﬁnition as much as possible; however, since there is no clear, direct correspondence
between the OpenFOAM and Fluent boundary conditions, the user should check the
boundary conditions before running a case.
• Creation of axi-symmetric meshes from a 2 dimensional mesh is currently not sup-
ported but can be implemented on request.
• Multiple material meshes are not permitted. If multiple ﬂuid materials exist, they
will be converted into a single OpenFOAM mesh; if a solid region is detected, the
converter will attempt to ﬁlter it out.
• Fluent allows the user to deﬁne a patch which is internal to the mesh, i.e. consists
of the faces with cells on both sides. Such patches are not allowed in OpenFOAM
and the converter will attempt to ﬁlter them out.
• There is currently no support for embedded interfaces and reﬁnement trees.
The procedure of converting a Fluent.msh ﬁle is ﬁrst to create a new OpenFOAM case
by creating the necessary directories/ﬁles: the case directory containing a controlDict ﬁle
in a system subdirectory. Then at a command prompt the user should execute:
fluentMeshToFoam <meshFile>
where <meshFile> is the name of the .msh ﬁle, including the full or relative path.
Open∇FOAM-2.2.0
5.5 Mesh conversion U-155
5.5.2 starToFoam
This section describes how to convert a mesh generated on the STAR-CD code into a form
that can be read by OpenFOAM mesh classes. The mesh can be generated by any of the
packages supplied with STAR-CD, i.e.PROSTAR, SAMM, ProAM and their derivatives.
The converter accepts any single-stream mesh including integral and arbitrary couple
matching and all cell types are supported. The features that the converter does not
support are:
• multi-stream mesh speciﬁcation;
• baﬄes, i.e. zero-thickness walls inserted into the domain;
• partial boundaries, where an uncovered part of a couple match is considered to be
a boundary face;
• sliding interfaces.
For multi-stream meshes, mesh conversion can be achieved by writing each individual
stream as a separate mesh and reassemble them in OpenFOAM.
OpenFOAM adopts a policy of only accepting input meshes that conform to the
fairly stringent validity criteria speciﬁed in section 5.1. It will simply not run using
invalid meshes and cannot convert a mesh that is itself invalid. The following sections
describe steps that must be taken when generating a mesh using a mesh generating
package supplied with STAR-CD to ensure that it can be converted to OpenFOAM format.
To avoid repetition in the remainder of the section, the mesh generation tools supplied
with STAR-CD will be referred to by the collective name STAR-CD.
5.5.2.1 General advice on conversion
We strongly recommend that the user run the STAR-CD mesh checking tools before
attempting a starToFoam conversion and, after conversion, the checkMesh utility should
be run on the newly converted mesh. Alternatively, starToFoam may itself issue warnings
containing PROSTAR commands that will enable the user to take a closer look at cells with
problems. Problematic cells and matches should be checked and ﬁxed before attempting
to use the mesh with OpenFOAM. Remember that an invalid mesh will not run with
OpenFOAM, but it may run in another environment that does not impose the validity
criteria.
Some problems of tolerance matching can be overcome by the use of a matching
tolerance in the converter. However, there is a limit to its eﬀectiveness and an apparent
need to increase the matching tolerance from its default level indicates that the original
mesh suﬀers from inaccuracies.
5.5.2.2 Eliminating extraneous data
When mesh generation in is completed, remove any extraneous vertices and compress the
cells boundary and vertex numbering, assuming that ﬂuid cells have been created and all
other cells are discarded. This is done with the following PROSTAR commands:
CSET NEWS FLUID
CSET INVE
Open∇FOAM-2.2.0
U-156 Mesh generation and conversion
The CSET should be empty. If this is not the case, examine the cells in CSET and adjust
the model. If the cells are genuinely not desired, they can be removed using the PROSTAR
command:
CDEL CSET
Similarly, vertices will need to be discarded as well:
CSET NEWS FLUID
VSET NEWS CSET
VSET INVE
Before discarding these unwanted vertices, the unwanted boundary faces have to be col-
lected before purging:
CSET NEWS FLUID
VSET NEWS CSET
BSET NEWS VSET ALL
BSET INVE
If the BSET is not empty, the unwanted boundary faces can be deleted using:
BDEL BSET
At this time, the model should contain only the ﬂuid cells and the supporting vertices,
as well as the deﬁned boundary faces. All boundary faces should be fully supported by the
vertices of the cells, if this is not the case, carry on cleaning the geometry until everything
is clean.
5.5.2.3 Removing default boundary conditions
By default, STAR-CD assigns wall boundaries to any boundary faces not explicitly associ-
ated with a boundary region. The remaining boundary faces are collected into a default
boundary region, with the assigned boundary type 0. OpenFOAM deliberately does not
have a concept of a default boundary condition for undeﬁned boundary faces since it
invites human error, e.g. there is no means of checking that we meant to give all the
unassociated faces the default condition.
Therefore all boundaries for each OpenFOAM mesh must be speciﬁed for a mesh to
be successfully converted. The default boundary needs to be transformed into a real
one using the procedure described below:
1. Plot the geometry with Wire Surface option.
2. Deﬁne an extra boundary region with the same parameters as the default region
0 and add all visible faces into the new region, say 10, by selecting a zone option
in the boundary tool and drawing a polygon around the entire screen draw of the
model. This can be done by issuing the following commands in PROSTAR:
RDEF 10 WALL
BZON 10 ALL
Open∇FOAM-2.2.0
5.5 Mesh conversion U-157
3. We shall remove all previously deﬁned boundary types from the set. Go through
the boundary regions:
BSET NEWS REGI 1
BSET NEWS REGI 2
... 3, 4, ...
Collect the vertices associated with the boundary set and then the boundary faces
associated with the vertices (there will be twice as many of them as in the original
set).
BSET NEWS REGI 1
VSET NEWS BSET
BSET NEWS VSET ALL
BSET DELE REGI 1
REPL
This should give the faces of boundary Region 10 which have been deﬁned on top
of boundary Region 1. Delete them with BDEL BSET. Repeat these for all regions.
5.5.2.4 Renumbering the model
Renumber and check the model using the commands:
CSET NEW FLUID
CCOM CSET
VSET NEWS CSET
VSET INVE (Should be empty!)
VSET INVE
VCOM VSET
BSET NEWS VSET ALL
BSET INVE (Should be empty also!)
BSET INVE
BCOM BSET
CHECK ALL
GEOM
Internal PROSTAR checking is performed by the last two commands, which may reveal
some other unforeseeable error(s). Also, take note of the scaling factor because PROSTAR
only applies the factor for STAR-CD and not the geometry. If the factor is not 1, use the
scalePoints utility in OpenFOAM.
5.5.2.5 Writing out the mesh data
Once the mesh is completed, place all the integral matches of the model into the couple
type 1. All other types will be used to indicate arbitrary matches.
CPSET NEWS TYPE INTEGRAL
CPMOD CPSET 1
Open∇FOAM-2.2.0
U-158 Mesh generation and conversion
The components of the computational grid must then be written to their own ﬁles. This
is done using PROSTAR for boundaries by issuing the command
BWRITE
by default, this writes to a .23 ﬁle (versions prior to 3.0) or a .bnd ﬁle (versions 3.0 and
higher). For cells, the command
CWRITE
outputs the cells to a .14 or .cel ﬁle and for vertices, the command
VWRITE
outputs to ﬁle a .15 or .vrt ﬁle. The current default setting writes the ﬁles in ASCII
format. If couples are present, an additional couple ﬁle with the extension .cpl needs to
be written out by typing:
CPWRITE
After outputting to the three ﬁles, exit PROSTAR or close the ﬁles. Look through
the panels and take note of all STAR-CD sub-models, material and ﬂuid properties used
– the material properties and mathematical model will need to be set up by creating and
editing OpenFOAM dictionary ﬁles.
The procedure of converting the PROSTAR ﬁles is ﬁrst to create a new OpenFOAM
case by creating the necessary directories. The PROSTAR ﬁles must be stored within the
same directory and the user must change the ﬁle extensions: from .23, .14 and .15 (below
STAR-CD version 3.0), or .pcs, .cls and .vtx (STAR-CD version 3.0 and above); to .bnd,
.cel and .vrt respectively.
5.5.2.6 Problems with the .vrt ﬁle
The .vrt ﬁle is written in columns of data of speciﬁed width, rather than free format. A
typical line of data might be as follows, giving a vertex number followed by the coordi-
nates:
19422 -0.105988957 -0.413711881E-02 0.000000000E+00
If the ordinates are written in scientiﬁc notation and are negative, there may be no space
between values, e.g.:
19423 -0.953953117E-01-0.338810333E-02 0.000000000E+00
The starToFoam converter reads the data using spaces to delimit the ordinate values and
will therefore object when reading the previous example. Therefore, OpenFOAM includes
a simple script, foamCorrectVrt to insert a space between values where necessary, i.e. it
would convert the previous example to:
19423 -0.953953117E-01 -0.338810333E-02 0.000000000E+00
The foamCorrectVrt script should therefore be executed if necessary before running the
starToFoam converter, by typing:
foamCorrectVrt <file>.vrt
Open∇FOAM-2.2.0
5.5 Mesh conversion U-159
5.5.2.7 Converting the mesh to OpenFOAM format
The translator utility starToFoam can now be run to create the boundaries, cells and
points ﬁles necessary for a OpenFOAM run:
starToFoam <meshFilePrefix>
where <meshFilePreﬁx> is the name of the the preﬁx of the mesh ﬁles, including the
full or relative path. After the utility has ﬁnished running, OpenFOAM boundary types
should be speciﬁed by editing the boundary ﬁle by hand.
5.5.3 gambitToFoam
GAMBIT writes mesh data to a single ﬁle with a .neu extension. The procedure of con-
verting a GAMBIT.neu ﬁle is ﬁrst to create a new OpenFOAM case, then at a command
prompt, the user should execute:
gambitToFoam <meshFile>
where <meshFile> is the name of the .neu ﬁle, including the full or relative path.
The GAMBIT ﬁle format does not provide information about type of the boundary
patch, e.g. wall, symmetry plane, cyclic. Therefore all the patches have been created as
type patch. Please reset after mesh conversion as necessary.
5.5.4 ideasToFoam
OpenFOAM can convert a mesh generated by I-DEAS but written out in ANSYS format
as a .ans ﬁle. The procedure of converting the .ans ﬁle is ﬁrst to create a new OpenFOAM
case, then at a command prompt, the user should execute:
ideasToFoam <meshFile>
where <meshFile> is the name of the .ans ﬁle, including the full or relative path.
5.5.5 cfx4ToFoam
CFX writes mesh data to a single ﬁle with a .geo extension. The mesh format in CFX is
block-structured, i.e. the mesh is speciﬁed as a set of blocks with glueing information and
the vertex locations. OpenFOAM will convert the mesh and capture the CFX boundary
condition as best as possible. The 3 dimensional ‘patch’ deﬁnition in CFX, containing
information about the porous, solid regions etc. is ignored with all regions being converted
into a single OpenFOAM mesh. CFX supports the concept of a ‘default’ patch, where
each external face without a deﬁned boundary condition is treated as a wall. These faces
are collected by the converter and put into a defaultFaces patch in the OpenFOAM
mesh and given the type wall; of course, the patch type can be subsequently changed.
Like, OpenFOAM 2 dimensional geometries in CFX are created as 3 dimensional
meshes of 1 cell thickness. If a user wishes to run a 2 dimensional case on a mesh created
by CFX, the boundary condition on the front and back planes should be set to empty;
the user should ensure that the boundary conditions on all other faces in the plane of the
calculation are set correctly. Currently there is no facility for creating an axi-symmetric
geometry from a 2 dimensional CFX mesh.
The procedure of converting a CFX.geo ﬁle is ﬁrst to create a new OpenFOAM case,
then at a command prompt, the user should execute:
Open∇FOAM-2.2.0
U-160 Mesh generation and conversion
cfx4ToFoam <meshFile>
where <meshFile> is the name of the .geo ﬁle, including the full or relative path.
5.6 Mapping ﬁelds between diﬀerent geometries
The mapFields utility maps one or more ﬁelds relating to a given geometry onto the
corresponding ﬁelds for another geometry. It is completely generalised in so much as
there does not need to be any similarity between the geometries to which the ﬁelds relate.
However, for cases where the geometries are consistent, mapFields can be executed with
a special option that simpliﬁes the mapping process.
For our discussion of mapFields we need to deﬁne a few terms. First, we say that
the data is mapped from the source to the target. The ﬁelds are deemed consistent if
the geometry and boundary types, or conditions, of both source and target ﬁelds are
identical. The ﬁeld data that mapFields maps are those ﬁelds within the time directory
speciﬁed by startFrom/startTime in the controlDict of the target case. The data is read
from the equivalent time directory of the source case and mapped onto the equivalent
time directory of the target case.
5.6.1 Mapping consistent ﬁelds
A mapping of consistent ﬁelds is simply performed by executing mapFields on the (target)
case using the -consistent command line option as follows:
mapFields <source dir> -consistent
5.6.2 Mapping inconsistent ﬁelds
When the ﬁelds are not consistent, as shown in Figure 5.16, mapFields requires a map-
FieldsDict dictionary in the system directory of the target case. The following rules apply
to the mapping:
• the ﬁeld data is mapped from source to target wherever possible, i.e. in our example
all the ﬁeld data within the target geometry is mapped from the source, except those
in the shaded region which remain unaltered;
• the patch ﬁeld data is left unaltered unless speciﬁed otherwise in the mapFieldsDict
dictionary.
The mapFieldsDict dictionary contain two lists that specify mapping of patch data. The
ﬁrst list is patchMap that speciﬁes mapping of data between pairs of source and target
patches that are geometrically coincident, as shown in Figure 5.16. The list contains
each pair of names of source and target patch. The second list is cuttingPatches that
contains names of target patches whose values are to be mapped from the source internal
ﬁeld through which the target patch cuts. In the situation where the target patch only
cuts through part of the source internal ﬁeld, e.g. bottom left target patch in our example,
those values within the internal ﬁeld are mapped and those outside remain unchanged.
An example mapFieldsDict dictionary is shown below:
Open∇FOAM-2.2.0
5.6 Mapping ﬁelds between diﬀerent geometries U-161
Internal target patches:
can be mapped using cuttingPatches
Target ﬁeld geometry
Source ﬁeld geometry
can be mapped using patchMap
Coincident patches:
Figure 5.16: Mapping inconsistent ﬁelds
17
18 patchMap ( lid movingWall );
19
20 cuttingPatches ( fixedWalls );
21
22
23 // ************************************************************************* //
mapFields <source dir>
5.6.3 Mapping parallel cases
If either or both of the source and target cases are decomposed for running in parallel,
additional options must be supplied when executing mapFields:
-parallelSource if the source case is decomposed for parallel running;
-parallelTarget if the target case is decomposed for parallel running.
Open∇FOAM-2.2.0
U-162 Mesh generation and conversion
Open∇FOAM-2.2.0
Chapter 6
Post-processing
This chapter describes options for post-processing with OpenFOAM. OpenFOAM is sup-
plied with a post-processing utility paraFoam that uses ParaView, an open source visuali-
sation application described in section 6.1.
Other methods of post-processing using third party products are oﬀered, including
EnSight, Fieldview and the post-processing supplied with Fluent.
6.1 paraFoam
The main post-processing tool provided with OpenFOAM is a reader module to run
with ParaView, an open-source, visualization application. The module is compiled into
2 libraries, PV3FoamReader and vtkPV3Foam using version 3.12.0 of ParaView supplied
with the OpenFOAM release (PVFoamReader and vtkFoam in ParaView version 2.x). It
is recommended that this version of ParaView is used, although it is possible that the
latest binary release of the software will run adequately. Further details about ParaView
can be found at http://www.paraview.org and further documentation is available at
http://www.kitware.com/products/paraviewguide.html.
ParaView uses the Visualisation Toolkit (VTK) as its data processing and rendering
engine and can therefore read any data in VTK format. OpenFOAM includes the foam-
ToVTK utility to convert data from its native format to VTK format, which means that
any VTK-based graphics tools can be used to post-process OpenFOAM cases. This pro-
vides an alternative means for using ParaView with OpenFOAM. For users who wish
to experiment with advanced, parallel visualisation, there is also the free VisIt software,
available at http://www.llnl.gov/visit.
In summary, we recommend the reader module for ParaView as the primary post-
processing tool for OpenFOAM. Alternatively OpenFOAM data can be converted into
VTK format to be read by ParaView or any other VTK -based graphics tools.
6.1.1 Overview of paraFoam
paraFoam is strictly a script that launches ParaView using the reader module supplied
with OpenFOAM. It is executed like any of the OpenFOAM utilities either by the single
command from within the case directory or with the -case option with the case path as
an argument, e.g.:
paraFoam -case <caseDir>
ParaView is launched and opens the window shown in Figure 6.1. The case is controlled
from the left panel, which contains the following:
U-164 Post-processing
Figure 6.1: The paraFoam window
Pipeline Browser lists the modules opened in ParaView, where the selected modules are
highlighted in blue and the graphics for the given module can be enabled/disabled
by clicking the eye button alongside;
Properties panel contains the input selections for the case, such as times, regions and
ﬁelds;
Display panel controls the visual representation of the selected module, e.g. colours;
Information panel gives case statistics such as mesh geometry and size.
ParaView operates a tree-based structure in which data can be ﬁltered from the top-
level case module to create sets of sub-modules. For example, a contour plot of, say,
pressure could be a sub-module of the case module which contains all the pressure data.
The strength of ParaView is that the user can create a number of sub-modules and display
whichever ones they feel to create the desired image or animation. For example, they
may add some solid geometry, mesh and velocity vectors, to a contour plot of pressure,
switching any of the items on and oﬀ as necessary.
The general operation of the system is based on the user making a selection and then
clicking the green Apply button in the Properties panel. The additional buttons are: the
Reset button which can be used to reset the GUI if necessary; and, the Delete button that
will delete the active module.
6.1.2 The Properties panel
The Properties panel for the case module contains the settings for time step, regions and
ﬁelds. The controls are described in Figure 6.2. It is particularly worth noting that
Open∇FOAM-2.2.0
6.1 paraFoam U-165
The user can select internalMesh
region and/or individual patches
read into the case module
The user can select the ﬁelds
Figure 6.2: The Properties panel for the case module
in the current reader module, data in all time directories are loaded into ParaView (in
the reader module for ParaView 2.x, a set of check boxes controlled the time that were
displayed). In the current reader module, the buttons in the Current Time Controls
and VCR Controls toolbars select the time data to be displayed, as shown is section 6.1.4.
As with any operation in paraFoam, the user must click Apply after making any changes
to any selections. The Apply button is highlighted in green to alert the user if changes have
been made but not accepted. This method of operation has the advantage of allowing the
user to make a number of selections before accepting them, which is particularly useful
in large cases where data processing is best kept to a minimum.
There are occasions when the case data changes on ﬁle and ParaView needs to load the
changes, e.g. when ﬁeld data is written into new time directories. To load the changes,
the user should check the Update GUI button at the top of the Properties panel and then
apply the changes.
6.1.3 The Display panel
The Display panel contains the settings for visualising the data for a given case module.
The following points are particularly important:
• the data range may not be automatically updated to the max/min limits of a ﬁeld,
so the user should take care to select Rescale to Data Range at appropriate intervals,
in particular after loading the initial case module;
• clicking the Edit Color Map button, brings up a window in which there are two
panels:
Open∇FOAM-2.2.0
U-166 Post-processing
Outline, surface, wireframe or points
Data interpolation method
Change image opacity
e.g. to make transluscent
View case data
Colour geometry/entity by...
Set colour map range/appearance
Geometry manipulation tools
Figure 6.3: The Display panel
1. The Color Scale panel in which the colours within the scale can be chosen. The
standard blue to red colour scale for CFD can be selected by clicking Choose
Preset and selecting Blue to Red Rainbox HSV.
2. The Color Legend panel has a toggle switch for a colour bar legend and contains
settings for the layout of the legend, e.g. font.
• the underlying mesh can be represented by selecting Wireframe in the Represent-
ation menu of the Style panel;
• the geometry, e.g. a mesh (if Wireframe is selected), can be visualised as a single
colour by selecting Solid Color from the Color By menu and specifying the colour
in the Set Ambient Color window;
Open∇FOAM-2.2.0
6.1 paraFoam U-167
• the image can be made translucent by editing the value in the Opacity text box (1
= solid, 0 = invisible) in the Style panel.
6.1.4 The button toolbars
ParaView duplicates functionality from pull-down menus at the top of the main window
and the major panels, within the toolbars below the main pull-down menus. The displayed
toolbars can be selected from Toolbars in the main View menu. The default layout with
all toolbars is shown in Figure 6.4 with each toolbar labelled. The function of many of
the buttons is clear from their icon and, with tooltips enabled in the Help menu, the user
is given a concise description of the function of any button.
Selection Controls VCR Controls
Common Filters Camera Controls
Centre Axes Controls
Undo/Redo ControlsMain controls Current Time Controls
Active Variable Controls | Representation
Figure 6.4: Toolbars in ParaView
6.1.5 Manipulating the view
This section describes operations for setting and manipulating the view of objects in
paraFoam.
6.1.5.1 View settings
The View Settings are selected from the Edit menu, which opens a View Settings (Render
View) window with a table of 3 items: General, Lights and Annotation. The General panel
includes the following items which are often worth setting at startup:
• the background colour, where white is often a preferred choice for printed material,
is set by choosing background from the down-arrow button next to Choose Color
button, then selecting the color by clicking on the Choose Color button;
• Use parallel projection which is the usual choice for CFD, especially for 2D cases.
The Lights panel contains detailed lighting controls within the Light Kit panel. A
separate Headlight panel controls the direct lighting of the image. Checking the Headlight
button with white light colour of strength 1 seems to help produce images with strong
bright colours, e.g. with an isosurface.
The Annotation panel includes options for including annotations in the image. The
Orientation Axes feature controls an axes icon in the image window, e.g. to set the colour
of the axes labels x, y and z.
Open∇FOAM-2.2.0
U-168 Post-processing
6.1.5.2 General settings
The general Settings are selected from the Edit menu, which opens a general Options
window with General, Colors, Animations, Charts and Render View menu items.
The General panel controls some default behaviour of ParaView. In particular, there
is an Auto Accept button that enables ParaView to accept changes automatically without
clicking the green Apply button in the Properties window. For larger cases, this option is
generally not recommended: the user does not generally want the image to be re-rendered
between each of a number of changes he/she selects, but be able to apply a number of
changes to be re-rendered in their entirety once.
The Render View panel contains 3 sub-items: General, Camera and Server. The General
panel includes the level of detail (LOD) which controls the rendering of the image while it
is being manipulated, e.g. translated, resized, rotated; lowering the levels set by the sliders,
allows cases with large numbers of cells to be re-rendered quickly during manipulation.
The Camera panel includes control settings for 3D and 2D movements. This presents
the user with a map of rotation, translate and zoom controls using the mouse in combi-
nation with Shift- and Control-keys. The map can be edited to suit by the user.
6.1.6 Contour plots
A contour plot is created by selecting Contour from the Filter menu at the top menu
bar. The ﬁlter acts on a given module so that, if the module is the 3D case module itself,
the contours will be a set of 2D surfaces that represent a constant value, i.e. isosurfaces.
The Properties panel for contours contains an Isosurfaces list that the user can edit, most
conveniently by the New Range window. The chosen scalar ﬁeld is selected from a pull
down menu.
6.1.6.1 Introducing a cutting plane
Very often a user will wish to create a contour plot across a plane rather than producing
isosurfaces. To do so, the user must ﬁrst use the Slice ﬁlter to create the cutting plane,
on which the contours can be plotted. The Slice ﬁlter allows the user to specify a cutting
Plane, Box or Sphere in the Slice Type menu by a center and normal/radius respectively.
The user can manipulate the cutting plane like any other using the mouse.
The user can then run the Contour ﬁlter on the cut plane to generate contour lines.
6.1.7 Vector plots
Vector plots are created using the Glyph ﬁlter. The ﬁlter reads the ﬁeld selected in
Vectors and oﬀers a range of Glyph Types for which the Arrow provides a clear vector
plot images. Each glyph has a selection of graphical controls in a panel which the user
can manipulate to best eﬀect.
The remainder of the Properties panel contains mainly the Scale Mode menu for the
glyphs. The most common options are Scale Mode are: Vector, where the glyph length
is proportional to the vector magnitude; and, Off where each glyph is the same length.
The Set Scale Factor parameter controls the base length of the glyphs.
6.1.7.1 Plotting at cell centres
Vectors are by default plotted on cell vertices but, very often, we wish to plot data at cell
centres. This is done by ﬁrst applying the Cell Centers ﬁlter to the case module, and
then applying the Glyph ﬁlter to the resulting cell centre data.
Open∇FOAM-2.2.0
6.1 paraFoam U-169
6.1.8 Streamlines
Streamlines are created by ﬁrst creating tracer lines using the Stream Tracer ﬁlter. The
tracer Seed panel speciﬁes a distribution of tracer points over a Line Source or Point
Cloud. The user can view the tracer source, e.g. the line, but it is displayed in white, so
they may need to change the background colour in order to see it.
The distance the tracer travels and the length of steps the tracer takes are speciﬁed in
the text boxes in the main Stream Tracer panel. The process of achieving desired tracer
lines is largely one of trial and error in which the tracer lines obviously appear smoother
as the step length is reduced but with the penalty of a longer calculation time.
Once the tracer lines have been created, the Tubes ﬁlter can be applied to the Tracer
module to produce high quality images. The tubes follow each tracer line and are not
strictly cylindrical but have a ﬁxed number of sides and given radius. When the number
of sides is set above, say, 10, the tubes do however appear cylindrical, but again this adds
a computational cost.
6.1.9 Image output
The simplest way to output an image to ﬁle from ParaView is to select Save Screenshot
from the File menu. On selection, a window appears in which the user can select the
resolution for the image to save. There is a button that, when clicked, locks the aspect
ratio, so if the user changes the resolution in one direction, the resolution is adjusted in
the other direction automatically. After selecting the pixel resolution, the image can be
saved. To achieve high quality output, the user might try setting the pixel resolution to
1000 or more in the x-direction so that when the image is scaled to a typical size of a
ﬁgure in an A4 or US letter document, perhaps in a PDF document, the resolution is
sharp.
6.1.10 Animation output
To create an animation, the user should ﬁrst select Save Animation from the File menu.
A dialogue window appears in which the user can specify a number of things including
the image resolution. The user should specify the resolution as required. The other
noteworthy setting is number of frames per timestep. While this would intuitively be
set to 1, it can be set to a larger number in order to introduce more frames into the
animation artiﬁcially. This technique can be particularly useful to produce a slower
animation because some movie players have limited speed control, particularly over mpeg
movies.
On clicking the Save Animation button, another window appears in which the user spec-
iﬁes a ﬁle name root and ﬁle format for a set of images. On clicking OK, the set of ﬁles will
be saved according to the naming convention “<fileRoot> <imageNo>.<fileExt>”,
e.g. the third image of a series with the ﬁle root “animation”, saved in jpg format would
be named “animation 0002.jpg” (<imageNo> starts at 0000).
Once the set of images are saved the user can convert them into a movie using their
software of choice. The convert utility in the ImageMagick package can do this from the
command line, e.g. by
convert animation*jpg movie.mpg
When creating an mpg movie it can be worth increasing the default quality setting, e.g.
with -quality 90%, to reduce the graininess that can occur with the default setting.
Open∇FOAM-2.2.0
U-170 Post-processing
6.2 Post-processing with Fluent
It is possible to use Fluent as a post-processor for the cases run in OpenFOAM. Two con-
verters are supplied for the purpose: foamMeshToFluent which converts the OpenFOAM
mesh into Fluent format and writes it out as a .msh ﬁle; and, foamDataToFluent con-
verts the OpenFOAM results data into a .dat ﬁle readable by Fluent. foamMeshToFluent
is executed in the usual manner. The resulting mesh is written out in a ﬂuentInterface
subdirectory of the case directory, i.e.<caseName>/ﬂuentInterface/<caseName>.msh
foamDataToFluent converts the OpenFOAM data results into the Fluent format. The
conversion is controlled by two ﬁles. First, the controlDict dictionary speciﬁes startTime,
giving the set of results to be converted. If you want to convert the latest result,
startFrom can be set to latestTime. The second ﬁle which speciﬁes the translation
is the foamDataToFluentDict dictionary, located in the constant directory. An example
foamDataToFluentDict dictionary is given below:
1 /*--------------------------------*- C++ -*----------------------------------*\
2 | ========= | |
3 | \\ / F ield | OpenFOAM: The Open Source CFD Toolbox |
4 | \\ / O peration | Version: 2.2.0 |
5 | \\ / A nd | Web: www.OpenFOAM.org |
6 | \\/ M anipulation | |
7 \*---------------------------------------------------------------------------*/
8 FoamFile
9 {
10 version 2.0;
11 format ascii;
12 class dictionary;
13 location "system";
14 object foamDataToFluentDict;
15 }
16 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
17
18 p 1;
19
20 U 2;
21
22 T 3;
23
24 h 4;
25
26 k 5;
27
28 epsilon 6;
29
30 alpha1 150;
31
32
33 // ************************************************************************* //
The dictionary contains entries of the form
<fieldName> <fluentUnitNumber>
The <fluentUnitNumber> is a label used by the Fluent post-processor that only recog-
nises a ﬁxed set of ﬁelds. The basic set of <fluentUnitNumber> numbers are quoted in
Table 6.1. The dictionary must contain all the entries the user requires to post-process,
e.g. in our example we have entries for pressure p and velocity U. The list of default entries
described in Table 6.1. The user can run foamDataToFluent like any utility.
To view the results using Fluent, go to the ﬂuentInterface subdirectory of the case
directory and start a 3 dimensional version of Fluent with
fluent 3d
The mesh and data ﬁles can be loaded in and the results visualised. The mesh is read
by selecting Read Case from the File menu. Support items should be selected to read
Open∇FOAM-2.2.0
6.3 Post-processing with Fieldview U-171
Fluent name Unit number Common OpenFOAM name
PRESSURE 1 p
MOMENTUM 2 U
TEMPERATURE 3 T
ENTHALPY 4 h
TKE 5 k
TED 6 epsilon
SPECIES 7 —
G 8 —
XF RF DATA VOF 150 gamma
TOTAL PRESSURE 192 —
TOTAL TEMPERATURE 193 —
Table 6.1: Fluent unit numbers for post-processing.
certain data types, e.g. to read turbulence data for k and epsilon, the user would select
k-epsilon from the Define->Models->Viscous menu. The data can then be read by
selecting Read Data from the File menu.
A note of caution: users MUST NOT try to use an original Fluent mesh ﬁle that has
been converted to OpenFOAM format in conjunction with the OpenFOAM solution that
has been converted to Fluent format since the alignment of zone numbering cannot be
guaranteed.
6.3 Post-processing with Fieldview
OpenFOAM oﬀers the capability for post-processing OpenFOAM cases with Fieldview.
The method involves running a post-processing utility foamToFieldview to convert case
data from OpenFOAM to Fieldview.uns ﬁle format. For a given case, foamToFieldview is
executed like any normal application. foamToFieldview creates a directory named Fieldview
in the case directory, deleting any existing Fieldview directory in the process. By default
the converter reads the data in all time directories and writes into a set of ﬁles of the
form <case> nn.uns, where nn is an incremental counter starting from 1 for the ﬁrst time
directory, 2 for the second and so on. The user may specify the conversion of a single time
directory with the option -time <time>, where <time> is a time in general, scientiﬁc
or ﬁxed format.
Fieldview provides certain functions that require information about boundary condi-
tions, e.g. drawing streamlines that uses information about wall boundaries. The con-
verter tries, wherever possible, to include this information in the converted ﬁles by default.
The user can disable the inclusion of this information by using the -noWall option in the
execution command.
The data ﬁles for Fieldview have the .uns extension as mentioned already. If the original
OpenFOAM case includes a dot ‘.’, Fieldview may have problems interpreting a set of data
ﬁles as a single case with multiple time steps.
6.4 Post-processing with EnSight
OpenFOAM oﬀers the capability for post-processing OpenFOAM cases with EnSight,
with a choice of 2 options:
Open∇FOAM-2.2.0
U-172 Post-processing
• converting the OpenFOAM data to EnSight format with the foamToEnsight utility;
• reading the OpenFOAM data directly into EnSight using the ensight74FoamExec
module.
6.4.1 Converting data to EnSight format
The foamToEnsight utility converts data from OpenFOAM to EnSight ﬁle format. For a
given case, foamToEnsight is executed like any normal application. foamToEnsight creates
a directory named Ensight in the case directory, deleting any existing Ensight directory in
the process. The converter reads the data in all time directories and writes into a case
ﬁle and a set of data ﬁles. The case ﬁle is named EnSight Case and contains details of
the data ﬁle names. Each data ﬁle has a name of the form EnSight nn.ext, where nn is an
incremental counter starting from 1 for the ﬁrst time directory, 2 for the second and so
on and ext is a ﬁle extension of the name of the ﬁeld that the data refers to, as described
in the case ﬁle, e.g.T for temperature, mesh for the mesh. Once converted, the data can
be read into EnSight by the normal means:
1. from the EnSight GUI, the user should select Data (Reader) from the File menu;
2. the appropriate EnSight Case ﬁle should be highlighted in the Files box;
3. the Format selector should be set to Case, the EnSight default setting;
4. the user should click (Set) Case and Okay.
6.4.2 The ensight74FoamExec reader module
EnSight provides the capability of using a user-deﬁned module to read data from a format
other than the standard EnSight format. OpenFOAM includes its own reader module
ensight74FoamExec that is compiled into a library named libuserd-foam. It is this library
that EnSight needs to use which means that it must be able to locate it on the ﬁling
system as described in the following section.
6.4.2.1 Conﬁguration of EnSight for the reader module
In order to run the EnSight reader, it is necessary to set some environment variables cor-
rectly. The settings are made in the bashrc (or cshrc) ﬁle in the $WM PROJECT DIR/etc/-
apps/ensightFoam directory. The environment variables associated with EnSight are pre-
ﬁxed by $CEI or $ENSIGHT7 and listed in Table 6.2. With a standard user setup, only
$CEI HOME may need to be set manually, to the path of the EnSight installation.
6.4.2.2 Using the reader module
The principal diﬃculty in using the EnSight reader lies in the fact that EnSight expects
that a case to be deﬁned by the contents of a particular ﬁle, rather than a directory as it
is in OpenFOAM. Therefore in following the instructions for the using the reader below,
the user should pay particular attention to the details of case selection, since EnSight does
not permit selection of a directory name.
1. from the EnSight GUI, the user should select Data (Reader) from the File menu;
2. The user should now be able to select the OpenFOAM from the Format menu; if not,
there is a problem with the conﬁguration described above.
Open∇FOAM-2.2.0
6.5 Sampling data U-173
Environment variable Description and options
$CEI HOME Path where EnSight is installed, eg /usr/local/ensight, added
to the system path by default
$CEI ARCH Machine architecture, from a choice of names cor-
responding to the machine directory names in
$CEI HOME/ensight74/machines; default settings include
linux 2.4 and sgi 6.5 n32
$ENSIGHT7 READER Path that EnSight searches for the user deﬁned libuserd-foam
reader library, set by default to $FOAM LIBBIN
$ENSIGHT7 INPUT Set by default to dummy
Table 6.2: Environment variable settings for EnSight.
3. The user should ﬁnd their case directory from the File Selection window, highlight
one of top 2 entries in the Directories box ending in /. or /.. and click (Set)
Geometry.
4. The path ﬁeld should now contain an entry for the case. The (Set) Geometry text
box should contain a ‘/’.
5. The user may now click Okay and EnSight will begin reading the data.
6. When the data is read, a new Data Part Loader window will appear, asking which
part(s) are to be read. The user should select Load all.
7. When the mesh is displayed in the EnSight window the user should close the Data
Part Loader window, since some features of EnSight will not work with this window
open.
6.5 Sampling data
OpenFOAM provides the sample utility to sample ﬁeld data, either through a 1D line
for plotting on graphs or a 2D plane for displaying as isosurface images. The sampling
locations are speciﬁed for a case through a sampleDict dictionary in the case system
directory. The data can be written in a range of formats including well-known graphing
packages such as Grace/xmgr, gnuplot and jPlot.
The sampleDict dictionary can be generated by copying an example sampleDict from
the sample source code directory at $FOAM UTILITIES/postProcessing/sampling/sample.
The plateHole tutorial case in the $FOAM TUTORIALS/solidDisplacementFoam directory
also contains an example for 1D line sampling:
17
18 interpolationScheme cellPoint;
19
20 setFormat raw;
21
22 sets
23 (
24 leftPatch
25 {
26 type uniform;
27 axis y;
28 start ( 0 0.5 0.25 );
29 end ( 0 2 0.25 );
30 nPoints 100;
31 }
32 );
33
Open∇FOAM-2.2.0
U-174 Post-processing
34 fields ( sigmaxx );
35
36
37 // ************************************************************************* //
Keyword Options Description
interpolation-
Scheme
cell
cellPoint
cellPointFace
Cell-centre value assumed constant over cell
Linear weighted interpolation using cell values
Mixed linear weighted / cell-face interpolation
setFormat raw
gnuplot
xmgr
jplot
Raw ASCII data in columns
Data in gnuplot format
Data in Grace/xmgr format
Data in jPlot format
surfaceFormat null
foamFile
dx
vtk
raw
stl
Suppresses output
points, faces, values ﬁle
DX scalar or vector format
VTK ASCII format
xyz values for use with e.g.gnuplotsplot
ASCII STL; just surface, no values
fields List of ﬁelds to be sampled, e.g. for velocity U:
U Writes all components of U
sets List of 1D sets subdictionaries — see Table 6.4
surfaces List of 2D surfaces subdictionaries — see Table 6.5 and Table 6.6
Table 6.3: keyword entries for sampleDict.
The dictionary contains the following entries:
interpolationScheme the scheme of data interpolation;
sets the locations within the domain that the ﬁelds are line-sampled (1D).
surfaces the locations within the domain that the ﬁelds are surface-sampled (2D).
setFormat the format of line data output;
surfaceFormat the format of surface data output;
fields the ﬁelds to be sampled;
The interpolationScheme includes cellPoint and cellPointFace options in which
each polyhedral cell is decomposed into tetrahedra and the sample values are interpolated
from values at the tetrahedra vertices. With cellPoint, the tetrahedra vertices include
the polyhedron cell centre and 3 face vertices. The vertex coincident with the cell centre
inherits the cell centre ﬁeld value and the other vertices take values interpolated from cell
centres. With cellPointFace, one of the tetrahedra vertices is also coincident with a
face centre, which inherits ﬁeld values by conventional interpolation schemes using values
at the centres of cells that the face intersects.
The setFormat entry for line sampling includes a raw data format and formats for
gnuplot, Grace/xmgr and jPlot graph drawing packages. The data are written into a sets
directory within the case directory. The directory is split into a set of time directories and
Open∇FOAM-2.2.0
6.5 Sampling data U-175
the data ﬁles are contained therein. Each data ﬁle is given a name containing the ﬁeld
name, the sample set name, and an extension relating to the output format, including
.xy for raw data, .agr for Grace/xmgr and .dat for jPlot. The gnuplot format has the data
in raw form with an additional commands ﬁle, with .gplt extension, for generating the
graph. Note that any existing sets directory is deleted when sample is run.
The surfaceFormat entry for surface sampling includes a raw data format and formats
for gnuplot, Grace/xmgr and jPlot graph drawing packages. The data are written into a
surfaces directory within the case directory. The directory is split into time directories
and ﬁles are written much as with line sampling.
The fields list contains the ﬁelds that the user wishes to sample. The sample utility
can parse the following restricted set of functions to enable the user to manipulate vector
and tensor ﬁelds, e.g. for U:
U.component(n) writes the nth component of the vector/tensor, n = 0, 1 . . .;
mag(U) writes the magnitude of the vector/tensor.
The sets list contains sub-dictionaries of locations where the data is to be sampled.
The sub-dictionary is named according to the name of the set and contains a set of entries,
also listed in Table 6.4, that describes the locations where the data is to be sampled. For
example, a uniform sampling provides a uniform distribution of nPoints sample locations
along a line speciﬁed by a start and end point. All sample sets are also given: a type;
and, means of specifying the length ordinate on a graph by the axis keyword.
Required entries
Sampling type Sample locations
name
axis
start
end
nPoints
points
uniform Uniformly distributed points on a line • • • • •
face Intersection of speciﬁed line and cell faces • • • •
midPoint Midpoint between line-face intersections • • • •
midPointAndFace Combination of midPoint and face • • • •
curve Speciﬁed points, tracked along a curve • • •
cloud Speciﬁed points • • •
Entries Description Options
type Sampling type see list above
axis Output of sample location x x ordinate
y y ordinate
z z ordinate
xyz xyz coordinates
distance distance from point 0
start Start point of sample line e.g.(0.0 0.0 0.0)
end End point of sample line e.g.(0.0 2.0 0.0)
nPoints Number of sampling points e.g.200
points List of sampling points
Table 6.4: Entries within sets sub-dictionaries.
The surfaces list contains sub-dictionaries of locations where the data is to be sam-
pled. The sub-dictionary is named according to the name of the surface and contains
Open∇FOAM-2.2.0
U-176 Post-processing
Keyword Description Options
basePoint Point on plane e.g.(0 0 0)
normalVector Normal vector to plane e.g.(1 0 0)
interpolate Interpolate data? true/false
triangulate Triangulate surface? (optional) true/false
Table 6.5: Entries for a plane in surfaces sub-dictionaries.
Keyword Description Options
patchName Name of patch e.g.movingWall
interpolate Interpolate data? true/false
triangulate Triangulate surface? (optional) true/false
Table 6.6: Entries for a patch in surfaces sub-dictionaries.
a set of entries beginning with the type: either a plane, deﬁned by point and normal
direction, with additional sub-dictionary entries speciﬁed in Table 6.5; or, a patch, coin-
ciding with an existing boundary patch, with additional sub-dictionary entries a speciﬁed
in Table 6.6.
6.6 Monitoring and managing jobs
This section is concerned primarily with successful running of OpenFOAM jobs and ex-
tends on the basic execution of solvers described in section 3.3. When a solver is executed,
it reports the status of equation solution to standard output, i.e. the screen, if the level
debug switch is set to 1 or 2 (default) in DebugSwitches in the $WM PROJECT DIR/etc/-
controlDict ﬁle. An example from the beginning of the solution of the cavity tutorial is
shown below where it can be seen that, for each equation that is solved, a report line is
written with the solver name, the variable that is solved, its initial and ﬁnal residuals and
number of iterations.
Starting time loop
Time = 0.005
Max Courant Number = 0
BICCG: Solving for Ux, Initial residual = 1, Final residual = 2.96338e-06, No Iterations 8
ICCG: Solving for p, Initial residual = 1, Final residual = 4.9336e-07, No Iterations 35
time step continuity errors : sum local = 3.29376e-09, global = -6.41065e-20, cumulative = -6.41065e-20
ICCG: Solving for p, Initial residual = 0.47484, Final residual = 5.41068e-07, No Iterations 34
time step continuity errors : sum local = 6.60947e-09, global = -6.22619e-19, cumulative = -6.86725e-19
ExecutionTime = 0.14 s
Time = 0.01
Max Courant Number = 0.585722
BICCG: Solving for Ux, Initial residual = 0.148584, Final residual = 7.15711e-06, No Iterations 6
BICCG: Solving for Uy, Initial residual = 0.256618, Final residual = 8.94127e-06, No Iterations 6
ICCG: Solving for p, Initial residual = 0.37146, Final residual = 6.67464e-07, No Iterations 33
time step continuity errors : sum local = 6.34431e-09, global = 1.20603e-19, cumulative = -5.66122e-19
ICCG: Solving for p, Initial residual = 0.271556, Final residual = 3.69316e-07, No Iterations 33
time step continuity errors : sum local = 3.96176e-09, global = 6.9814e-20, cumulative = -4.96308e-19
ExecutionTime = 0.16 s
Time = 0.015
Max Courant Number = 0.758267
Open∇FOAM-2.2.0
6.6 Monitoring and managing jobs U-177
BICCG: Solving for Ux, Initial residual = 0.0448679, Final residual = 2.42301e-06, No Iterations 6
BICCG: Solving for Uy, Initial residual = 0.0782042, Final residual = 1.47009e-06, No Iterations 7
ICCG: Solving for p, Initial residual = 0.107474, Final residual = 4.8362e-07, No Iterations 32
time step continuity errors : sum local = 3.99028e-09, global = -5.69762e-19, cumulative = -1.06607e-18
ICCG: Solving for p, Initial residual = 0.0806771, Final residual = 9.47171e-07, No Iterations 31
time step continuity errors : sum local = 7.92176e-09, global = 1.07533e-19, cumulative = -9.58537e-19
ExecutionTime = 0.19 s
6.6.1 The foamJob script for running jobs
The user may be happy to monitor the residuals, iterations, Courant number etc. as
report data passes across the screen. Alternatively, the user can redirect the report to a
log ﬁle which will improve the speed of the computation. The foamJob script provides
useful options for this purpose with the following executing the speciﬁed <solver> as a
background process and redirecting the output to a ﬁle named log:
foamJob <solver>
For further options the user should execute foamJob -help. The user may monitor the
log ﬁle whenever they wish, using the UNIXtail command, typically with the -f ‘follow’
option which appends the new data as the log ﬁle grows:
tail -f log
6.6.2 The foamLog script for monitoring jobs
There are limitations to monitoring a job by reading the log ﬁle, in particular it is diﬃcult
to extract trends over a long period of time. The foamLog script is therefore provided to
extract data of residuals, iterations, Courant number etc. from a log ﬁle and present it in
a set of ﬁles that can be plotted graphically. The script is executed by:
foamLog <logFile>
The ﬁles are stored in a subdirectory of the case directory named logs. Each ﬁle has
the name <var> <subIter> where <var> is the name of the variable speciﬁed in the log
ﬁle and <subIter> is the iteration number within the time step. Those variables that
are solved for, the initial residual takes the variable name <var> and ﬁnal residual takes
<var>FinalRes. By default, the ﬁles are presented in two-column format of time and the
extracted values.
For example, in the cavity tutorial we may wish to observe the initial residual of the
Ux equation to see whether the solution is converging to a steady-state. In that case, we
would plot the data from the logs/Ux 0 ﬁle as shown in Figure 6.5. It can be seen here
that the residual falls monotonically until it reaches the convergence tolerance of 10−5
.
foamLog generates ﬁles for everything it feasibly can from the log ﬁle. In the cavity
tutorial example, this includes:
• the Courant number, Courant 0;
• Ux equation initial and ﬁnal residuals, Ux 0 and UxFinalRes 0, and iterations,
UxIters 0 (and equivalent Uy data);
• cumulative, global and local continuity errors after each of the 2 p equations,
contCumulative 0, contGlobal 0, contLocal 0 and contCumulative 1, contGlobal 1,
contLocal 1;
Open∇FOAM-2.2.0
U-178 Post-processing
Time [s]
Ux0
0.180.160.140.120.100.080.060.040.020.00
1e+00
1e-01
1e-02
1e-03
1e-04
1e-05
Figure 6.5: Initial residual of Ux in the cavity tutorial
• residuals and iterations from the the 2 p equations p 0, pFinalRes 0, pIters 0 and
p 1, pFinalRes 1, pIters 1;
• and execution time, executionTime.
Open∇FOAM-2.2.0
Chapter 7
Models and physical properties
OpenFOAM includes a large range of solvers each designed for a speciﬁc class of problem.
The equations and algorithms diﬀer from one solver to another so that the selection of
a solver involves the user making some initial choices on the modelling for their partic-
ular case. The choice of solver typically involves scanning through their descriptions in
Table 3.5 to ﬁnd the one suitable for the case. It ultimately determines many of the pa-
rameters and physical properties required to deﬁne the case but leaves the user with some
modelling options that can be speciﬁed at runtime through the entries in dictionary ﬁles
in the constant directory of a case. This chapter deals with many of the more common
models and associated properties that may be speciﬁed at runtime.
7.1 Thermophysical models
Thermophysical models are concerned with the energy, heat and physical properties.
The thermophysicalProperties dictionary is read by any solver that uses the thermophys-
ical model library. A thermophysical model is constructed in OpenFOAM as a pressure-
temperature p − T system from which other properties are computed. There is one com-
pulsory dictionary entry called thermoType which speciﬁes the complete thermophysical
model that is used in the simulation. The thermophysical modelling starts with a layer
that deﬁnes the basic equation of state and then adds more layers of modelling that de-
rive properties from the previous layer(s). The naming of the thermoType reﬂects these
multiple layers of modelling as listed in Table 7.1.
Equation of State — equationOfState
icoPolynomial Incompressible polynomial equation of state, e.g. for liquids
perfectGas Perfect gas equation of state
Basic thermophysical properties — thermo
eConstThermo Constant speciﬁc heat cp model with evaluation of internal
energy e and entropy s
hConstThermo Constant speciﬁc heat cp model with evaluation of enthalpy
h and entropy s
hPolynomialThermo cp evaluated by a function with coeﬃcients from polynomi-
als, from which h, s are evaluated
janafThermo cp evaluated by a function with coeﬃcients from JANAF
thermodynamic tables, from which h, s are evaluated
Derived thermophysical properties — specieThermo
Continued on next page
U-180 Models and physical properties
Continued from previous page
specieThermo Thermophysical properties of species, derived from cp, h
and/or s
Transport properties — transport
constTransport Constant transport properties
polynomialTransport Polynomial based temperature-dependent transport prop-
erties
sutherlandTransport Sutherland’s formula for temperature-dependent transport
properties
Mixture properties — mixture
pureMixture General thermophysical model calculation for passive gas
mixtures
homogeneousMixture Combustion mixture based on normalised fuel mass frac-
tion b
inhomogeneousMixture Combustion mixture based on b and total fuel mass fraction
ft
veryInhomogeneousMixture Combustion mixture based on b, ft and unburnt fuel mass
fraction fu
dieselMixture Combustion mixture based on ft and fu
basicMultiComponent-
Mixture
Basic mixture based on multiple components
multiComponentMixture Derived mixture based on multiple components
reactingMixture Combustion mixture using thermodynamics and reaction
schemes
egrMixture Exhaust gas recirculation mixture
Thermophysical model — thermoModel
hPsiThermo General thermophysical model calculation based on en-
thalpy h and compressibility ψ
hsPsiThermo General thermophysical model calculation based on sensi-
ble enthalpy hs and compressibility ψ
ePsiThermo General thermophysical model calculation based on inter-
nal energy e and compressibility ψ
hRhoThermo General thermophysical model calculation based on en-
thalpy h
hsRhoThermo General thermophysical model calculation based on sensi-
ble enthalpy hs
hPsiMixtureThermo Calculates enthalpy for combustion mixture based on en-
thalpy h and ψ
hsPsiMixtureThermo Calculates enthalpy for combustion mixture based on sen-
sible enthalpy hs and ψ
hRhoMixtureThermo Calculates enthalpy for combustion mixture based on en-
thalpy h and ρ
hsRhoMixtureThermo Calculates enthalpy for combustion mixture based on sen-
sible enthalpy hs and ρ
hhuMixtureThermo Calculates enthalpy for unburnt gas and combustion mix-
ture
Continued on next page
Open∇FOAM-2.2.0
7.1 Thermophysical models U-181
Continued from previous page
Table 7.1: Layers of thermophysical modelling.
The following is an example entry for thermoType:
thermoType
{
type hePsiThermo;
mixture pureMixture;
transport const;
thermo hConst;
equationOfState perfectGas;
specie specie;
energy sensibleEnthalpy;
}
The keyword entries specify the choice of thermophysical models, e.g. constant transport
(constant viscosity, thermal diﬀusion), Perfect Gas equationOfState, etc. In addition
there is a keyword entry named energy that allows the user to specify the form of energy
to be used in the solution and thermodynamics. The energy can be internal energy
or enthalpy and in forms that include the heat of formation ∆hf or not. We refer to
absolute energy where heat of formation is included, and sensible energy where it is not.
For example absolute enthalpy h is related to sensible enthalpy hs by
h = hs +
i
ci∆hi
f (7.1)
where ci and hi
f are the molar fraction and heat of formation, respectively, of specie
i. In most cases, we use the sensible form of energy, for which it is easier to account
for energy change due to reactions. Keyword entries for energy therefore include e.g.
sensibleEnthalpy, sensibleInternalEnergy and absoluteEnthalpy.
7.1.1 Thermophysical property data
The basic thermophysical properties are speciﬁed for each species from input data. Data
entries must contain the name of the specie as the keyword, e.g. O2, H2O, mixture, followed
by sub-dictionaries of coeﬃcients, including:
specie containing i.e. number of moles, nMoles, of the specie, and molecular weight,
molWeight in units of g/mol;
thermodynamics containing coeﬃcients for the chosen thermodynamic model (see be-
low);
transport containing coeﬃcients for the chosen tranpsort model (see below).
The thermodynamic coeﬃcients are ostensibly concerned with evaluating the speciﬁc
heat cp from which other properties are derived. The current thermo models are described
as follows:
hConstThermo assumes a constant cp and a heat of fusion Hf which is simply speciﬁed
by a two values cp Hf , given by keywords Cp and Hf.
Open∇FOAM-2.2.0
U-182 Models and physical properties
eConstThermo assumes a constant cv and a heat of fusion Hf which is simply speciﬁed
by a two values cv Hf , given by keywords Cv and Hf.
janafThermo calculates cp as a function of temperature T from a set of coeﬃcients taken
from JANAF tables of thermodynamics. The ordered list of coeﬃcients is given in
Table 7.2. The function is valid between a lower and upper limit in temperature Tl
and Th respectively. Two sets of coeﬃcients are speciﬁed, the ﬁrst set for tempera-
tures above a common temperature Tc (and below Th, the second for temperatures
below Tc (and above Tl). The function relating cp to temperature is:
cp = R((((a4T + a3)T + a2)T + a1)T + a0) (7.2)
In addition, there are constants of integration, a5 and a6, both at high and low
temperature, used to evaluating h and s respectively.
hPolynomialThermo calculates Cp as a function of temperature by a polynomial of any
order. The following case provides an example of its use: $FOAM TUTORIALS/-
lagrangian/porousExplicitSourceReactingParcelFoam/ﬁlter
Description Entry Keyword
Lower temperature limit Tl (K) Tlow
Upper temperature limit Th (K) Thigh
Common temperature Tc (K) Tcommon
High temperature coeﬃcients a0 . . . a4 highCpCoeffs (a0 a1 a2 a3 a4...
High temperature enthalpy oﬀset a5 a5...
High temperature entropy oﬀset a6 a6)
Low temperature coeﬃcients a0 . . . a4 lowCpCoeffs (a0 a1 a2 a3 a4...
Low temperature enthalpy oﬀset a5 a5...
Low temperature entropy oﬀset a6 a6)
Table 7.2: JANAF thermodynamics coeﬃcients.
The transport coeﬃcients are used to to evaluate dynamic viscosity µ, thermal con-
ductivity κ and laminar thermal conductivity (for enthalpy equation) α. The current
transport models are described as follows:
constTransport assumes a constant µ and Prandtl number Pr = cpµ/κ which is simply
speciﬁed by a two keywords, mu and Pr, respectively.
sutherlandTransport calculates µ as a function of temperature T from a Sutherland coef-
ﬁcient As and Sutherland temperature Ts, speciﬁed by keywords As and Ts; µ is
calculated according to:
µ =
As
√
T
1 + Ts/T
(7.3)
polynomialTransport calculates µ and κ as a function of temperature T from a polynomial
of any order.
The following is an example entry for a specie named fuel modelled using sutherland-
Transport and janafThermo:
Open∇FOAM-2.2.0
7.1 Thermophysical models U-183
fuel
{
specie
{
nMoles 1;
molWeight 16.0428;
}
thermodynamics
{
Tlow 200;
Thigh 6000;
Tcommon 1000;
highCpCoeffs (1.63543 0.0100844 -3.36924e-06 5.34973e-10
-3.15528e-14 -10005.6 9.9937);
lowCpCoeffs (5.14988 -0.013671 4.91801e-05 -4.84744e-08
1.66694e-11 -10246.6 -4.64132);
}
transport
{
As 1.67212e-06;
Ts 170.672;
}
}
The following is an example entry for a specie named air modelled using constTransport
and hConstThermo:
air
{
specie
{
nMoles 1;
molWeight 28.96;
}
thermodynamics
{
Cp 1004.5;
Hf 2.544e+06;
}
transport
{
mu 1.8e-05;
Pr 0.7;
}
}
Open∇FOAM-2.2.0
U-184 Models and physical properties
7.2 Turbulence models
The turbulenceProperties dictionary is read by any solver that includes turbulence mod-
elling. Within that ﬁle is the simulationType keyword that controls the type of turbu-
lence modelling to be used, either:
laminar uses no turbulence models;
RASModel uses Reynolds-averaged stress (RAS) modelling;
LESModel uses large-eddy simulation (LES) modelling.
If RASModel is selected, the choice of RAS modelling is speciﬁed in a RASProperties
ﬁle, also in the constant directory. The RAS turbulence model is selected by the RASModel
entry from a long list of available models that are listed in Table 3.9. Similarly, if LESModel
is selected, the choice of LES modelling is speciﬁed in a LESProperties dictionary and the
LES turbulence model is selected by the LESModel entry.
The entries required in the RASProperties are listed in Table 7.3 and those for LESProp-
erties dictionaries are listed in Table 7.4.
RASModel Name of RAS turbulence model
turbulence Switch to turn turbulence modelling on/oﬀ
printCoeffs Switch to print model coeﬀs to terminal at simulation startup
<RASModel>Coeffs Optional dictionary of coeﬃcients for the respective RASModel
Table 7.3: Keyword entries in the RASProperties dictionary.
LESModel Name of LES model
delta Name of delta δ model
<LESModel>Coeffs Dictionary of coeﬃcients for the respective LESModel
<delta>Coeffs Dictionary of coeﬃcients for each delta model
Table 7.4: Keyword entries in the LESProperties dictionary.
The incompressible and compressible RAS turbulence models, isochoric and aniso-
choric LES models and delta models are all named and described in Table 3.9. Examples
of their use can be found in the $FOAM TUTORIALS.
7.2.1 Model coeﬃcients
The coeﬃcients for the RAS turbulence models are given default values in their respective
source code. If the user wishes to override these default values, then they can do so by
adding a sub-dictionary entry to the RASProperties ﬁle, whose keyword name is that of
the model with Coeffs appended, e.g. kEpsilonCoeffs for the kEpsilon model. If the
printCoeffs switch is on in the RASProperties ﬁle, an example of the relevant ...Coeffs
dictionary is printed to standard output when the model is created at the beginning of
a run. The user can simply copy this into the RASProperties ﬁle and edit the entries as
required.
Open∇FOAM-2.2.0
7.2 Turbulence models U-185
7.2.2 Wall functions
A range of wall function models is available in OpenFOAM that are applied as boundary
conditions on individual patches. This enables diﬀerent wall function models to be applied
to diﬀerent wall regions. The choice of wall function model is speciﬁed through: νt in the
0/nut ﬁle for incompressible RAS; µt in the 0/mut ﬁle for compressible RAS; νsgs in the
0/nuSgs ﬁle for incompressible LES; µsgs in the 0/muSgs ﬁle for incompressible LES. For
example, a 0/nut ﬁle:
17
18 dimensions [0 2 -1 0 0 0 0];
19
20 internalField uniform 0;
21
22 boundaryField
23 {
24 movingWall
25 {
26 type nutkWallFunction;
27 value uniform 0;
28 }
29 fixedWalls
30 {
31 type nutkWallFunction;
32 value uniform 0;
33 }
34 frontAndBack
35 {
36 type empty;
37 }
38 }
39
40
41 // ************************************************************************* //
There are a number of wall function models available in the release, e.g. nutWallFunction,
nutRoughWallFunction, nutSpalartAllmarasStandardRoughWallFunction, nutSpal-
artAllmarasStandardWallFunction and nutSpalartAllmarasWallFunction. The user
can consult the relevant directories for a full list of wall function models:
find $FOAM SRC/turbulenceModels -name wallFunctions
Within each wall function boundary condition the user can over-ride default settings for
E, κ and Cµ through optional E, kappa and Cmu keyword entries.
Having selected the particular wall functions on various patches in the nut/mut ﬁle,
the user should select epsilonWallFunction on corresponding patches in the epsilon ﬁeld
and kqRwallFunction on corresponding patches in the turbulent ﬁelds k, q and R.
Open∇FOAM-2.2.0
U-186 Models and physical properties
Open∇FOAM-2.2.0
Index U-187
Index
Symbols Numbers A B C D E F G H I J K L M N O P Q R S T U V W X Z
Symbols
*
tensor member function, P-21
+
tensor member function, P-21
-
tensor member function, P-21
/
tensor member function, P-21
/*...*/
C++ syntax, U-76
//
C++ syntax, U-76
OpenFOAM ﬁle syntax, U-104
# include
C++ syntax, U-70, U-76
&
tensor member function, P-21
&&
tensor member function, P-21
^
tensor member function, P-21
<LESModel>Coeffs keyword, U-184
<RASModel>Coeffs keyword, U-184
<delta>Coeffs keyword, U-184
0.000000e+00 directory, U-104
1-dimensional mesh, U-130
1D mesh, U-130
2-dimensional mesh, U-130
2D mesh, U-130
Numbers
0 directory, U-104
A
access functions, P-19
addLayersControls keyword, U-146
adiabaticFlameT utility, U-94
adjointShapeOptimizationFoam solver, U-83
adjustableRunTime
keyword entry, U-60, U-111
adjustTimeStep keyword, U-60, U-112
agglomerator keyword, U-123
algorithms tools, U-95
alphaContactAngle
boundary condition, U-57
analytical solution, P-41
Animations window panel, U-168
anisotropicFilter model, U-99
Annotation window panel, U-24, U-167
ansysToFoam utility, U-89
APIfunctions model, U-98
applications, U-67
Apply button, U-164, U-168
applyBoundaryLayer utility, U-88
applyWallFunctionBoundaryConditions utility,
U-88
arbitrarily unstructured, P-27
arc
keyword entry, U-139
arc keyword, U-138
As keyword, U-182
ascii
keyword entry, U-112
attachMesh utility, U-89
Auto Accept button, U-168
autoMesh
library, U-96
autoPatch utility, U-89
autoReﬁneMesh utility, U-90
axes
right-handed, U-136
right-handed rectangular Cartesian, P-11,
U-18
axi-symmetric cases, U-135, U-144
axi-symmetric mesh, U-130
B
background
process, U-24, U-79
backward
keyword entry, U-119
Backward diﬀerencing, P-35
barotropicCompressibilityModels
library, U-98
Open∇FOAM-2.2.0
U-188 Index
basicMultiComponentMixture model, U-97,
U-180
basicSolidThermo
library, U-99
basicThermophysicalModels
library, U-97
binary
keyword entry, U-112
BirdCarreau model, U-100
blended diﬀerencing, P-34
block
expansion ratio, U-140
block keyword, U-138
blocking
keyword entry, U-78
blockMesh
library, U-96
blockMesh solver, P-43
blockMesh utility, U-36, U-88, U-136
blockMesh executable
vertex numbering, U-140
blockMeshDict
dictionary, U-18, U-20, U-35, U-48, U-136,
U-144
blocks keyword, U-20, U-30, U-140
boundaries, U-132
boundary, U-132
boundary
dictionary, U-129, U-136
boundary keyword, U-141
boundary condition
alphaContactAngle, U-57
buoyantPressure, U-137
calculated, U-136
cyclic, U-135, U-142
directionMixed, U-136
empty, P-59, P-65, U-18, U-130, U-135
ﬁxedGradient, U-136
ﬁxedValue, U-136
ﬂuxCorrectedVelocity, U-137
inlet, P-65
inletOutlet, U-137
mixed, U-136
movingWallVelocity, U-137
outlet, P-65
outletInlet, U-137
partialSlip, U-137
patch, U-134
pressureDirectedInletVelocity, U-137
pressureInletVelocity, U-137
pressureOutlet, P-59
pressureTransmissive, U-137
processor, U-135
setup, U-20
slip, U-137
supersonicFreeStream, U-137
surfaceNormalFixedValue, U-137
symmetryPlane, P-59, U-134
totalPressure, U-137
turbulentInlet, U-137
wall, U-40
wall, P-59, P-65, U-57, U-134
wedge, U-130, U-135, U-144
zeroGradient, U-136
boundary conditions, P-39
Dirichlet, P-39
inlet, P-40
Neumann, P-39
no-slip impermeable wall, P-40
outlet, P-40
physical, P-40
symmetry plane, P-40
boundaryField keyword, U-21, U-108
boundaryFoam solver, U-84
bounded
keyword entry, U-117, U-118
boxToCell keyword, U-58
boxTurb utility, U-88
breaking of a dam, U-55
buoyantBoussinesqPimpleFoam solver, U-86
buoyantBoussinesqSimpleFoam solver, U-86
buoyantPimpleFoam solver, U-86
buoyantPressure
boundary condition, U-137
buoyantSimpleFoam solver, U-86
button
Apply, U-164, U-168
Auto Accept, U-168
Choose Preset, U-166
Delete, U-164
Edit Color Map, U-165
Enable Line Series, U-34
Orientation Axes, U-24, U-167
Refresh Times, U-25
Rescale to Data Range, U-25
Reset, U-164
Set Ambient Color, U-166
Update GUI, U-165
Use Parallel Projection, U-24
Use parallel projection, U-167
C
C++ syntax
/*...*/, U-76
//, U-76
# include, U-70, U-76
cacheAgglomeration keyword, U-123
calculated
Open∇FOAM-2.2.0
Index U-189
boundary condition, U-136
cAlpha keyword, U-61
cases, U-103
castellatedMesh keyword, U-146
castellatedMeshControls
dictionary, U-147–U-149
castellatedMeshControls keyword, U-146
cavitatingDyMFoam solver, U-85
cavitatingFoam solver, U-85
cavity ﬂow, U-17
CEI ARCH
environment variable, U-173
CEI HOME
environment variable, U-173
cell
expansion ratio, U-140
cell class, P-27
cell
keyword entry, U-174
cellLimited
keyword entry, U-117
cellPoint
keyword entry, U-174
cellPointFace
keyword entry, U-174
cells
dictionary, U-136
central diﬀerencing, P-34
cfdTools tools, U-95
cfx4ToFoam utility, U-89, U-154
changeDictionary utility, U-88
Charts window panel, U-168
checkMesh utility, U-89, U-155
chemFoam solver, U-86
chemistryModel
library, U-98
chemistryModel model, U-98
chemistrySolver model, U-98
chemkinToFoam utility, U-94
Choose Preset button, U-166
chtMultiRegionFoam solver, U-86
chtMultiRegionSimpleFoam solver, U-86
Chung
library, U-98
class
cell, P-27
dimensionSet, P-21, P-28, P-29
face, P-27
ﬁniteVolumeCalculus, P-29
ﬁniteVolumeMethod, P-29
fvMesh, P-27
fvSchemes, P-32
fvc, P-32
fvm, P-32
pointField, P-27
polyBoundaryMesh, P-27
polyMesh, P-27, U-127, U-129
polyPatchList, P-27
polyPatch, P-27
scalarField, P-25
scalar, P-19
slice, P-27
symmTensorField, P-25
symmTensorThirdField, P-25
tensorField, P-25
tensorThirdField, P-25
tensor, P-19
vectorField, P-25
vector, P-19, U-107
word, P-21, P-27
class keyword, U-105
clockTime
keyword entry, U-111
cloud keyword, U-175
cmptAv
tensor member function, P-21
Co utility, U-91
coalChemistryFoam solver, U-86
coalCombustion
library, U-96
cofactors
tensor member function, P-21
coldEngineFoam solver, U-86
collapseEdges utility, U-90
Color By menu, U-166
Color Legend window, U-27
Color Legend window panel, U-166
Color Scale window panel, U-166
Colors window panel, U-168
combinePatchFaces utility, U-90
comments, U-76
commsType keyword, U-78
compressed
keyword entry, U-112
compressibleInterDyMFoam solver, U-85
compressibleInterFoam solver, U-85
compressibleLESModels
library, U-100
compressibleRASModels
library, U-99
constant directory, U-104, U-179
constLaminarFlameSpeed model, U-98
constTransport model, U-98, U-180
containers tools, U-95
continuum
mechanics, P-11
control
of time, U-111
Open∇FOAM-2.2.0
U-190 Index
controlDict
dictionary, P-61, U-21, U-30, U-41, U-50,
U-60, U-104, U-160
controlDict ﬁle, P-46
convection, see divergence, P-34
convergence, U-38
conversion
library, U-96
convertToMeters keyword, U-138
coordinate
system, P-11
coordinate system, U-18
corrected
keyword entry, U-117, U-118
Courant number, P-38, U-22
Cp keyword, U-181
cpuTime
keyword entry, U-111
Crank Nicholson
temporal discretisation, P-38
CrankNicholson
keyword entry, U-119
createBaﬄes utility, U-89
createPatch utility, U-89
createTurbulenceFields utility, U-92
cross product, see tensor, vector cross product
CrossPowerLaw
keyword entry, U-59
CrossPowerLaw model, U-100
cubeRootVolDelta model, U-99
cubicCorrected
keyword entry, U-119
cubicCorrection
keyword entry, U-116
curl, P-33
curl
fvc member function, P-33
Current Time Controls menu, U-25, U-165
curve keyword, U-175
Cv keyword, U-182
cyclic
boundary condition, U-135, U-142
cyclic
keyword entry, U-135
cylinder
ﬂow around a, P-41
D
d2dt2
fvc member function, P-33
fvm member function, P-33
dam
breaking of a, U-55
datToFoam utility, U-89
db tools, U-95
ddt
fvc member function, P-33
fvm member function, P-33
DeardorﬀDiﬀStress model, U-100
debug keyword, U-146
decomposePar utility, U-79, U-80, U-94
decomposeParDict
dictionary, U-79
decomposition
of ﬁeld, U-79
of mesh, U-79
decompositionMethods
library, U-96
decompression of a tank, P-58
defaultFieldValues keyword, U-58
deformedGeom utility, U-89
Delete button, U-164
delta keyword, U-81, U-184
deltaT keyword, U-111
dependencies, U-70
dependency lists, U-70
det
tensor member function, P-21
determinant, see tensor, determinant
dev
tensor member function, P-21
diag
tensor member function, P-21
diagonal
keyword entry, U-121, U-122
DIC
keyword entry, U-122
DICGaussSeidel
keyword entry, U-122
dictionary
LESProperties, U-184
PISO, U-23
blockMeshDict, U-18, U-20, U-35, U-48,
U-136, U-144
boundary, U-129, U-136
castellatedMeshControls, U-147–U-149
cells, U-136
controlDict, P-61, U-21, U-30, U-41, U-50,
U-60, U-104, U-160
decomposeParDict, U-79
faces, U-129, U-136
fvSchemes, U-60, U-61, U-104, U-113
fvSolution, U-104, U-120
mechanicalProperties, U-49
neighbour, U-129
owner, U-129
points, U-129, U-136
thermalProperties, U-50
Open∇FOAM-2.2.0
Index U-191
thermophysicalProperties, U-179
transportProperties, U-21, U-38, U-41
turbulenceProperties, U-40, U-59, U-184
dieselMixture model, U-97, U-180
dieselSpray
library, U-96
diﬀerencing
Backward, P-35
blended, P-34
central, P-34
Euler implicit, P-35
Gamma, P-34
MINMOD, P-34
SUPERBEE, P-34
upwind, P-34
van Leer, P-34
DILU
keyword entry, U-122
dimension
checking in OpenFOAM, P-21, U-107
dimensional units, U-107
dimensioned<Type> template class, P-21
dimensionedTypes tools, U-95
dimensions keyword, U-20, U-108
dimensionSet class, P-21, P-28, P-29
dimensionSet tools, U-95
directionMixed
boundary condition, U-136
directory
0.000000e+00, U-104
0, U-104
Make, U-71
constant, U-104, U-179
ﬂuentInterface, U-170
polyMesh, U-104, U-129
processorN, U-80
run, U-103
system, P-46, U-104
tutorials, P-41, U-17
discretisation
equation, P-29
Display window panel, U-23, U-25,
U-164, U-165
distance
keyword entry, U-149, U-175
distributed model, U-96
distributed keyword, U-81, U-82
distributionModels
library, U-96
div
fvc member function, P-33
fvm member function, P-33
divergence, P-33, P-35
divSchemes keyword, U-114
dnsFoam solver, U-86
doLayers keyword, U-146
double inner product, see tensor,double inner
product
dsmc
library, U-96
dsmcFieldsCalc utility, U-92
dsmcFoam solver, U-87
dsmcInitialise utility, U-88
dx
keyword entry, U-174
dynamicFvMesh
library, U-96
dynamicMesh
library, U-96
dynLagrangian model, U-100
dynMixedSmagorinsky model, U-100
dynOneEqEddy model, U-100
dynSmagorinsky model, U-100
E
eConstThermo model, U-98, U-179
edgeGrading keyword, U-140
edgeMesh
library, U-96
edges keyword, U-138
Edit menu, U-167, U-168
Edit Color Map button, U-165
egrMixture model, U-97, U-180
electrostaticFoam solver, U-87
empty
boundary condition, P-59, P-65, U-18,
U-130, U-135
empty
keyword entry, U-135
Enable Line Series button, U-34
endTime keyword, U-22, U-111
energy keyword, U-181
engine
library, U-96
engineCompRatio utility, U-92
engineFoam solver, U-86
engineSwirl utility, U-88
ensight74FoamExec utility, U-172
ENSIGHT7 INPUT
environment variable, U-173
ENSIGHT7 READER
environment variable, U-173
ensightFoamReader utility, U-91
enstrophy utility, U-91
environment variable
CEI ARCH, U-173
CEI HOME, U-173
ENSIGHT7 INPUT, U-173
Open∇FOAM-2.2.0
U-192 Index
ENSIGHT7 READER, U-173
FOAM RUN, U-103
WM ARCH OPTION, U-74
WM ARCH, U-74
WM COMPILER BIN, U-74
WM COMPILER DIR, U-74
WM COMPILER LIB, U-74
WM COMPILER, U-74
WM COMPILE OPTION, U-74
WM DIR, U-74
WM MPLIB, U-74
WM OPTIONS, U-74
WM PRECISION OPTION, U-74
WM PROJECT DIR, U-74
WM PROJECT INST DIR, U-74
WM PROJECT USER DIR, U-74
WM PROJECT VERSION, U-74
WM PROJECT, U-74
wmake, U-73
ePsiThermo model, U-97, U-180
equationOfState keyword, U-181
equilibriumCO utility, U-94
equilibriumFlameT utility, U-94
errorReduction keyword, U-153
Euler
keyword entry, U-119
Euler implicit
diﬀerencing, P-35
temporal discretisation, P-38
examples
decompression of a tank, P-58
ﬂow around a cylinder, P-41
ﬂow over backward step, P-49
Hartmann problem, P-63
supersonic ﬂow over forward step, P-54
execFlowFunctionObjects utility, U-92
expandDictionary utility, U-94
expansionRatio keyword, U-152
explicit
temporal discretisation, P-38
extrude2DMesh utility, U-88
extrudeMesh utility, U-88
extrudeToRegionMesh utility, U-89
F
face class, P-27
face keyword, U-175
faceAgglomerate utility, U-88
faceAreaPair
keyword entry, U-123
faceLimited
keyword entry, U-117
faces
dictionary, U-129, U-136
FDIC
keyword entry, U-122
featureAngle keyword, U-152
features keyword, U-147, U-148
ﬁeld
U, U-22
p, U-22
decomposition, U-79
FieldField<Type> template class, P-28
ﬁeldFunctionObjects
library, U-95
ﬁelds, P-25
mapping, U-160
ﬁelds tools, U-95
fields keyword, U-174
Field<Type> template class, P-25
fieldValues keyword, U-58
ﬁle
Make/ﬁles, U-72
controlDict, P-46
ﬁles, U-71
g, U-59
options, U-71
snappyHexMeshDict, U-145
transportProperties, U-59
ﬁle format, U-104
ﬁleFormats
library, U-96
fileModificationChecking keyword, U-78
fileModificationSkew keyword, U-78
ﬁles ﬁle, U-71
filteredLinear2
keyword entry, U-116
finalLayerThickness keyword, U-152
ﬁnancialFoam solver, U-88
ﬁnite volume
discretisation, P-23
mesh, P-27
ﬁniteVolume
library, U-95
ﬁniteVolume tools, U-95
ﬁniteVolumeCalculus class, P-29
ﬁniteVolumeMethod class, P-29
ﬁreFoam solver, U-86
firstTime keyword, U-111
fixed
keyword entry, U-112
ﬁxedGradient
boundary condition, U-136
ﬁxedValue
boundary condition, U-136
ﬂattenMesh utility, U-89
floatTransfer keyword, U-78
ﬂow
Open∇FOAM-2.2.0
Index U-193
free surface, U-55
laminar, U-17
steady, turbulent, P-49
supersonic, P-55
turbulent, U-17
ﬂow around a cylinder, P-41
ﬂow over backward step, P-49
ﬂowType utility, U-91
ﬂuent3DMeshToFoam utility, U-89
ﬂuentInterface directory, U-170
ﬂuentMeshToFoam utility, U-89, U-154
ﬂuxCorrectedVelocity
boundary condition, U-137
fluxRequired keyword, U-114
OpenFOAM
cases, U-103
FOAM RUN
environment variable, U-103
foamCalc utility, U-32, U-92
foamCalcFunctions
library, U-95
foamCorrectVrt script/alias, U-158
foamDataToFluent utility, U-91, U-170
foamDebugSwitches utility, U-94
FoamFile keyword, U-105
foamFile
keyword entry, U-174
foamFormatConvert utility, U-94
foamInfoExec utility, U-94
foamJob script/alias, U-177
foamListTimes utility, U-92
foamLog script/alias, U-177
foamMeshToFluent utility, U-89, U-170
foamToEnsight utility, U-91
foamToEnsightParts utility, U-91
foamToGMV utility, U-91
foamToStarMesh utility, U-89
foamToSurface utility, U-89
foamToTecplot360 utility, U-91
foamToVTK utility, U-91
foamUpgradeCyclics utility, U-88
foamUpgradeFvSolution utility, U-88
forces
library, U-95
foreground
process, U-24
format keyword, U-105
fourth
keyword entry, U-117, U-118
functions keyword, U-113
fvc class, P-32
fvc member function
curl, P-33
d2dt2, P-33
ddt, P-33
div, P-33
gGrad, P-33
grad, P-33
laplacian, P-33
lsGrad, P-33
snGrad, P-33
snGradCorrection, P-33
sqrGradGrad, P-33
fvDOM
library, U-98
fvm class, P-32
fvm member function
d2dt2, P-33
ddt, P-33
div, P-33
laplacian, P-33
Su, P-33
SuSp, P-33
fvMatrices tools, U-95
fvMatrix template class, P-29
fvMesh class, P-27
fvMesh tools, U-95
fvMotionSolvers
library, U-96
fvSchemes
dictionary, U-60, U-61, U-104, U-113
fvSchemes class, P-32
fvSchemes
menu entry, U-51
fvSolution
dictionary, U-104, U-120
G
g ﬁle, U-59
gambitToFoam utility, U-89, U-154
GAMG
keyword entry, U-52, U-121, U-122
Gamma
keyword entry, U-116
Gamma diﬀerencing, P-34
Gauss
keyword entry, U-117
Gauss’s theorem, P-32
GaussSeidel
keyword entry, U-122
General window panel, U-167, U-168
general
keyword entry, U-112
genericFvPatchField
library, U-96
geometric-algebraic multi-grid, U-122
GeometricBoundaryField template class, P-28
geometricField<Type> template class, P-28
Open∇FOAM-2.2.0
U-194 Index
geometry keyword, U-146
gGrad
fvc member function, P-33
global tools, U-95
gmshToFoam utility, U-89
gnuplot
keyword entry, U-112, U-174
grad
fvc member function, P-33
(Grad Grad) squared, P-33
gradient, P-33, P-36
Gauss scheme, P-36
Gauss’s theorem, U-51
least square ﬁt, U-51
least squares method, P-36, U-51
surface normal, P-36
gradSchemes keyword, U-114
graph tools, U-95
graphFormat keyword, U-112
GuldersEGRLaminarFlameSpeed model, U-98
GuldersLaminarFlameSpeed model, U-98
H
hConstThermo model, U-98, U-179
Help menu, U-167
HerschelBulkley model, U-100
Hf keyword, U-181, U-182
hhuMixtureThermo model, U-97, U-180
hierarchical
keyword entry, U-80, U-81
highCpCoeffs keyword, U-182
homogenousDynSmagorinsky model, U-100
homogeneousMixture model, U-97, U-180
hPolynomialThermo model, U-98, U-179
hPsiMixtureThermo model, U-97, U-180
hPsiThermo model, U-97, U-180
hRhoMixtureThermo model, U-97, U-180
hRhoThermo model, U-97, U-180
hsPsiMixtureThermo model, U-97, U-180
hsPsiThermo model, U-97, U-180
hsRhoMixtureThermo model, U-97, U-180
hsRhoThermo model, U-97, U-180
I
I
tensor member function, P-21
icoFoam solver, U-17, U-21, U-22, U-24, U-84
icoPolynomial model, U-98, U-179
icoUncoupledKinematicParcelDyMFoam solver,
U-86
icoUncoupledKinematicParcelFoam solver, U-87
ideasToFoam utility, U-154
ideasUnvToFoam utility, U-89
identities, see tensor, identities
identity, see tensor, identity
incompressibleLESModels
library, U-100
incompressibleRASModels
library, U-99
incompressibleTransportModels
library, P-50, U-100
incompressibleTurbulenceModels
library, P-50
index
notation, P-12, P-13
Information window panel, U-164
inhomogeneousMixture model, U-97, U-180
inlet
boundary condition, P-65
inletOutlet
boundary condition, U-137
inner product, see tensor, inner product
inotify
keyword entry, U-78
inotifyMaster
keyword entry, U-78
inside
keyword entry, U-149
insideCells utility, U-89
interDyMFoam solver, U-85
interfaceProperties
library, U-100
interfaceProperties model, U-100
interFoam solver, U-85
interMixingFoam solver, U-85
internalField keyword, U-21, U-108
interPhaseChangeFoam solver, U-85
interpolation tools, U-95
interpolationScheme keyword, U-174
interpolations tools, U-95
interpolationSchemes keyword, U-114
inv
tensor member function, P-21
iterations
maximum, U-121
J
janafThermo model, U-98, U-179
jobControl
library, U-95
jplot
keyword entry, U-112, U-174
K
kEpsilon model, U-99
keyword
As, U-182
Cp, U-181
Open∇FOAM-2.2.0
Index U-195
Cv, U-182
FoamFile, U-105
Hf, U-181, U-182
LESModel, U-184
Pr, U-182
RASModel, U-184
Tcommon, U-182
Thigh, U-182
Tlow, U-182
Ts, U-182
addLayersControls, U-146
adjustTimeStep, U-60, U-112
agglomerator, U-123
arc, U-138
blocks, U-20, U-30, U-140
block, U-138
boundaryField, U-21, U-108
boundary, U-141
boxToCell, U-58
cAlpha, U-61
cacheAgglomeration, U-123
castellatedMeshControls, U-146
castellatedMesh, U-146
class, U-105
cloud, U-175
commsType, U-78
convertToMeters, U-138
curve, U-175
debug, U-146
defaultFieldValues, U-58
deltaT, U-111
delta, U-81, U-184
dimensions, U-20, U-108
distributed, U-81, U-82
divSchemes, U-114
doLayers, U-146
edgeGrading, U-140
edges, U-138
endTime, U-22, U-111
energy, U-181
equationOfState, U-181
errorReduction, U-153
expansionRatio, U-152
face, U-175
featureAngle, U-152
features, U-147, U-148
fieldValues, U-58
fields, U-174
fileModificationChecking, U-78
fileModificationSkew, U-78
finalLayerThickness, U-152
firstTime, U-111
floatTransfer, U-78
fluxRequired, U-114
format, U-105
functions, U-113
geometry, U-146
gradSchemes, U-114
graphFormat, U-112
highCpCoeffs, U-182
internalField, U-21, U-108
interpolationSchemes, U-114
interpolationScheme, U-174
laplacianSchemes, U-114
latestTime, U-38
layers, U-152
leastSquares, U-51
levels, U-150
libs, U-78, U-112
locationInMesh, U-148, U-149
location, U-105
lowCpCoeffs, U-182
manualCoeffs, U-81
maxAlphaCo, U-60
maxBoundarySkewness, U-153
maxConcave, U-153
maxCo, U-60, U-112
maxDeltaT, U-60
maxFaceThicknessRatio, U-152
maxGlobalCells, U-148
maxInternalSkewness, U-153
maxIter, U-121
maxLocalCells, U-148
maxNonOrtho, U-153
maxThicknessToMedialRatio, U-152
mergeLevels, U-123
mergePatchPairs, U-138
mergeTolerance, U-146
meshQualityControls, U-146
method, U-81
midPointAndFace, U-175
midPoint, U-175
minArea, U-153
minDeterminant, U-153
minFaceWeight, U-153
minFlatness, U-153
minMedianAxisAngle, U-152
minRefinementCells, U-148
minThickness, U-152
minTriangleTwist, U-153
minTwist, U-153
minVolRatio, U-153
minVol, U-153
mode, U-149
molWeight, U-181
mu, U-182
nAlphaSubCycles, U-61
nBufferCellsNoExtrude, U-152
Open∇FOAM-2.2.0
U-196 Index
nCellsBetweenLevels, U-148
nFaces, U-130
nFinestSweeps, U-123
nGrow, U-152
nLayerIter, U-152
nMoles, U-181
nPostSweeps, U-123
nPreSweeps, U-123
nRelaxIter, U-150, U-152
nRelaxedIter, U-152
nSmoothNormals, U-152
nSmoothPatch, U-150
nSmoothScale, U-153
nSmoothSurfaceNormals, U-152
nSmoothThickness, U-152
nSolveIter, U-150
neighbourPatch, U-142
numberOfSubdomains, U-81
n, U-81
object, U-105
order, U-81
pRefCell, U-23, U-125
pRefValue, U-23, U-125
p rhgRefCell, U-125
p rhgRefValue, U-125
patchMap, U-160
patches, U-138
preconditioner, U-121, U-122
pressure, U-49
printCoeffs, U-41, U-184
processorWeights, U-80
processorWeights, U-81
purgeWrite, U-112
refGradient, U-136
refinementRegions, U-148, U-150
refinementSurfaces, U-148
refinementRegions, U-149
regions, U-58
relTol, U-52, U-121
relativeSizes, U-152
relaxed, U-153
resolveFeatureAngle, U-148
roots, U-81, U-82
runTimeModifiable, U-112
scotchCoeffs, U-81
setFormat, U-174
sets, U-174
simpleGrading, U-140
simulationType, U-40, U-59, U-184
smoother, U-123
snGradSchemes, U-114
snapControls, U-146
snap, U-146
solvers, U-120
solver, U-52, U-121
specie, U-181
spline, U-138
startFace, U-130
startFrom, U-22, U-111
startTime, U-22, U-111
stopAt, U-111
strategy, U-80, U-81
surfaceFormat, U-174
surfaces, U-174
thermoType, U-179
thermodynamics, U-181
timeFormat, U-112
timePrecision, U-112
timeScheme, U-114
tolerance, U-52, U-121, U-150
topoSetSource, U-58
traction, U-49
transport, U-181
turbulence, U-184
type, U-132, U-133
uniform, U-175
valueFraction, U-136
value, U-21, U-136
version, U-105
vertices, U-20, U-138, U-139
writeCompression, U-112
writeControl, U-22, U-60, U-111
writeFormat, U-54, U-112
writeInterval, U-22, U-31, U-111
writePrecision, U-112
<LESModel>Coeffs, U-184
<RASModel>Coeffs, U-184
<delta>Coeffs, U-184
keyword entry
CrankNicholson, U-119
CrossPowerLaw, U-59
DICGaussSeidel, U-122
DIC, U-122
DILU, U-122
Euler, U-119
FDIC, U-122
GAMG, U-52, U-121, U-122
Gamma, U-116
GaussSeidel, U-122
Gauss, U-117
LESModel, U-40, U-184
MGridGen, U-123
MUSCL, U-116
Newtonian, U-59
PBiCG, U-121
PCG, U-121
QUICK, U-119
RASModel, U-40, U-184
Open∇FOAM-2.2.0
Index U-197
SFCD, U-116, U-119
UMIST, U-115
adjustableRunTime, U-60, U-111
arc, U-139
ascii, U-112
backward, U-119
binary, U-112
blocking, U-78
bounded, U-117, U-118
cellLimited, U-117
cellPointFace, U-174
cellPoint, U-174
cell, U-174
clockTime, U-111
compressed, U-112
corrected, U-117, U-118
cpuTime, U-111
cubicCorrected, U-119
cubicCorrection, U-116
cyclic, U-135
diagonal, U-121, U-122
distance, U-149, U-175
dx, U-174
empty, U-135
faceAreaPair, U-123
faceLimited, U-117
filteredLinear2, U-116
fixed, U-112
foamFile, U-174
fourth, U-117, U-118
general, U-112
gnuplot, U-112, U-174
hierarchical, U-80, U-81
inotifyMaster, U-78
inotify, U-78
inside, U-149
jplot, U-112, U-174
laminar, U-40, U-184
latestTime, U-111
leastSquares, U-117
limitedCubic, U-116
limitedLinear, U-116
limited, U-117, U-118
linearUpwind, U-116, U-119
linear, U-116, U-119
line, U-139
localEuler, U-119
manual, U-80, U-81
metis, U-81
midPoint, U-116
nextWrite, U-111
noWriteNow, U-111
nonBlocking, U-78
none, U-115, U-122
null, U-174
outside, U-149
patch, U-135, U-176
polyLine, U-139
polySpline, U-139
processor, U-135
raw, U-112, U-174
runTime, U-31, U-111
scheduled, U-78
scientific, U-112
scotch, U-80, U-81
simpleSpline, U-139
simple, U-80, U-81
skewLinear, U-116, U-119
smoothSolver, U-121
startTime, U-22, U-111
steadyState, U-119
stl, U-174
symmetryPlane, U-135
timeStampMaster, U-78
timeStamp, U-78
timeStep, U-22, U-31, U-111
uncompressed, U-112
uncorrected, U-117, U-118
upwind, U-116, U-119
vanLeer, U-116
vtk, U-174
wall, U-135
wedge, U-135
writeControl, U-111
writeNow, U-111
xmgr, U-112, U-174
xyz, U-175
x, U-175
y, U-175
z, U-175
kivaToFoam utility, U-89
kOmega model, U-99
kOmegaSST model, U-99
kOmegaSSTSAS model, U-100
Kronecker delta, P-16
L
lagrangian
library, U-96
lagrangianIntermediate
library, U-96
Lambda2 utility, U-91
LamBremhorstKE model, U-99
laminar model, U-99
laminar
keyword entry, U-40, U-184
laminarFlameSpeedModels
library, U-98
Open∇FOAM-2.2.0
U-198 Index
laplaceFilter model, U-99
Laplacian, P-34
laplacian, P-33
laplacian
fvc member function, P-33
fvm member function, P-33
laplacianFoam solver, U-83
laplacianSchemes keyword, U-114
latestTime
keyword entry, U-111
latestTime keyword, U-38
LaunderGibsonRSTM model, U-99
LaunderSharmaKE model, U-99
layers keyword, U-152
leastSquares
keyword entry, U-117
leastSquares keyword, U-51
LESdeltas
library, U-99
LESﬁlters
library, U-99
LESModel
keyword entry, U-40, U-184
LESModel keyword, U-184
LESProperties
dictionary, U-184
levels keyword, U-150
libraries, U-67
library
Chung, U-98
LESdeltas, U-99
LESﬁlters, U-99
MGridGenGAMGAgglomeration, U-96
ODE, U-96
OSspeciﬁc, U-96
OpenFOAM, U-95
P1, U-98
PV3FoamReader, U-163
PVFoamReader, U-163
SLGThermo, U-99
Wallis, U-98
autoMesh, U-96
barotropicCompressibilityModels, U-98
basicSolidThermo, U-99
basicThermophysicalModels, U-97
blockMesh, U-96
chemistryModel, U-98
coalCombustion, U-96
compressibleLESModels, U-100
compressibleRASModels, U-99
conversion, U-96
decompositionMethods, U-96
dieselSpray, U-96
distributionModels, U-96
dsmc, U-96
dynamicFvMesh, U-96
dynamicMesh, U-96
edgeMesh, U-96
engine, U-96
ﬁeldFunctionObjects, U-95
ﬁleFormats, U-96
ﬁniteVolume, U-95
foamCalcFunctions, U-95
forces, U-95
fvDOM, U-98
fvMotionSolvers, U-96
genericFvPatchField, U-96
incompressibleLESModels, U-100
incompressibleRASModels, U-99
incompressibleTransportModels, P-50, U-100
incompressibleTurbulenceModels, P-50
interfaceProperties, U-100
jobControl, U-95
lagrangianIntermediate, U-96
lagrangian, U-96
laminarFlameSpeedModels, U-98
linear, U-98
liquidMixtureProperties, U-99
liquidProperties, U-98
meshTools, U-96
molecularMeasurements, U-96
molecule, U-96
pairPatchAgglomeration, U-96
postCalc, U-95
potential, U-96
primitive, P-19
radiationModels, U-98
randomProcesses, U-96
reactionThermophysicalModels, U-97
sampling, U-95
solidMixtureProperties, U-99
solidParticle, U-96
solidProperties, U-99
solid, U-99
specie, U-98
surfMesh, U-96
surfaceFilmModels, U-101
systemCall, U-96
thermalPorousZone, U-99
thermophysicalFunctions, U-98
thermophysical, U-179
topoChangerFvMesh, U-96
triSurface, U-96
twoPhaseInterfaceProperties, U-100
utilityFunctionObjects, U-96
viewFactor, U-98
vtkFoam, U-163
vtkPV3Foam, U-163
Open∇FOAM-2.2.0
Index U-199
libs keyword, U-78, U-112
lid-driven cavity ﬂow, U-17
LienCubicKE model, U-99
LienCubicKELowRe model, U-99
LienLeschzinerLowRe model, U-99
Lights window panel, U-167
limited
keyword entry, U-117, U-118
limitedCubic
keyword entry, U-116
limitedLinear
keyword entry, U-116
line
keyword entry, U-139
Line Style menu, U-34
linear
library, U-98
linear
keyword entry, U-116, U-119
linearUpwind
keyword entry, U-116, U-119
liquid
electrically-conducting, P-63
liquidMixtureProperties
library, U-99
liquidProperties
library, U-98
lists, P-25
List<Type> template class, P-25
localEuler
keyword entry, U-119
location keyword, U-105
locationInMesh keyword, U-148, U-149
locDynOneEqEddy model, U-100
lowCpCoeffs keyword, U-182
lowReOneEqEddy model, U-100
LRDDiﬀStress model, U-100
LRR model, U-99
lsGrad
fvc member function, P-33
LTSInterFoam solver, U-85
LTSReactingParcelFoam solver, U-87
M
Mach utility, U-91
mag
tensor member function, P-21
magneticFoam solver, U-87
magnetohydrodynamics, P-63
magSqr
tensor member function, P-21
Make directory, U-71
make script/alias, U-69
Make/ﬁles ﬁle, U-72
manual
keyword entry, U-80, U-81
manualCoeffs keyword, U-81
mapFields utility, U-30, U-37, U-41, U-54, U-88,
U-160
mapping
ﬁelds, U-160
Marker Style menu, U-34
matrices tools, U-95
max
tensor member function, P-21
maxAlphaCo keyword, U-60
maxBoundarySkewness keyword, U-153
maxCo keyword, U-60, U-112
maxConcave keyword, U-153
maxDeltaT keyword, U-60
maxDeltaxyz model, U-100
maxFaceThicknessRatio keyword, U-152
maxGlobalCells keyword, U-148
maximum iterations, U-121
maxInternalSkewness keyword, U-153
maxIter keyword, U-121
maxLocalCells keyword, U-148
maxNonOrtho keyword, U-153
maxThicknessToMedialRatio keyword, U-152
mdEquilibrationFoam solver, U-87
mdFoam solver, U-87
mdInitialise utility, U-88
mechanicalProperties
dictionary, U-49
memory tools, U-95
menu
Color By, U-166
Current Time Controls, U-25, U-165
Edit, U-167, U-168
Help, U-167
Line Style, U-34
Marker Style, U-34
VCR Controls, U-25, U-165
View, U-167
menu entry
Plot Over Line, U-33
Save Animation, U-169
Save Screenshot, U-169
Settings, U-168
Show Color Legend, U-25
Solid Color, U-166
Toolbars, U-167
View Settings..., U-24
View Settings, U-24, U-167
Wireframe, U-166
fvSchemes, U-51
mergeLevels keyword, U-123
mergeMeshes utility, U-90
Open∇FOAM-2.2.0
U-200 Index
mergeOrSplitBaﬄes utility, U-90
mergePatchPairs keyword, U-138
mergeTolerance keyword, U-146
mesh
1-dimensional, U-130
1D, U-130
2-dimensional, U-130
2D, U-130
axi-symmetric, U-130
basic, P-27
block structured, U-136
decomposition, U-79
description, U-127
ﬁnite volume, P-27
generation, U-136, U-145
grading, U-136, U-140
grading, example of, P-49
non-orthogonal, P-41
reﬁnement, P-58
resolution, U-30
speciﬁcation, U-127
split-hex, U-145
Stereolithography (STL), U-145
surface, U-145
validity constraints, U-127
Mesh Parts window panel, U-23
meshes tools, U-95
meshQualityControls keyword, U-146
meshTools
library, U-96
message passing interface
openMPI, U-81
method keyword, U-81
metis
keyword entry, U-81
MGridGenGAMGAgglomeration
library, U-96
MGridGen
keyword entry, U-123
mhdFoam solver, P-65, U-87
midPoint
keyword entry, U-116
midPoint keyword, U-175
midPointAndFace keyword, U-175
min
tensor member function, P-21
minArea keyword, U-153
minDeterminant keyword, U-153
minFaceWeight keyword, U-153
minFlatness keyword, U-153
minMedianAxisAngle keyword, U-152
MINMOD diﬀerencing, P-34
minRefinementCells keyword, U-148
minThickness keyword, U-152
minTriangleTwist keyword, U-153
minTwist keyword, U-153
minVol keyword, U-153
minVolRatio keyword, U-153
mirrorMesh utility, U-90
mixed
boundary condition, U-136
mixedSmagorinsky model, U-100
mixtureAdiabaticFlameT utility, U-94
mode keyword, U-149
model
APIfunctions, U-98
BirdCarreau, U-100
CrossPowerLaw, U-100
DeardorﬀDiﬀStress, U-100
GuldersEGRLaminarFlameSpeed, U-98
GuldersLaminarFlameSpeed, U-98
HerschelBulkley, U-100
LRDDiﬀStress, U-100
LRR, U-99
LamBremhorstKE, U-99
LaunderGibsonRSTM, U-99
LaunderSharmaKE, U-99
LienCubicKELowRe, U-99
LienCubicKE, U-99
LienLeschzinerLowRe, U-99
NSRDSfunctions, U-98
Newtonian, U-100
NonlinearKEShih, U-99
PrandtlDelta, U-99
RNGkEpsilon, U-99
Smagorinsky2, U-100
Smagorinsky, U-100
SpalartAllmarasDDES, U-100
SpalartAllmarasIDDES, U-100
SpalartAllmaras, U-99, U-100
anisotropicFilter, U-99
basicMultiComponentMixture, U-97, U-180
chemistryModel, U-98
chemistrySolver, U-98
constLaminarFlameSpeed, U-98
constTransport, U-98, U-180
cubeRootVolDelta, U-99
dieselMixture, U-97, U-180
distributed, U-96
dynLagrangian, U-100
dynMixedSmagorinsky, U-100
dynOneEqEddy, U-100
dynSmagorinsky, U-100
eConstThermo, U-98, U-179
ePsiThermo, U-97, U-180
egrMixture, U-97, U-180
hConstThermo, U-98, U-179
hPolynomialThermo, U-98, U-179
Open∇FOAM-2.2.0
Index U-201
hPsiMixtureThermo, U-97, U-180
hPsiThermo, U-97, U-180
hRhoMixtureThermo, U-97, U-180
hRhoThermo, U-97, U-180
hhuMixtureThermo, U-97, U-180
homogenousDynSmagorinsky, U-100
homogeneousMixture, U-97, U-180
hsPsiMixtureThermo, U-97, U-180
hsPsiThermo, U-97, U-180
hsRhoMixtureThermo, U-97, U-180
hsRhoThermo, U-97, U-180
icoPolynomial, U-98, U-179
inhomogeneousMixture, U-97, U-180
interfaceProperties, U-100
janafThermo, U-98, U-179
kEpsilon, U-99
kOmegaSSTSAS, U-100
kOmegaSST, U-99
kOmega, U-99
laminar, U-99
laplaceFilter, U-99
locDynOneEqEddy, U-100
lowReOneEqEddy, U-100
maxDeltaxyz, U-100
mixedSmagorinsky, U-100
multiComponentMixture, U-97, U-180
oneEqEddy, U-100
perfectGas, U-98, U-179
polynomialTransport, U-98, U-180
powerLaw, U-100
ptsotchDecomp, U-97
pureMixture, U-97, U-180
qZeta, U-99
reactingMixture, U-97, U-180
realizableKE, U-99
reconstruct, U-96
scaleSimilarity, U-100
scotchDecomp, U-97
simpleFilter, U-99
smoothDelta, U-100
specieThermo, U-98, U-180
spectEddyVisc, U-100
sutherlandTransport, U-98, U-180
veryInhomogeneousMixture, U-97, U-180
modifyMesh utility, U-90
molecularMeasurements
library, U-96
molecule
library, U-96
molWeight keyword, U-181
moveDynamicMesh utility, U-90
moveEngineMesh utility, U-90
moveMesh utility, U-90
movingWallVelocity
boundary condition, U-137
MPI
openMPI, U-81
MRFInterFoam solver, U-85
MRFMultiphaseInterFoam solver, U-85
mshToFoam utility, U-89
mu keyword, U-182
multiComponentMixture model, U-97, U-180
multigrid
geometric-algebraic, U-122
multiphaseEulerFoam solver, U-85
multiphaseInterFoam solver, U-85
MUSCL
keyword entry, U-116
N
n keyword, U-81
nabla
operator, P-23
nAlphaSubCycles keyword, U-61
nBufferCellsNoExtrude keyword, U-152
nCellsBetweenLevels keyword, U-148
neighbour
dictionary, U-129
neighbourPatch keyword, U-142
netgenNeutralToFoam utility, U-89
Newtonian
keyword entry, U-59
Newtonian model, U-100
nextWrite
keyword entry, U-111
nFaces keyword, U-130
nFinestSweeps keyword, U-123
nGrow keyword, U-152
nLayerIter keyword, U-152
nMoles keyword, U-181
non-orthogonal mesh, P-41
nonBlocking
keyword entry, U-78
none
keyword entry, U-115, U-122
NonlinearKEShih model, U-99
nonNewtonianIcoFoam solver, U-84
noWriteNow
keyword entry, U-111
nPostSweeps keyword, U-123
nPreSweeps keyword, U-123
nRelaxedIter keyword, U-152
nRelaxIter keyword, U-150, U-152
nSmoothNormals keyword, U-152
nSmoothPatch keyword, U-150
nSmoothScale keyword, U-153
nSmoothSurfaceNormals keyword, U-152
nSmoothThickness keyword, U-152
Open∇FOAM-2.2.0
U-202 Index
nSolveIter keyword, U-150
NSRDSfunctions model, U-98
null
keyword entry, U-174
numberOfSubdomains keyword, U-81
O
object keyword, U-105
objToVTK utility, U-90
ODE
library, U-96
oneEqEddy model, U-100
Opacity text box, U-167
OpenFOAM
applications, U-67
ﬁle format, U-104
libraries, U-67
OpenFOAM
library, U-95
OpenFOAM ﬁle syntax
//, U-104
openMPI
message passing interface, U-81
MPI, U-81
operator
scalar, P-24
vector, P-23
Options window, U-168
options ﬁle, U-71
order keyword, U-81
Orientation Axes button, U-24, U-167
OSspeciﬁc
library, U-96
outer product, see tensor, outer product
outlet
boundary condition, P-65
outletInlet
boundary condition, U-137
outside
keyword entry, U-149
owner
dictionary, U-129
P
p ﬁeld, U-22
P1
library, U-98
p rhgRefCell keyword, U-125
p rhgRefValue keyword, U-125
pairPatchAgglomeration
library, U-96
paraFoam, U-23, U-163
parallel
running, U-79
partialSlip
boundary condition, U-137
particleTracks utility, U-92
patch
boundary condition, U-134
patch
keyword entry, U-135, U-176
patchAverage utility, U-92
patches keyword, U-138
patchIntegrate utility, U-92
patchMap keyword, U-160
patchSummary utility, U-94
PBiCG
keyword entry, U-121
PCG
keyword entry, U-121
pdfPlot utility, U-92
PDRFoam solver, U-86
PDRMesh utility, U-90
Pe utility, U-91
perfectGas model, U-98, U-179
permutation symbol, P-15
pimpleDyMFoam solver, U-84
pimpleFoam solver, U-84
Pipeline Browser window, U-23, U-164
PISO
dictionary, U-23
pisoFoam solver, U-17, U-84
Plot Over Line
menu entry, U-33
plot3dToFoam utility, U-89
pointField class, P-27
pointField<Type> template class, P-29
points
dictionary, U-129, U-136
polyBoundaryMesh class, P-27
polyDualMesh utility, U-90
polyLine
keyword entry, U-139
polyMesh directory, U-104, U-129
polyMesh class, P-27, U-127, U-129
polynomialTransport model, U-98, U-180
polyPatch class, P-27
polyPatchList class, P-27
polySpline
keyword entry, U-139
porousInterFoam solver, U-85
porousSimpleFoam solver, U-84
post-processing, U-163
post-processing
paraFoam, U-163
postCalc
library, U-95
postChannel utility, U-92
Open∇FOAM-2.2.0
Index U-203
potential
library, U-96
potentialFoam solver, P-42, U-83
potentialFreeSurfaceFoam solver, U-84
pow
tensor member function, P-21
powerLaw model, U-100
pPrime2 utility, U-91
Pr keyword, U-182
PrandtlDelta model, U-99
preconditioner keyword, U-121, U-122
pRefCell keyword, U-23, U-125
pRefValue keyword, U-23, U-125
pressure keyword, U-49
pressure waves
in liquids, P-58
pressureDirectedInletVelocity
boundary condition, U-137
pressureInletVelocity
boundary condition, U-137
pressureOutlet
boundary condition, P-59
pressureTransmissive
boundary condition, U-137
primitive
library, P-19
primitives tools, U-95
printCoeffs keyword, U-41, U-184
processorWeights keyword, U-80
probeLocations utility, U-92
process
background, U-24, U-79
foreground, U-24
processor
boundary condition, U-135
processor
keyword entry, U-135
processorN directory, U-80
processorWeights keyword, U-81
Properties window panel, U-25, U-164
ptot utility, U-92
ptsotchDecomp model, U-97
pureMixture model, U-97, U-180
purgeWrite keyword, U-112
PV3FoamReader
library, U-163
PVFoamReader
library, U-163
Q
Q utility, U-91
QUICK
keyword entry, U-119
qZeta model, U-99
R
R utility, U-92
radiationModels
library, U-98
randomProcesses
library, U-96
RASModel
keyword entry, U-40, U-184
RASModel keyword, U-184
raw
keyword entry, U-112, U-174
reactingFoam solver, U-86
reactingMixture model, U-97, U-180
reactingParcelFilmFoam solver, U-87
reactingParcelFoam solver, U-87
reactionThermophysicalModels
library, U-97
realizableKE model, U-99
reconstruct model, U-96
reconstructPar utility, U-83, U-94
reconstructParMesh utility, U-94
refGradient keyword, U-136
reﬁneHexMesh utility, U-90
refinementRegions keyword, U-149
reﬁnementLevel utility, U-90
refinementRegions keyword, U-148, U-150
refinementSurfaces keyword, U-148
reﬁneMesh utility, U-90
reﬁneWallLayer utility, U-90
Refresh Times button, U-25
regions keyword, U-58
relative tolerance, U-121
relativeSizes keyword, U-152
relaxed keyword, U-153
relTol keyword, U-52, U-121
removeFaces utility, U-90
Render View window, U-168
Render View window panel, U-168
renumberMesh utility, U-90
Rescale to Data Range button, U-25
Reset button, U-164
resolveFeatureAngle keyword, U-148
restart, U-38
Reynolds number, U-17, U-21
rhoPorousSimpleFoam solver, U-84
rhoCentralDyMFoam solver, U-84
rhoCentralFoam solver, U-84
rhoLTSPimpleFoam solver, U-84
rhoPimpleFoam solver, U-84
rhoPimplecFoam solver, U-84
rhoReactingFoam solver, U-86
rhoSimpleFoam solver, U-84
rhoSimplecFoam solver, U-84
rmdepall script/alias, U-74
Open∇FOAM-2.2.0
U-204 Index
RNGkEpsilon model, U-99
roots keyword, U-81, U-82
rotateMesh utility, U-90
run
parallel, U-79
run directory, U-103
runTime
keyword entry, U-31, U-111
runTimeModifiable keyword, U-112
S
sammToFoam utility, U-89
sample utility, U-92, U-173
sampling
library, U-95
Save Animation
menu entry, U-169
Save Screenshot
menu entry, U-169
scalar, P-12
operator, P-24
scalar class, P-19
scalarField class, P-25
scalarTransportFoam solver, U-83
scale
tensor member function, P-21
scalePoints utility, U-157
scaleSimilarity model, U-100
scheduled
keyword entry, U-78
scientific
keyword entry, U-112
scotch
keyword entry, U-80, U-81
scotchCoeffs keyword, U-81
scotchDecomp model, U-97
script/alias
foamCorrectVrt, U-158
foamJob, U-177
foamLog, U-177
make, U-69
rmdepall, U-74
wclean, U-73
wmake, U-69
second time derivative, P-33
Seed window, U-169
selectCells utility, U-90
Set Ambient Color button, U-166
setFields utility, U-58, U-88
setFormat keyword, U-174
sets keyword, U-174
setSet utility, U-90
setsToZones utility, U-90
Settings
menu entry, U-168
settlingFoam solver, U-86
SFCD
keyword entry, U-116, U-119
shallowWaterFoam solver, U-84
shape, U-140
Show Color Legend
menu entry, U-25
SI units, U-107
simple
keyword entry, U-80, U-81
simpleFilter model, U-99
simpleFoam solver, P-50, U-84
simpleGrading keyword, U-140
simpleReactingParcelFoam solver, U-87
simpleSpline
keyword entry, U-139
simulationType keyword, U-40, U-59, U-184
singleCellMesh utility, U-90
skew
tensor member function, P-21
skewLinear
keyword entry, U-116, U-119
SLGThermo
library, U-99
slice class, P-27
slip
boundary condition, U-137
Smagorinsky model, U-100
Smagorinsky2 model, U-100
smapToFoam utility, U-91
smoothDelta model, U-100
smoother keyword, U-123
smoothSolver
keyword entry, U-121
snap keyword, U-146
snapControls keyword, U-146
snappyHexMesh utility
background mesh, U-146
cell removal, U-149
cell splitting, U-147
mesh layers, U-150
meshing process, U-145
snapping to surfaces, U-150
snappyHexMesh utility, U-89, U-145
snappyHexMeshDict ﬁle, U-145
snGrad
fvc member function, P-33
snGradCorrection
fvc member function, P-33
snGradSchemes keyword, U-114
solid
library, U-99
Solid Color
Open∇FOAM-2.2.0
Index U-205
menu entry, U-166
solidDisplacementFoam solver, U-87
solidDisplacementFoam solver, U-50
solidEquilibriumDisplacementFoam solver, U-87
solidMixtureProperties
library, U-99
solidParticle
library, U-96
solidProperties
library, U-99
solver
LTSInterFoam, U-85
LTSReactingParcelFoam, U-87
MRFInterFoam, U-85
MRFMultiphaseInterFoam, U-85
PDRFoam, U-86
SRFPimpleFoam, U-84
SRFSimpleFoam, U-84
XiFoam, U-86
adjointShapeOptimizationFoam, U-83
blockMesh, P-43
boundaryFoam, U-84
buoyantBoussinesqPimpleFoam, U-86
buoyantBoussinesqSimpleFoam, U-86
buoyantPimpleFoam, U-86
buoyantSimpleFoam, U-86
cavitatingDyMFoam, U-85
cavitatingFoam, U-85
chemFoam, U-86
chtMultiRegionFoam, U-86
chtMultiRegionSimpleFoam, U-86
coalChemistryFoam, U-86
coldEngineFoam, U-86
compressibleInterDyMFoam, U-85
compressibleInterFoam, U-85
dnsFoam, U-86
dsmcFoam, U-87
electrostaticFoam, U-87
engineFoam, U-86
ﬁnancialFoam, U-88
ﬁreFoam, U-86
icoFoam, U-17, U-21, U-22, U-24, U-84
icoUncoupledKinematicParcelDyMFoam,
U-86
icoUncoupledKinematicParcelFoam, U-87
interDyMFoam, U-85
interFoam, U-85
interMixingFoam, U-85
interPhaseChangeFoam, U-85
laplacianFoam, U-83
magneticFoam, U-87
mdEquilibrationFoam, U-87
mdFoam, U-87
mhdFoam, P-65, U-87
multiphaseEulerFoam, U-85
multiphaseInterFoam, U-85
nonNewtonianIcoFoam, U-84
pimpleDyMFoam, U-84
pimpleFoam, U-84
pisoFoam, U-17, U-84
porousInterFoam, U-85
porousSimpleFoam, U-84
potentialFoam, P-42, U-83
potentialFreeSurfaceFoam, U-84
reactingFoam, U-86
reactingParcelFilmFoam, U-87
reactingParcelFoam, U-87
rhoCentralDyMFoam, U-84
rhoCentralFoam, U-84
rhoLTSPimpleFoam, U-84
rhoPimpleFoam, U-84
rhoPimplecFoam, U-84
rhoReactingFoam, U-86
rhoSimpleFoam, U-84
rhoSimplecFoam, U-84
rhoPorousSimpleFoam, U-84
scalarTransportFoam, U-83
settlingFoam, U-86
shallowWaterFoam, U-84
simpleFoam, P-50, U-84
simpleReactingParcelFoam, U-87
solidDisplacementFoam, U-87
solidDisplacementFoam, U-50
solidEquilibriumDisplacementFoam, U-87
sonicDyMFoam, U-84
sonicFoam, P-56, U-85
sonicLiquidFoam, P-59, U-85
sprayEngineFoam, U-87
sprayFoam, U-87
twoLiquidMixingFoam, U-86
twoPhaseEulerFoam, U-86
uncoupledKinematicParcelFoam, U-87
solver keyword, U-52, U-121
solver relative tolerance, U-121
solver tolerance, U-121
solvers keyword, U-120
sonicDyMFoam solver, U-84
sonicFoam solver, P-56, U-85
sonicLiquidFoam solver, P-59, U-85
source, P-33
SpalartAllmaras model, U-99, U-100
SpalartAllmarasDDES model, U-100
SpalartAllmarasIDDES model, U-100
specie
library, U-98
specie keyword, U-181
specieThermo model, U-98, U-180
spectEddyVisc model, U-100
Open∇FOAM-2.2.0
U-206 Index
spline keyword, U-138
splitCells utility, U-91
splitMesh utility, U-90
splitMeshRegions utility, U-90
sprayEngineFoam solver, U-87
sprayFoam solver, U-87
sqr
tensor member function, P-21
sqrGradGrad
fvc member function, P-33
SRFPimpleFoam solver, U-84
SRFSimpleFoam solver, U-84
star3ToFoam utility, U-89
star4ToFoam utility, U-89
startFace keyword, U-130
startFrom keyword, U-22, U-111
starToFoam utility, U-154
startTime
keyword entry, U-22, U-111
startTime keyword, U-22, U-111
steady ﬂow
turbulent, P-49
steadyParticleTracks utility, U-92
steadyState
keyword entry, U-119
Stereolithography (STL), U-145
stitchMesh utility, U-90
stl
keyword entry, U-174
stopAt keyword, U-111
strategy keyword, U-80, U-81
streamFunction utility, U-91
stress analysis of plate with hole, U-45
stressComponents utility, U-91
Style window panel, U-23, U-166
Su
fvm member function, P-33
subsetMesh utility, U-90
summation convention, P-13
SUPERBEE diﬀerencing, P-34
supersonic ﬂow, P-55
supersonic ﬂow over forward step, P-54
supersonicFreeStream
boundary condition, U-137
surface mesh, U-145
surfaceAdd utility, U-93
surfaceAutoPatch utility, U-93
surfaceCheck utility, U-93
surfaceClean utility, U-93
surfaceCoarsen utility, U-93
surfaceConvert utility, U-93
surfaceFeatureConvert utility, U-93
surfaceFeatureExtract utility, U-93, U-148
surfaceField<Type> template class, P-29
surfaceFilmModels
library, U-101
surfaceFind utility, U-93
surfaceFormat keyword, U-174
surfaceInertia utility, U-93
surfaceMesh tools, U-95
surfaceMeshConvert utility, U-93
surfaceMeshConvertTesting utility, U-93
surfaceMeshExport utility, U-93
surfaceMeshImport utility, U-93
surfaceMeshInfo utility, U-93
surfaceMeshTriangulate utility, U-93
surfaceNormalFixedValue
boundary condition, U-137
surfaceOrient utility, U-93
surfacePointMerge utility, U-93
surfaceRedistributePar utility, U-93
surfaceReﬁneRedGreen utility, U-93
surfaces keyword, U-174
surfaceSmooth utility, U-93
surfaceSplitByPatch utility, U-93
surfaceSplitNonManifolds utility, U-94
surfaceSubset utility, U-94
surfaceToPatch utility, U-94
surfaceTransformPoints utility, U-94
surfMesh
library, U-96
SuSp
fvm member function, P-33
sutherlandTransport model, U-98, U-180
symm
tensor member function, P-21
symmetryPlane
boundary condition, P-59, U-134
symmetryPlane
keyword entry, U-135
symmTensorField class, P-25
symmTensorThirdField class, P-25
system directory, P-46, U-104
systemCall
library, U-96
T
T()
tensor member function, P-21
Tcommon keyword, U-182
template class
GeometricBoundaryField, P-28
fvMatrix, P-29
dimensioned<Type>, P-21
FieldField<Type>, P-28
Field<Type>, P-25
geometricField<Type>, P-28
List<Type>, P-25
Open∇FOAM-2.2.0
Index U-207
pointField<Type>, P-29
surfaceField<Type>, P-29
volField<Type>, P-29
temporal discretisation, P-38
Crank Nicholson, P-38
Euler implicit, P-38
explicit, P-38
in OpenFOAM, P-39
tensor, P-11
addition, P-13
algebraic operations, P-13
algebraic operations in OpenFOAM, P-19
antisymmetric, see tensor, skew
calculus, P-23
classes in OpenFOAM, P-19
cofactors, P-18
component average, P-16
component maximum, P-16
component minimum, P-16
determinant, P-18
deviatoric, P-17
diagonal, P-17
dimension, P-12
double inner product, P-15
geometric transformation, P-16
Hodge dual, P-18
hydrostatic, P-17
identities, P-17
identity, P-16
inner product, P-14
inverse, P-18
magnitude, P-16
magnitude squared, P-16
mathematics, P-11
notation, P-13
nth power, P-16
outer product, P-15
rank, P-12
rank 3, P-12
scalar division, P-14
scalar multiplication, P-13
scale function, P-16
second rank, P-12
skew, P-17
square of, P-16
subtraction, P-13
symmetric, P-17
symmetric rank 2, P-12
symmetric rank 3, P-12
trace, P-17
transformation, P-16
transpose, P-12, P-17
triple inner product, P-15
vector cross product, P-15
tensor class, P-19
tensor member function
*, P-21
+, P-21
-, P-21
/, P-21
&, P-21
&&, P-21
^, P-21
cmptAv, P-21
cofactors, P-21
det, P-21
dev, P-21
diag, P-21
I, P-21
inv, P-21
mag, P-21
magSqr, P-21
max, P-21
min, P-21
pow, P-21
scale, P-21
skew, P-21
sqr, P-21
symm, P-21
T(), P-21
tr, P-21
transform, P-21
tensorField class, P-25
tensorThirdField class, P-25
tetgenToFoam utility, U-89
text box
Opacity, U-167
thermalPorousZone
library, U-99
thermalProperties
dictionary, U-50
thermodynamics keyword, U-181
thermophysical
library, U-179
thermophysicalFunctions
library, U-98
thermophysicalProperties
dictionary, U-179
thermoType keyword, U-179
Thigh keyword, U-182
time
control, U-111
time derivative, P-33
ﬁrst, P-35
second, P-33, P-35
time step, U-22
timeFormat keyword, U-112
timePrecision keyword, U-112
Open∇FOAM-2.2.0
U-208 Index
timeScheme keyword, U-114
timeStamp
keyword entry, U-78
timeStampMaster
keyword entry, U-78
timeStep
keyword entry, U-22, U-31, U-111
Tlow keyword, U-182
tolerance
solver, U-121
solver relative, U-121
tolerance keyword, U-52, U-121, U-150
Toolbars
menu entry, U-167
tools
algorithms, U-95
cfdTools, U-95
containers, U-95
db, U-95
dimensionSet, U-95
dimensionedTypes, U-95
ﬁelds, U-95
ﬁniteVolume, U-95
fvMatrices, U-95
fvMesh, U-95
global, U-95
graph, U-95
interpolations, U-95
interpolation, U-95
matrices, U-95
memory, U-95
meshes, U-95
primitives, U-95
surfaceMesh, U-95
volMesh, U-95
topoChangerFvMesh
library, U-96
topoSet utility, U-90
topoSetSource keyword, U-58
totalPressure
boundary condition, U-137
tr
tensor member function, P-21
trace, see tensor, trace
traction keyword, U-49
transform
tensor member function, P-21
transformPoints utility, U-90
transport keyword, U-181
transportProperties
dictionary, U-21, U-38, U-41
transportProperties ﬁle, U-59
triple inner product, P-15
triSurface
library, U-96
Ts keyword, U-182
turbulence
dissipation, U-39
kinetic energy, U-39
length scale, U-40
turbulence keyword, U-184
turbulence model
RAS, U-39
turbulenceProperties
dictionary, U-40, U-59, U-184
turbulent ﬂow
steady, P-49
turbulentInlet
boundary condition, U-137
tutorials
breaking of a dam, U-55
lid-driven cavity ﬂow, U-17
stress analysis of plate with hole, U-45
tutorials directory, P-41, U-17
twoLiquidMixingFoam solver, U-86
twoPhaseEulerFoam solver, U-86
twoPhaseInterfaceProperties
library, U-100
type keyword, U-132, U-133
U
U ﬁeld, U-22
Ucomponents utility, P-66
UMIST
keyword entry, U-115
uncompressed
keyword entry, U-112
uncorrected
keyword entry, U-117, U-118
uncoupledKinematicParcelFoam solver, U-87
uniform keyword, U-175
units
base, U-107
of measurement, P-21, U-107
S.I. base, P-21
SI, U-107
Syst`eme International, U-107
United States Customary System, U-107
USCS, U-107
Update GUI button, U-165
uprime utility, U-91
upwind
keyword entry, U-116, U-119
upwind diﬀerencing, P-34, U-60
USCS units, U-107
Use Parallel Projection button, U-24
Use parallel projection button, U-167
utility
Open∇FOAM-2.2.0
Index U-209
Co, U-91
Lambda2, U-91
Mach, U-91
PDRMesh, U-90
Pe, U-91
Q, U-91
R, U-92
Ucomponents, P-66
adiabaticFlameT, U-94
ansysToFoam, U-89
applyBoundaryLayer, U-88
applyWallFunctionBoundaryConditions,
U-88
attachMesh, U-89
autoPatch, U-89
autoReﬁneMesh, U-90
blockMesh, U-36, U-88, U-136
boxTurb, U-88
cfx4ToFoam, U-89, U-154
changeDictionary, U-88
checkMesh, U-89, U-155
chemkinToFoam, U-94
collapseEdges, U-90
combinePatchFaces, U-90
createBaﬄes, U-89
createPatch, U-89
createTurbulenceFields, U-92
datToFoam, U-89
decomposePar, U-79, U-80, U-94
deformedGeom, U-89
dsmcFieldsCalc, U-92
dsmcInitialise, U-88
engineCompRatio, U-92
engineSwirl, U-88
ensight74FoamExec, U-172
ensightFoamReader, U-91
enstrophy, U-91
equilibriumCO, U-94
equilibriumFlameT, U-94
execFlowFunctionObjects, U-92
expandDictionary, U-94
extrude2DMesh, U-88
extrudeMesh, U-88
extrudeToRegionMesh, U-89
faceAgglomerate, U-88
ﬂattenMesh, U-89
ﬂowType, U-91
ﬂuent3DMeshToFoam, U-89
ﬂuentMeshToFoam, U-89, U-154
foamCalc, U-32, U-92
foamDataToFluent, U-91, U-170
foamDebugSwitches, U-94
foamFormatConvert, U-94
foamInfoExec, U-94
foamListTimes, U-92
foamMeshToFluent, U-89, U-170
foamToEnsightParts, U-91
foamToEnsight, U-91
foamToGMV, U-91
foamToStarMesh, U-89
foamToSurface, U-89
foamToTecplot360, U-91
foamToVTK, U-91
foamUpgradeCyclics, U-88
foamUpgradeFvSolution, U-88
gambitToFoam, U-89, U-154
gmshToFoam, U-89
ideasToFoam, U-154
ideasUnvToFoam, U-89
insideCells, U-89
kivaToFoam, U-89
mapFields, U-30, U-37, U-41, U-54, U-88,
U-160
mdInitialise, U-88
mergeMeshes, U-90
mergeOrSplitBaﬄes, U-90
mirrorMesh, U-90
mixtureAdiabaticFlameT, U-94
modifyMesh, U-90
moveDynamicMesh, U-90
moveEngineMesh, U-90
moveMesh, U-90
mshToFoam, U-89
netgenNeutralToFoam, U-89
objToVTK, U-90
pPrime2, U-91
particleTracks, U-92
patchAverage, U-92
patchIntegrate, U-92
patchSummary, U-94
pdfPlot, U-92
plot3dToFoam, U-89
polyDualMesh, U-90
postChannel, U-92
probeLocations, U-92
ptot, U-92
reconstructParMesh, U-94
reconstructPar, U-83, U-94
reﬁneHexMesh, U-90
reﬁneMesh, U-90
reﬁneWallLayer, U-90
reﬁnementLevel, U-90
removeFaces, U-90
renumberMesh, U-90
rotateMesh, U-90
sammToFoam, U-89
sample, U-92, U-173
scalePoints, U-157
Open∇FOAM-2.2.0
U-210 Index
selectCells, U-90
setFields, U-58, U-88
setSet, U-90
setsToZones, U-90
singleCellMesh, U-90
smapToFoam, U-91
snappyHexMesh, U-89, U-145
splitCells, U-91
splitMeshRegions, U-90
splitMesh, U-90
star3ToFoam, U-89
star4ToFoam, U-89
starToFoam, U-154
steadyParticleTracks, U-92
stitchMesh, U-90
streamFunction, U-91
stressComponents, U-91
subsetMesh, U-90
surfaceAdd, U-93
surfaceAutoPatch, U-93
surfaceCheck, U-93
surfaceClean, U-93
surfaceCoarsen, U-93
surfaceConvert, U-93
surfaceFeatureConvert, U-93
surfaceFeatureExtract, U-93, U-148
surfaceFind, U-93
surfaceInertia, U-93
surfaceMeshConvertTesting, U-93
surfaceMeshConvert, U-93
surfaceMeshExport, U-93
surfaceMeshImport, U-93
surfaceMeshInfo, U-93
surfaceMeshTriangulate, U-93
surfaceOrient, U-93
surfacePointMerge, U-93
surfaceRedistributePar, U-93
surfaceReﬁneRedGreen, U-93
surfaceSmooth, U-93
surfaceSplitByPatch, U-93
surfaceSplitNonManifolds, U-94
surfaceSubset, U-94
surfaceToPatch, U-94
surfaceTransformPoints, U-94
tetgenToFoam, U-89
topoSet, U-90
transformPoints, U-90
uprime, U-91
viewFactorsGen, U-88
vorticity, U-91
wallFunctionTable, U-88
wallGradU, U-91
wallHeatFlux, U-91
wallShearStress, U-92
wdot, U-92
writeCellCentres, U-92
writeMeshObj, U-89
yPlusLES, U-92
yPlusRAS, U-92
zipUpMesh, U-90
utilityFunctionObjects
library, U-96
V
value keyword, U-21, U-136
valueFraction keyword, U-136
van Leer diﬀerencing, P-34
vanLeer
keyword entry, U-116
VCR Controls menu, U-25, U-165
vector, P-12
operator, P-23
unit, P-16
vector class, P-19, U-107
vector product, see tensor, vector cross product
vectorField class, P-25
version keyword, U-105
vertices keyword, U-20, U-138, U-139
veryInhomogeneousMixture model, U-97, U-180
View menu, U-167
View Settings
menu entry, U-24, U-167
View Settings (Render View) window, U-167
View Settings...
menu entry, U-24
viewFactor
library, U-98
viewFactorsGen utility, U-88
viscosity
kinematic, U-21, U-41
volField<Type> template class, P-29
volMesh tools, U-95
vorticity utility, U-91
vtk
keyword entry, U-174
vtkFoam
library, U-163
vtkPV3Foam
library, U-163
W
wall
boundary condition, P-59, P-65, U-57,
U-134
wall
keyword entry, U-135
wallFunctionTable utility, U-88
wallGradU utility, U-91
Open∇FOAM-2.2.0
Index U-211
wallHeatFlux utility, U-91
Wallis
library, U-98
wallShearStress utility, U-92
wclean script/alias, U-73
wdot utility, U-92
wedge
boundary condition, U-130, U-135, U-144
wedge
keyword entry, U-135
window
Color Legend, U-27
Options, U-168
Pipeline Browser, U-23, U-164
Render View, U-168
Seed, U-169
View Settings (Render View), U-167
window panel
Animations, U-168
Annotation, U-24, U-167
Charts, U-168
Color Legend, U-166
Color Scale, U-166
Colors, U-168
Display, U-23, U-25, U-164, U-165
General, U-167, U-168
Information, U-164
Lights, U-167
Mesh Parts, U-23
Properties, U-25, U-164
Render View, U-168
Style, U-23, U-166
Wireframe
menu entry, U-166
WM ARCH
environment variable, U-74
WM ARCH OPTION
environment variable, U-74
WM COMPILE OPTION
environment variable, U-74
WM COMPILER
environment variable, U-74
WM COMPILER BIN
environment variable, U-74
WM COMPILER DIR
environment variable, U-74
WM COMPILER LIB
environment variable, U-74
WM DIR
environment variable, U-74
WM MPLIB
environment variable, U-74
WM OPTIONS
environment variable, U-74
WM PRECISION OPTION
environment variable, U-74
WM PROJECT
environment variable, U-74
WM PROJECT DIR
environment variable, U-74
WM PROJECT INST DIR
environment variable, U-74
WM PROJECT USER DIR
environment variable, U-74
WM PROJECT VERSION
environment variable, U-74
wmake
platforms, U-70
wmake script/alias, U-69
word class, P-21, P-27
writeCellCentres utility, U-92
writeCompression keyword, U-112
writeControl
keyword entry, U-111
writeControl keyword, U-22, U-60, U-111
writeFormat keyword, U-54, U-112
writeInterval keyword, U-22, U-31, U-111
writeMeshObj utility, U-89
writeNow
keyword entry, U-111
writePrecision keyword, U-112
X
x
keyword entry, U-175
XiFoam solver, U-86
xmgr
keyword entry, U-112, U-174
xyz
keyword entry, U-175
Y
y
keyword entry, U-175
yPlusLES utility, U-92
yPlusRAS utility, U-92
Z
z
keyword entry, U-175
zeroGradient
boundary condition, U-136
zipUpMesh utility, U-90
Open∇FOAM-2.2.0
